// Copyright (C) 2026 Ryan Daum <ryan.daum@gmail.com> This program is free
// software: you can redistribute it and/or modify it under the terms of the GNU
// General Public License as published by the Free Software Foundation, version
// 3.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with
// this program. If not, see <https://www.gnu.org/licenses/>.
//

program    = { SOI ~ statements ~ EOI }
statements = { statement* }
statement  = {
    if_statement
  | for_in_statement
  | for_range_statement
  | while_statement
  | labelled_while_statement
  | fork_statement
  | labelled_fork_statement
  | break_statement
  | continue_statement
  | empty_return
  | try_except_statement
  | try_finally_statement
  | fn_statement
  | global_assignment
  | begin_statement
  | expr_statement
  | local_assignment
  | const_assignment
  }

if_statement  = { ^"if" ~ "(" ~ expr ~ ")" ~ statements ~ (elseif_clause)* ~ (else_clause)? ~ endif_clause }
elseif_clause = { ^"elseif" ~ "(" ~ expr ~ ")" ~ statements }
else_clause   = { ^"else" ~ statements }
endif_clause  = { ^"endif" }

for_in_statement    = { ^"for" ~ for_in_index  ~ "in" ~ for_in_clause ~ statements ~ ^"endfor" }
for_in_index = { ident ~ ("," ~ ident)?}
for_range_statement    = { ^"for" ~ ident  ~ "in" ~ for_range_clause ~ statements ~ ^"endfor" }

for_range_clause = { "[" ~ expr ~ ".." ~ expr ~ "]" }
for_in_clause    = { "(" ~ expr ~ ")" }

empty_return = { ^"return" ~ ";"}

labelled_while_statement = { ^"while" ~ ident ~ "(" ~ expr ~ ")" ~ statements ~ ^"endwhile" }
while_statement          = { ^"while" ~ "(" ~ expr ~ ")" ~ statements ~ ^"endwhile" }

fork_statement          = { ^"fork" ~ "(" ~ expr ~ ")" ~ statements ~ ^"endfork" }
labelled_fork_statement = { ^"fork" ~ ident ~ "(" ~ expr ~ ")" ~ statements ~ ^"endfork" }

break_statement    = { ^"break" ~ (ident)? ~ ";" }
continue_statement = { ^"continue" ~ (ident)? ~ ";" }

try_except_statement  = { ^"try" ~ statements ~ (except)+ ~ ^"endtry" }
try_finally_statement = { ^"try" ~ statements ~ ^"finally" ~ statements ~ ^"endtry" }
except                = { ^"except" ~ (labelled_except | unlabelled_except) ~ statements }
labelled_except       = { ident ~ "(" ~ codes ~ ")" }
unlabelled_except     = { "(" ~ codes ~ ")" }

begin_statement       = { begin_keyword ~ statements ~ end_keyword }
begin_keyword         = @{ ^"begin" ~ !ident_continue }
end_keyword           = @{ ^"end" ~ !ident_continue }
global_keyword        = @{ ^"global" ~ !ident_continue }


// Function definitions using fn/endfn
fn_statement = { fn_named | fn_assignment }
fn_named = { ^"fn" ~ ident ~ "(" ~ lambda_params ~ ")" ~ statements ~ ^"endfn" }
fn_assignment = { ident ~ "=" ~ fn_expr ~ ";" }
fn_expr = { ^"fn" ~ "(" ~ lambda_params ~ ")" ~ statements ~ ^"endfn" }

local_assignment = { ^"let" ~ (local_assign_scatter | local_assign_single) ~ ";" }
local_assign_single = { ident ~ (ASSIGN ~ expr)? }
local_assign_scatter = { scatter_assign ~ expr }

const_assignment = { ^"const" ~ (const_assign_scatter | const_assign_single) ~ ";" }
const_assign_single = { ident ~ (ASSIGN ~ expr)? }
const_assign_scatter = { scatter_assign ~ expr }

// range comprehension expression.   {expr for x in (range)}
range_comprehension = { "{" ~ expr ~ "for" ~ ident ~ "in" ~ (for_range_clause | for_in_clause) ~ "}" }

// globally scoped (same as default in MOO) adds explicitly to global scope.
global_assignment = { global_keyword ~ ident ~ (ASSIGN ~ expr)? ~ ";" }

codes   = { anycode | exprlist }
anycode = { ^"any" }

expr_statement   = { (expr)? ~ ";" }

expr = { (integer | (prefix* ~ primary)) ~ postfix* ~ (infix ~ (integer | (prefix* ~ primary)) ~ postfix*)* }

infix    = _{
    add
  | sub
  | mul
  | div
  | modulus
  | land
  | lor
  | eq
  | neq
  | bitshl
  | bitlshr
  | bitshr
  | lte
  | gte
  | lt
  | gt
  | in_range
  | bitand
  | bitor
  | bitxor
  | pow
}
add      =  { "+" }
sub      =  { "-" }
mul      =  { "*" }
div      =  { "/" }
pow      =  { "^" }
modulus  =  { "%" }
land     =  { "&&" }
lor      =  { "||" }
eq       =  { "==" }
neq      =  { "!=" }
lt       =  { "<" }
gt       =  { ">" }
lte      =  { "<=" }
gte      =  { ">=" }
in_range = @{ ^"in" ~ !ident_continue+ }
bitand   =  { "&." }
bitor    =  { "|." }
bitxor   =  { "^." }
bitshl   =  { "<<" }
bitlshr  =  { ">>>" }
bitshr   =  { ">>" }

prefix = _{ neg | not | bitnot | scatter_assign }
// neg only matches when NOT followed by a digit - this allows `-5` to parse as a signed
// integer literal rather than unary negation of 5. Enables `~-5` to parse as `~(-5)`.
neg    =  { "-" ~ !ASCII_DIGIT }
//
not = { "!" }
bitnot = { "~" }

scatter_assign   =  { "{" ~ scatter ~ "}" ~ !"=>" ~ ASSIGN }
scatter          = _{ scatter_item ~ ("," ~ scatter_item)* }
scatter_item     = _{ scatter_optional | scatter_target | scatter_rest }
scatter_optional =  { "?" ~ ident ~ (ASSIGN ~ expr)? }
scatter_target   =  { ident }
scatter_rest     =  { "@" ~ ident }

postfix        = _{ index_range | index_single | verb_call | verb_expr_call | prop | prop_expr | cond_expr | assign | call }
call           =  { arglist }
index_range    =  { "[" ~ expr ~ ".." ~ expr ~ "]" }
index_single   =  { "[" ~ expr ~ "]" }
pass_expr      =  { ^"pass" ~ "(" ~ (exprlist)? ~ ")" }
verb_call      =  { ":" ~ ident ~ arglist }
verb_expr_call =  { ":" ~ "(" ~ expr ~ ")" ~ arglist }
prop           =  { "." ~ ident }
prop_expr      =  { "." ~ "(" ~ expr ~ ")" }
assign         =  { "=" ~ !(">" | "=") ~ expr }
cond_expr      =  { "?" ~ expr ~ "|" ~ expr }
return_expr    =  { ^"return" ~ (expr)? }


primary    = _{
    lambda
  | fn_expr
  | pass_expr
  | builtin_call
  | paren_expr
  | sysprop_call
  | try_expr
  | flyweight
  | map
  | list
  | atom
  | return_expr
  | range_end
  | range_comprehension
}
paren_expr =  { "(" ~ expr ~ ")" }

try_expr     = { "`" ~ expr ~ "!" ~ codes ~ ("=>" ~ expr)? ~ "\'" }
builtin_call = { (ident ~ !(keyword)) ~ arglist }

sysprop      = { "$" ~ ident }
sysprop_call = { sysprop ~ arglist }

boolean = @{ ("true" | "false") ~ !ident_continue }

atom     = { integer | float | string | object | err | sysprop | boolean | symbol | type_constant | literal_binary | ident }
arglist  = { "(" ~ exprlist ~ ")" | "()" }
lambda   = { "{" ~ lambda_params ~ "}" ~ "=>" ~ expr }
lambda_params = { (lambda_param ~ ("," ~ lambda_param)*)? }
lambda_param = { scatter_optional | scatter_target | scatter_rest }

list     = { ("{" ~ exprlist ~ "}" ~ !"=>") | "{}" }

// flyweight is < parent, .slot = value, ..., contents? >
flyweight     = { "<" ~ expr ~ ("," ~ flyweight_slot)* ~ ("," ~ expr)? ~ ">" }
flyweight_slot     = { "." ~ ident ~ "=" ~ expr }

exprlist = { argument ~ ("," ~ argument)* }
argument = { expr | "@" ~ expr }
map      = { ("[" ~ (expr ~ "->" ~ expr) ~ ("," ~ expr ~ "->" ~ expr)* ~ "]") | ( "[" ~ "]" ) }

range_end = { "$" }

// An unambiguous assignment operator, for use in scatter assignments where list comparison could be a false match.
ASSIGN = _{ "=" ~ !("=" | ">") }

err = { errcode ~ ("(" ~ expr ~ ")")? }
errcode = @{ ^"e_" ~ ident_continue+  }

object  = @{ "#" ~ (anonymous_uuid | uuid | integer) }
uuid    = @{ ASCII_HEX_DIGIT{6} ~ "-" ~ ASCII_HEX_DIGIT{10} }
anonymous_uuid = @{ "anon_" ~ ASCII_HEX_DIGIT{6} ~ "-" ~ ASCII_HEX_DIGIT{10} }
// Keywords must be ordered so that longer keywords come before shorter prefixes.
// PEG parsers try alternatives in order, so "else" before "elseif" would match
// the "else" prefix of "elseif" incorrectly. Similarly for if/endif, for/endfor, etc.
// Note: "begin" and "end" are intentionally NOT keywords to preserve backward
// compatibility with existing MOO code that uses them as variable names (e.g., JHCore).
keyword = @{
    ^"endfork"
  | ^"endfor"
  | ^"fork"
  | ^"for"
  | ^"elseif"
  | ^"endif"
  | ^"if"
  | ^"else"
  | ^"return"
  | ^"endwhile"
  | ^"while"
  | ^"continue"
  | ^"break"
  | ^"try"
  | ^"except"
  | ^"endtry"
  | ^"finally"
  | ^"in"
  | ^"let"
  | ^"endfn"
  | ^"fn"
  | err
}

symbol = @{ "'" ~ ident }

ident_start    = _{ "_" | ASCII_ALPHA }
ident_continue = _{ "_" | ASCII_ALPHANUMERIC }

// Type constants use the TYPE_* prefix to avoid conflicts with variable names.
// Legacy forms (INT, OBJ, STR, etc.) are handled by the parser when legacy_type_constants is enabled.
type_constant = @{ (^"type_int" | ^"type_num" | ^"type_float"
                  | ^"type_str"
                  | ^"type_err"
                  | ^"type_obj"
                  | ^"type_list"
                  | ^"type_map"
                  | ^"type_bool"
                  | ^"type_flyweight"
                  | ^"type_binary"
                  | ^"type_lambda"
                  | ^"type_sym") ~ !(ident_continue) }

ident = @{
  // The usual case, identifiers that *don't* start with a keyword
    ((!keyword ~ ident_start) ~ ident_continue* ~ !ident_continue)
  // Identifiers can also start with a reserved keyword followed by more characters
  // This allows "in0", "for1", "if_var", etc.
  | (keyword ~ ident_continue+ ~ !ident_continue)
}

string    = @{ "\"" ~ str_inner ~ "\"" }
str_inner = @{ (!("\"" | "\\" | "\u{0000}" | "\u{001F}") ~ ANY)* ~ (escape ~ str_inner)? }

literal_binary = @{ "b\"" ~ binary_inner ~ "\"" }
binary_inner = @{ (ASCII_ALPHANUMERIC | "+" | "/" | "=" | "_" | "-")* }

integer = @{ ("+" | "-")? ~ number ~ !("." ~ digits) ~ !("e" | "E") }

float          = ${ exponent_float | point_float }
point_float    = ${ digit_part? ~ fraction | digit_part ~ "." }
exponent_float = ${ (point_float | digit_part) ~ (pos_exponent | neg_exponent) }
digit_part     = ${ ("-")? ~ number ~ ("_"? ~ number)* }
fraction       = ${ "." ~ digit_part }
pos_exponent   = ${ ("e" | "E") ~ "+"? ~ digit_part }
neg_exponent   = ${ ("e" | "E") ~ "-" ~ digit_part }

number = @{ "0" | (ASCII_NONZERO_DIGIT ~ digits?) }
digits = @{ (ASCII_DIGIT | ("_" ~ ASCII_DIGIT))+ }

exp = _{ ^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+ }

escape = @{ "\\" ~ ("b" | "t" | "n" | "f" | "r" | "\"" | "\\" | NEWLINE)? }

comment = _{ c_comment | cpp_comment }
c_comment = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
cpp_comment = @{ "//" ~ (!NEWLINE ~ ANY)* }

WHITESPACE = _{ " " | "\t" | "\u{00A0}" | NEWLINE | comment }

// And prepositions can't just be IDENT, because that excludes keywords... like "for"
PREP_CHARACTERS = @{ ASCII_ALPHA+ }
PROPCHARS = @{ ASCII_ALPHANUMERIC | "_" }
