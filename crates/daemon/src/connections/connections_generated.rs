pub use root::*;

const _: () = ::planus::check_version_compatibility("planus-1.2.0");

/// The root namespace
///
/// Generated from these locations:
/// * File `connections.fbs`
#[no_implicit_prelude]
#[allow(dead_code, clippy::needless_lifetimes)]
mod root {
    /// The namespace `MoorConnections`
    ///
    /// Generated from these locations:
    /// * File `connections.fbs`
    pub mod moor_connections {
        /// The table `ByteArray` in the namespace `MoorConnections`
        ///
        /// Generated from these locations:
        /// * Table `ByteArray` in the file `connections.fbs:32`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ByteArray {
            /// The field `data` in the table `ByteArray`
            pub data: ::planus::alloc::vec::Vec<u8>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ByteArray {
            fn default() -> Self {
                Self {
                    data: ::core::default::Default::default(),
                }
            }
        }

        impl ByteArray {
            /// Creates a [ByteArrayBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ByteArrayBuilder<()> {
                ByteArrayBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_data = field_data.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[u8]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_data);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ByteArray>> for ByteArray {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ByteArray> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ByteArray>> for ByteArray {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ByteArray>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ByteArray> for ByteArray {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ByteArray> {
                ByteArray::create(builder, &self.data)
            }
        }

        /// Builder for serializing an instance of the [ByteArray] type.
        ///
        /// Can be created using the [ByteArray::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ByteArrayBuilder<State>(State);

        impl ByteArrayBuilder<()> {
            /// Setter for the [`data` field](ByteArray#structfield.data).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn data<T0>(self, value: T0) -> ByteArrayBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
            {
                ByteArrayBuilder((value,))
            }
        }

        impl<T0> ByteArrayBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ByteArray].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ByteArray>
            where
                Self: ::planus::WriteAsOffset<ByteArray>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAs<::planus::Offset<ByteArray>> for ByteArrayBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ByteArray>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ByteArray> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAsOptional<::planus::Offset<ByteArray>> for ByteArrayBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ByteArray>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ByteArray>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>> ::planus::WriteAsOffset<ByteArray>
            for ByteArrayBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ByteArray> {
                let (v0,) = &self.0;
                ByteArray::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ByteArray].
        #[derive(Copy, Clone)]
        pub struct ByteArrayRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ByteArrayRef<'a> {
            /// Getter for the [`data` field](ByteArray#structfield.data).
            #[inline]
            pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                self.0.access_required(0, "ByteArray", "data")
            }
        }

        impl<'a> ::core::fmt::Debug for ByteArrayRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ByteArrayRef");
                f.field("data", &self.data());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ByteArrayRef<'a>> for ByteArray {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ByteArrayRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    data: value.data()?.to_vec(),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ByteArrayRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ByteArrayRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ByteArrayRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ByteArray>> for ByteArray {
            type Value = ::planus::Offset<ByteArray>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ByteArray>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ByteArrayRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ByteArrayRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ClientAttribute` in the namespace `MoorConnections`
        ///
        /// Generated from these locations:
        /// * Table `ClientAttribute` in the file `connections.fbs:37`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct ClientAttribute {
            /// The field `key` in the table `ClientAttribute`
            pub key: ::planus::alloc::boxed::Box<super::moor_common::Symbol>,
            /// The field `value` in the table `ClientAttribute`
            pub value: ::planus::alloc::boxed::Box<super::moor_var::Var>,
        }

        impl ClientAttribute {
            /// Creates a [ClientAttributeBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ClientAttributeBuilder<()> {
                ClientAttributeBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_key: impl ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
                field_value: impl ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
            ) -> ::planus::Offset<Self> {
                let prepared_key = field_key.prepare(builder);
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<super::moor_common::Symbol>>(0);
                table_writer.write_entry::<::planus::Offset<super::moor_var::Var>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_key);
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ClientAttribute>> for ClientAttribute {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientAttribute> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ClientAttribute>> for ClientAttribute {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientAttribute>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ClientAttribute> for ClientAttribute {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientAttribute> {
                ClientAttribute::create(builder, &self.key, &self.value)
            }
        }

        /// Builder for serializing an instance of the [ClientAttribute] type.
        ///
        /// Can be created using the [ClientAttribute::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ClientAttributeBuilder<State>(State);

        impl ClientAttributeBuilder<()> {
            /// Setter for the [`key` field](ClientAttribute#structfield.key).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn key<T0>(self, value: T0) -> ClientAttributeBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            {
                ClientAttributeBuilder((value,))
            }
        }

        impl<T0> ClientAttributeBuilder<(T0,)> {
            /// Setter for the [`value` field](ClientAttribute#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T1>(self, value: T1) -> ClientAttributeBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
            {
                let (v0,) = self.0;
                ClientAttributeBuilder((v0, value))
            }
        }

        impl<T0, T1> ClientAttributeBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ClientAttribute].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientAttribute>
            where
                Self: ::planus::WriteAsOffset<ClientAttribute>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
        > ::planus::WriteAs<::planus::Offset<ClientAttribute>>
            for ClientAttributeBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<ClientAttribute>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientAttribute> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
        > ::planus::WriteAsOptional<::planus::Offset<ClientAttribute>>
            for ClientAttributeBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<ClientAttribute>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientAttribute>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
        > ::planus::WriteAsOffset<ClientAttribute> for ClientAttributeBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientAttribute> {
                let (v0, v1) = &self.0;
                ClientAttribute::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [ClientAttribute].
        #[derive(Copy, Clone)]
        pub struct ClientAttributeRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ClientAttributeRef<'a> {
            /// Getter for the [`key` field](ClientAttribute#structfield.key).
            #[inline]
            pub fn key(&self) -> ::planus::Result<super::moor_common::SymbolRef<'a>> {
                self.0.access_required(0, "ClientAttribute", "key")
            }

            /// Getter for the [`value` field](ClientAttribute#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<super::moor_var::VarRef<'a>> {
                self.0.access_required(1, "ClientAttribute", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for ClientAttributeRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ClientAttributeRef");
                f.field("key", &self.key());
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ClientAttributeRef<'a>> for ClientAttribute {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ClientAttributeRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    key: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.key()?,
                    )?),
                    value: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.value()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ClientAttributeRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ClientAttributeRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ClientAttributeRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ClientAttribute>> for ClientAttribute {
            type Value = ::planus::Offset<ClientAttribute>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ClientAttribute>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ClientAttributeRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ClientAttributeRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ConnectionRecord` in the namespace `MoorConnections`
        ///
        /// Generated from these locations:
        /// * Table `ConnectionRecord` in the file `connections.fbs:43`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct ConnectionRecord {
            /// The field `client_id_high` in the table `ConnectionRecord`
            pub client_id_high: u64,
            /// The field `client_id_low` in the table `ConnectionRecord`
            pub client_id_low: u64,
            /// The field `connected_secs` in the table `ConnectionRecord`
            pub connected_secs: u64,
            /// The field `connected_nanos` in the table `ConnectionRecord`
            pub connected_nanos: u32,
            /// The field `last_activity_secs` in the table `ConnectionRecord`
            pub last_activity_secs: u64,
            /// The field `last_activity_nanos` in the table `ConnectionRecord`
            pub last_activity_nanos: u32,
            /// The field `last_ping_secs` in the table `ConnectionRecord`
            pub last_ping_secs: u64,
            /// The field `last_ping_nanos` in the table `ConnectionRecord`
            pub last_ping_nanos: u32,
            /// The field `hostname` in the table `ConnectionRecord`
            pub hostname: ::planus::alloc::string::String,
            /// The field `local_port` in the table `ConnectionRecord`
            pub local_port: u16,
            /// The field `remote_port` in the table `ConnectionRecord`
            pub remote_port: u16,
            /// The field `acceptable_content_types` in the table `ConnectionRecord`
            pub acceptable_content_types: ::planus::alloc::vec::Vec<super::moor_common::Symbol>,
            /// The field `client_attributes` in the table `ConnectionRecord`
            pub client_attributes: ::planus::alloc::vec::Vec<self::ClientAttribute>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ConnectionRecord {
            fn default() -> Self {
                Self {
                    client_id_high: 0,
                    client_id_low: 0,
                    connected_secs: 0,
                    connected_nanos: 0,
                    last_activity_secs: 0,
                    last_activity_nanos: 0,
                    last_ping_secs: 0,
                    last_ping_nanos: 0,
                    hostname: ::core::default::Default::default(),
                    local_port: 0,
                    remote_port: 0,
                    acceptable_content_types: ::core::default::Default::default(),
                    client_attributes: ::core::default::Default::default(),
                }
            }
        }

        impl ConnectionRecord {
            /// Creates a [ConnectionRecordBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ConnectionRecordBuilder<()> {
                ConnectionRecordBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_id_high: impl ::planus::WriteAsDefault<u64, u64>,
                field_client_id_low: impl ::planus::WriteAsDefault<u64, u64>,
                field_connected_secs: impl ::planus::WriteAsDefault<u64, u64>,
                field_connected_nanos: impl ::planus::WriteAsDefault<u32, u32>,
                field_last_activity_secs: impl ::planus::WriteAsDefault<u64, u64>,
                field_last_activity_nanos: impl ::planus::WriteAsDefault<u32, u32>,
                field_last_ping_secs: impl ::planus::WriteAsDefault<u64, u64>,
                field_last_ping_nanos: impl ::planus::WriteAsDefault<u32, u32>,
                field_hostname: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_local_port: impl ::planus::WriteAsDefault<u16, u16>,
                field_remote_port: impl ::planus::WriteAsDefault<u16, u16>,
                field_acceptable_content_types: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>,
                >,
                field_client_attributes: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::ClientAttribute>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_client_id_high = field_client_id_high.prepare(builder, &0);
                let prepared_client_id_low = field_client_id_low.prepare(builder, &0);
                let prepared_connected_secs = field_connected_secs.prepare(builder, &0);
                let prepared_connected_nanos = field_connected_nanos.prepare(builder, &0);
                let prepared_last_activity_secs = field_last_activity_secs.prepare(builder, &0);
                let prepared_last_activity_nanos = field_last_activity_nanos.prepare(builder, &0);
                let prepared_last_ping_secs = field_last_ping_secs.prepare(builder, &0);
                let prepared_last_ping_nanos = field_last_ping_nanos.prepare(builder, &0);
                let prepared_hostname = field_hostname.prepare(builder);
                let prepared_local_port = field_local_port.prepare(builder, &0);
                let prepared_remote_port = field_remote_port.prepare(builder, &0);
                let prepared_acceptable_content_types =
                    field_acceptable_content_types.prepare(builder);
                let prepared_client_attributes = field_client_attributes.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<30> =
                    ::core::default::Default::default();
                if prepared_client_id_high.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                if prepared_client_id_low.is_some() {
                    table_writer.write_entry::<u64>(1);
                }
                if prepared_connected_secs.is_some() {
                    table_writer.write_entry::<u64>(2);
                }
                if prepared_last_activity_secs.is_some() {
                    table_writer.write_entry::<u64>(4);
                }
                if prepared_last_ping_secs.is_some() {
                    table_writer.write_entry::<u64>(6);
                }
                if prepared_connected_nanos.is_some() {
                    table_writer.write_entry::<u32>(3);
                }
                if prepared_last_activity_nanos.is_some() {
                    table_writer.write_entry::<u32>(5);
                }
                if prepared_last_ping_nanos.is_some() {
                    table_writer.write_entry::<u32>(7);
                }
                table_writer.write_entry::<::planus::Offset<str>>(8);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>>(11);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::ClientAttribute>]>>(12);
                if prepared_local_port.is_some() {
                    table_writer.write_entry::<u16>(9);
                }
                if prepared_remote_port.is_some() {
                    table_writer.write_entry::<u16>(10);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_client_id_high) =
                            prepared_client_id_high
                        {
                            object_writer.write::<_, _, 8>(&prepared_client_id_high);
                        }
                        if let ::core::option::Option::Some(prepared_client_id_low) =
                            prepared_client_id_low
                        {
                            object_writer.write::<_, _, 8>(&prepared_client_id_low);
                        }
                        if let ::core::option::Option::Some(prepared_connected_secs) =
                            prepared_connected_secs
                        {
                            object_writer.write::<_, _, 8>(&prepared_connected_secs);
                        }
                        if let ::core::option::Option::Some(prepared_last_activity_secs) =
                            prepared_last_activity_secs
                        {
                            object_writer.write::<_, _, 8>(&prepared_last_activity_secs);
                        }
                        if let ::core::option::Option::Some(prepared_last_ping_secs) =
                            prepared_last_ping_secs
                        {
                            object_writer.write::<_, _, 8>(&prepared_last_ping_secs);
                        }
                        if let ::core::option::Option::Some(prepared_connected_nanos) =
                            prepared_connected_nanos
                        {
                            object_writer.write::<_, _, 4>(&prepared_connected_nanos);
                        }
                        if let ::core::option::Option::Some(prepared_last_activity_nanos) =
                            prepared_last_activity_nanos
                        {
                            object_writer.write::<_, _, 4>(&prepared_last_activity_nanos);
                        }
                        if let ::core::option::Option::Some(prepared_last_ping_nanos) =
                            prepared_last_ping_nanos
                        {
                            object_writer.write::<_, _, 4>(&prepared_last_ping_nanos);
                        }
                        object_writer.write::<_, _, 4>(&prepared_hostname);
                        object_writer.write::<_, _, 4>(&prepared_acceptable_content_types);
                        object_writer.write::<_, _, 4>(&prepared_client_attributes);
                        if let ::core::option::Option::Some(prepared_local_port) =
                            prepared_local_port
                        {
                            object_writer.write::<_, _, 2>(&prepared_local_port);
                        }
                        if let ::core::option::Option::Some(prepared_remote_port) =
                            prepared_remote_port
                        {
                            object_writer.write::<_, _, 2>(&prepared_remote_port);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ConnectionRecord>> for ConnectionRecord {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionRecord> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ConnectionRecord>> for ConnectionRecord {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ConnectionRecord>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ConnectionRecord> for ConnectionRecord {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionRecord> {
                ConnectionRecord::create(
                    builder,
                    self.client_id_high,
                    self.client_id_low,
                    self.connected_secs,
                    self.connected_nanos,
                    self.last_activity_secs,
                    self.last_activity_nanos,
                    self.last_ping_secs,
                    self.last_ping_nanos,
                    &self.hostname,
                    self.local_port,
                    self.remote_port,
                    &self.acceptable_content_types,
                    &self.client_attributes,
                )
            }
        }

        /// Builder for serializing an instance of the [ConnectionRecord] type.
        ///
        /// Can be created using the [ConnectionRecord::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ConnectionRecordBuilder<State>(State);

        impl ConnectionRecordBuilder<()> {
            /// Setter for the [`client_id_high` field](ConnectionRecord#structfield.client_id_high).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_id_high<T0>(self, value: T0) -> ConnectionRecordBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                ConnectionRecordBuilder((value,))
            }

            /// Sets the [`client_id_high` field](ConnectionRecord#structfield.client_id_high) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_id_high_as_default(
                self,
            ) -> ConnectionRecordBuilder<(::planus::DefaultValue,)> {
                self.client_id_high(::planus::DefaultValue)
            }
        }

        impl<T0> ConnectionRecordBuilder<(T0,)> {
            /// Setter for the [`client_id_low` field](ConnectionRecord#structfield.client_id_low).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_id_low<T1>(self, value: T1) -> ConnectionRecordBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                ConnectionRecordBuilder((v0, value))
            }

            /// Sets the [`client_id_low` field](ConnectionRecord#structfield.client_id_low) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_id_low_as_default(
                self,
            ) -> ConnectionRecordBuilder<(T0, ::planus::DefaultValue)> {
                self.client_id_low(::planus::DefaultValue)
            }
        }

        impl<T0, T1> ConnectionRecordBuilder<(T0, T1)> {
            /// Setter for the [`connected_secs` field](ConnectionRecord#structfield.connected_secs).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connected_secs<T2>(self, value: T2) -> ConnectionRecordBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1) = self.0;
                ConnectionRecordBuilder((v0, v1, value))
            }

            /// Sets the [`connected_secs` field](ConnectionRecord#structfield.connected_secs) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connected_secs_as_default(
                self,
            ) -> ConnectionRecordBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.connected_secs(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> ConnectionRecordBuilder<(T0, T1, T2)> {
            /// Setter for the [`connected_nanos` field](ConnectionRecord#structfield.connected_nanos).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connected_nanos<T3>(self, value: T3) -> ConnectionRecordBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<u32, u32>,
            {
                let (v0, v1, v2) = self.0;
                ConnectionRecordBuilder((v0, v1, v2, value))
            }

            /// Sets the [`connected_nanos` field](ConnectionRecord#structfield.connected_nanos) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connected_nanos_as_default(
                self,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.connected_nanos(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> ConnectionRecordBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`last_activity_secs` field](ConnectionRecord#structfield.last_activity_secs).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn last_activity_secs<T4>(
                self,
                value: T4,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1, v2, v3) = self.0;
                ConnectionRecordBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`last_activity_secs` field](ConnectionRecord#structfield.last_activity_secs) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn last_activity_secs_as_default(
                self,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.last_activity_secs(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> ConnectionRecordBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`last_activity_nanos` field](ConnectionRecord#structfield.last_activity_nanos).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn last_activity_nanos<T5>(
                self,
                value: T5,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAsDefault<u32, u32>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                ConnectionRecordBuilder((v0, v1, v2, v3, v4, value))
            }

            /// Sets the [`last_activity_nanos` field](ConnectionRecord#structfield.last_activity_nanos) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn last_activity_nanos_as_default(
                self,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                self.last_activity_nanos(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Setter for the [`last_ping_secs` field](ConnectionRecord#structfield.last_ping_secs).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn last_ping_secs<T6>(
                self,
                value: T6,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            where
                T6: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1, v2, v3, v4, v5) = self.0;
                ConnectionRecordBuilder((v0, v1, v2, v3, v4, v5, value))
            }

            /// Sets the [`last_ping_secs` field](ConnectionRecord#structfield.last_ping_secs) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn last_ping_secs_as_default(
                self,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
            {
                self.last_ping_secs(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
            /// Setter for the [`last_ping_nanos` field](ConnectionRecord#structfield.last_ping_nanos).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn last_ping_nanos<T7>(
                self,
                value: T7,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            where
                T7: ::planus::WriteAsDefault<u32, u32>,
            {
                let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                ConnectionRecordBuilder((v0, v1, v2, v3, v4, v5, v6, value))
            }

            /// Sets the [`last_ping_nanos` field](ConnectionRecord#structfield.last_ping_nanos) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn last_ping_nanos_as_default(
                self,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
            {
                self.last_ping_nanos(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
            /// Setter for the [`hostname` field](ConnectionRecord#structfield.hostname).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn hostname<T8>(
                self,
                value: T8,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            where
                T8: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                ConnectionRecordBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8>
            ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
        {
            /// Setter for the [`local_port` field](ConnectionRecord#structfield.local_port).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn local_port<T9>(
                self,
                value: T9,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            where
                T9: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                ConnectionRecordBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
            }

            /// Sets the [`local_port` field](ConnectionRecord#structfield.local_port) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn local_port_as_default(
                self,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, ::planus::DefaultValue)>
            {
                self.local_port(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
            ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
        {
            /// Setter for the [`remote_port` field](ConnectionRecord#structfield.remote_port).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn remote_port<T10>(
                self,
                value: T10,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            where
                T10: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                ConnectionRecordBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
            }

            /// Sets the [`remote_port` field](ConnectionRecord#structfield.remote_port) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn remote_port_as_default(
                self,
            ) -> ConnectionRecordBuilder<(
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                ::planus::DefaultValue,
            )> {
                self.remote_port(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
            ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
        {
            /// Setter for the [`acceptable_content_types` field](ConnectionRecord#structfield.acceptable_content_types).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn acceptable_content_types<T11>(
                self,
                value: T11,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            where
                T11: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>,
                    >,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                ConnectionRecordBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
        {
            /// Setter for the [`client_attributes` field](ConnectionRecord#structfield.client_attributes).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_attributes<T12>(
                self,
                value: T12,
            ) -> ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            where
                T12: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ClientAttribute>]>>,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                ConnectionRecordBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
            ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
        {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectionRecord].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionRecord>
            where
                Self: ::planus::WriteAsOffset<ConnectionRecord>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u32, u32>,
            T4: ::planus::WriteAsDefault<u64, u64>,
            T5: ::planus::WriteAsDefault<u32, u32>,
            T6: ::planus::WriteAsDefault<u64, u64>,
            T7: ::planus::WriteAsDefault<u32, u32>,
            T8: ::planus::WriteAs<::planus::Offset<str>>,
            T9: ::planus::WriteAsDefault<u16, u16>,
            T10: ::planus::WriteAsDefault<u16, u16>,
            T11: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>>,
            T12: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ClientAttribute>]>>,
        > ::planus::WriteAs<::planus::Offset<ConnectionRecord>>
            for ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
        {
            type Prepared = ::planus::Offset<ConnectionRecord>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionRecord> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u32, u32>,
            T4: ::planus::WriteAsDefault<u64, u64>,
            T5: ::planus::WriteAsDefault<u32, u32>,
            T6: ::planus::WriteAsDefault<u64, u64>,
            T7: ::planus::WriteAsDefault<u32, u32>,
            T8: ::planus::WriteAs<::planus::Offset<str>>,
            T9: ::planus::WriteAsDefault<u16, u16>,
            T10: ::planus::WriteAsDefault<u16, u16>,
            T11: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>>,
            T12: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ClientAttribute>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<ConnectionRecord>>
            for ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
        {
            type Prepared = ::planus::Offset<ConnectionRecord>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ConnectionRecord>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u32, u32>,
            T4: ::planus::WriteAsDefault<u64, u64>,
            T5: ::planus::WriteAsDefault<u32, u32>,
            T6: ::planus::WriteAsDefault<u64, u64>,
            T7: ::planus::WriteAsDefault<u32, u32>,
            T8: ::planus::WriteAs<::planus::Offset<str>>,
            T9: ::planus::WriteAsDefault<u16, u16>,
            T10: ::planus::WriteAsDefault<u16, u16>,
            T11: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>>,
            T12: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ClientAttribute>]>>,
        > ::planus::WriteAsOffset<ConnectionRecord>
            for ConnectionRecordBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionRecord> {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = &self.0;
                ConnectionRecord::create(
                    builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                )
            }
        }

        /// Reference to a deserialized [ConnectionRecord].
        #[derive(Copy, Clone)]
        pub struct ConnectionRecordRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ConnectionRecordRef<'a> {
            /// Getter for the [`client_id_high` field](ConnectionRecord#structfield.client_id_high).
            #[inline]
            pub fn client_id_high(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "ConnectionRecord", "client_id_high")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`client_id_low` field](ConnectionRecord#structfield.client_id_low).
            #[inline]
            pub fn client_id_low(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "ConnectionRecord", "client_id_low")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`connected_secs` field](ConnectionRecord#structfield.connected_secs).
            #[inline]
            pub fn connected_secs(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "ConnectionRecord", "connected_secs")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`connected_nanos` field](ConnectionRecord#structfield.connected_nanos).
            #[inline]
            pub fn connected_nanos(&self) -> ::planus::Result<u32> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "ConnectionRecord", "connected_nanos")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`last_activity_secs` field](ConnectionRecord#structfield.last_activity_secs).
            #[inline]
            pub fn last_activity_secs(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(4, "ConnectionRecord", "last_activity_secs")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`last_activity_nanos` field](ConnectionRecord#structfield.last_activity_nanos).
            #[inline]
            pub fn last_activity_nanos(&self) -> ::planus::Result<u32> {
                ::core::result::Result::Ok(
                    self.0
                        .access(5, "ConnectionRecord", "last_activity_nanos")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`last_ping_secs` field](ConnectionRecord#structfield.last_ping_secs).
            #[inline]
            pub fn last_ping_secs(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(6, "ConnectionRecord", "last_ping_secs")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`last_ping_nanos` field](ConnectionRecord#structfield.last_ping_nanos).
            #[inline]
            pub fn last_ping_nanos(&self) -> ::planus::Result<u32> {
                ::core::result::Result::Ok(
                    self.0
                        .access(7, "ConnectionRecord", "last_ping_nanos")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`hostname` field](ConnectionRecord#structfield.hostname).
            #[inline]
            pub fn hostname(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(8, "ConnectionRecord", "hostname")
            }

            /// Getter for the [`local_port` field](ConnectionRecord#structfield.local_port).
            #[inline]
            pub fn local_port(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(9, "ConnectionRecord", "local_port")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`remote_port` field](ConnectionRecord#structfield.remote_port).
            #[inline]
            pub fn remote_port(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(10, "ConnectionRecord", "remote_port")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`acceptable_content_types` field](ConnectionRecord#structfield.acceptable_content_types).
            #[inline]
            pub fn acceptable_content_types(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<super::moor_common::SymbolRef<'a>>>,
            > {
                self.0
                    .access_required(11, "ConnectionRecord", "acceptable_content_types")
            }

            /// Getter for the [`client_attributes` field](ConnectionRecord#structfield.client_attributes).
            #[inline]
            pub fn client_attributes(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::ClientAttributeRef<'a>>>,
            > {
                self.0
                    .access_required(12, "ConnectionRecord", "client_attributes")
            }
        }

        impl<'a> ::core::fmt::Debug for ConnectionRecordRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ConnectionRecordRef");
                f.field("client_id_high", &self.client_id_high());
                f.field("client_id_low", &self.client_id_low());
                f.field("connected_secs", &self.connected_secs());
                f.field("connected_nanos", &self.connected_nanos());
                f.field("last_activity_secs", &self.last_activity_secs());
                f.field("last_activity_nanos", &self.last_activity_nanos());
                f.field("last_ping_secs", &self.last_ping_secs());
                f.field("last_ping_nanos", &self.last_ping_nanos());
                f.field("hostname", &self.hostname());
                f.field("local_port", &self.local_port());
                f.field("remote_port", &self.remote_port());
                f.field("acceptable_content_types", &self.acceptable_content_types());
                f.field("client_attributes", &self.client_attributes());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ConnectionRecordRef<'a>> for ConnectionRecord {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ConnectionRecordRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_id_high: ::core::convert::TryInto::try_into(value.client_id_high()?)?,
                    client_id_low: ::core::convert::TryInto::try_into(value.client_id_low()?)?,
                    connected_secs: ::core::convert::TryInto::try_into(value.connected_secs()?)?,
                    connected_nanos: ::core::convert::TryInto::try_into(value.connected_nanos()?)?,
                    last_activity_secs: ::core::convert::TryInto::try_into(
                        value.last_activity_secs()?,
                    )?,
                    last_activity_nanos: ::core::convert::TryInto::try_into(
                        value.last_activity_nanos()?,
                    )?,
                    last_ping_secs: ::core::convert::TryInto::try_into(value.last_ping_secs()?)?,
                    last_ping_nanos: ::core::convert::TryInto::try_into(value.last_ping_nanos()?)?,
                    hostname: ::core::convert::Into::into(value.hostname()?),
                    local_port: ::core::convert::TryInto::try_into(value.local_port()?)?,
                    remote_port: ::core::convert::TryInto::try_into(value.remote_port()?)?,
                    acceptable_content_types: value.acceptable_content_types()?.to_vec_result()?,
                    client_attributes: value.client_attributes()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ConnectionRecordRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ConnectionRecordRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ConnectionRecordRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ConnectionRecord>> for ConnectionRecord {
            type Value = ::planus::Offset<ConnectionRecord>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ConnectionRecord>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ConnectionRecordRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ConnectionRecordRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ConnectionsRecords` in the namespace `MoorConnections`
        ///
        /// Generated from these locations:
        /// * Table `ConnectionsRecords` in the file `connections.fbs:62`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct ConnectionsRecords {
            /// The field `connections` in the table `ConnectionsRecords`
            pub connections: ::planus::alloc::vec::Vec<self::ConnectionRecord>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ConnectionsRecords {
            fn default() -> Self {
                Self {
                    connections: ::core::default::Default::default(),
                }
            }
        }

        impl ConnectionsRecords {
            /// Creates a [ConnectionsRecordsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ConnectionsRecordsBuilder<()> {
                ConnectionsRecordsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_connections: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::ConnectionRecord>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_connections = field_connections.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::ConnectionRecord>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_connections);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ConnectionsRecords>> for ConnectionsRecords {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionsRecords> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ConnectionsRecords>> for ConnectionsRecords {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ConnectionsRecords>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ConnectionsRecords> for ConnectionsRecords {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionsRecords> {
                ConnectionsRecords::create(builder, &self.connections)
            }
        }

        /// Builder for serializing an instance of the [ConnectionsRecords] type.
        ///
        /// Can be created using the [ConnectionsRecords::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ConnectionsRecordsBuilder<State>(State);

        impl ConnectionsRecordsBuilder<()> {
            /// Setter for the [`connections` field](ConnectionsRecords#structfield.connections).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connections<T0>(self, value: T0) -> ConnectionsRecordsBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ConnectionRecord>]>>,
            {
                ConnectionsRecordsBuilder((value,))
            }
        }

        impl<T0> ConnectionsRecordsBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectionsRecords].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionsRecords>
            where
                Self: ::planus::WriteAsOffset<ConnectionsRecords>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ConnectionRecord>]>>>
            ::planus::WriteAs<::planus::Offset<ConnectionsRecords>>
            for ConnectionsRecordsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ConnectionsRecords>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionsRecords> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ConnectionRecord>]>>>
            ::planus::WriteAsOptional<::planus::Offset<ConnectionsRecords>>
            for ConnectionsRecordsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ConnectionsRecords>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ConnectionsRecords>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ConnectionRecord>]>>>
            ::planus::WriteAsOffset<ConnectionsRecords> for ConnectionsRecordsBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionsRecords> {
                let (v0,) = &self.0;
                ConnectionsRecords::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ConnectionsRecords].
        #[derive(Copy, Clone)]
        pub struct ConnectionsRecordsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ConnectionsRecordsRef<'a> {
            /// Getter for the [`connections` field](ConnectionsRecords#structfield.connections).
            #[inline]
            pub fn connections(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::ConnectionRecordRef<'a>>>,
            > {
                self.0
                    .access_required(0, "ConnectionsRecords", "connections")
            }
        }

        impl<'a> ::core::fmt::Debug for ConnectionsRecordsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ConnectionsRecordsRef");
                f.field("connections", &self.connections());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ConnectionsRecordsRef<'a>> for ConnectionsRecords {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ConnectionsRecordsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    connections: value.connections()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ConnectionsRecordsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ConnectionsRecordsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ConnectionsRecordsRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ConnectionsRecords>> for ConnectionsRecords {
            type Value = ::planus::Offset<ConnectionsRecords>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ConnectionsRecords>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ConnectionsRecordsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ConnectionsRecordsRef]", "read_as_root", 0)
                })
            }
        }
    }
    /// The namespace `MoorCommon`
    ///
    /// Generated from these locations:
    /// * File `../../../schema/schema/common.fbs`
    pub mod moor_common {
        /// The table `VarBytes` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `VarBytes` in the file `../../../schema/schema/common.fbs:30`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VarBytes {
            /// The field `data` in the table `VarBytes`
            pub data: ::planus::alloc::vec::Vec<u8>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarBytes {
            fn default() -> Self {
                Self {
                    data: ::core::default::Default::default(),
                }
            }
        }

        impl VarBytes {
            /// Creates a [VarBytesBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarBytesBuilder<()> {
                VarBytesBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_data = field_data.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[u8]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_data);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarBytes>> for VarBytes {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBytes> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarBytes>> for VarBytes {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarBytes>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarBytes> for VarBytes {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBytes> {
                VarBytes::create(builder, &self.data)
            }
        }

        /// Builder for serializing an instance of the [VarBytes] type.
        ///
        /// Can be created using the [VarBytes::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarBytesBuilder<State>(State);

        impl VarBytesBuilder<()> {
            /// Setter for the [`data` field](VarBytes#structfield.data).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn data<T0>(self, value: T0) -> VarBytesBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
            {
                VarBytesBuilder((value,))
            }
        }

        impl<T0> VarBytesBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarBytes].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBytes>
            where
                Self: ::planus::WriteAsOffset<VarBytes>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAs<::planus::Offset<VarBytes>> for VarBytesBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarBytes>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBytes> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAsOptional<::planus::Offset<VarBytes>> for VarBytesBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarBytes>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarBytes>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>> ::planus::WriteAsOffset<VarBytes>
            for VarBytesBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBytes> {
                let (v0,) = &self.0;
                VarBytes::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarBytes].
        #[derive(Copy, Clone)]
        pub struct VarBytesRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarBytesRef<'a> {
            /// Getter for the [`data` field](VarBytes#structfield.data).
            #[inline]
            pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                self.0.access_required(0, "VarBytes", "data")
            }
        }

        impl<'a> ::core::fmt::Debug for VarBytesRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarBytesRef");
                f.field("data", &self.data());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarBytesRef<'a>> for VarBytes {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarBytesRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    data: value.data()?.to_vec(),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarBytesRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarBytesRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarBytesRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarBytes>> for VarBytes {
            type Value = ::planus::Offset<VarBytes>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarBytes>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarBytesRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarBytesRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Symbol` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `Symbol` in the file `../../../schema/schema/common.fbs:34`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Symbol {
            /// The field `value` in the table `Symbol`
            pub value: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Symbol {
            fn default() -> Self {
                Self {
                    value: ::core::default::Default::default(),
                }
            }
        }

        impl Symbol {
            /// Creates a [SymbolBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> SymbolBuilder<()> {
                SymbolBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Symbol>> for Symbol {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Symbol> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Symbol>> for Symbol {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Symbol>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Symbol> for Symbol {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Symbol> {
                Symbol::create(builder, &self.value)
            }
        }

        /// Builder for serializing an instance of the [Symbol] type.
        ///
        /// Can be created using the [Symbol::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct SymbolBuilder<State>(State);

        impl SymbolBuilder<()> {
            /// Setter for the [`value` field](Symbol#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T0>(self, value: T0) -> SymbolBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                SymbolBuilder((value,))
            }
        }

        impl<T0> SymbolBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Symbol].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Symbol>
            where
                Self: ::planus::WriteAsOffset<Symbol>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<Symbol>> for SymbolBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Symbol>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Symbol> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<Symbol>> for SymbolBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Symbol>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Symbol>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<Symbol>
            for SymbolBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Symbol> {
                let (v0,) = &self.0;
                Symbol::create(builder, v0)
            }
        }

        /// Reference to a deserialized [Symbol].
        #[derive(Copy, Clone)]
        pub struct SymbolRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> SymbolRef<'a> {
            /// Getter for the [`value` field](Symbol#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "Symbol", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for SymbolRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("SymbolRef");
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<SymbolRef<'a>> for Symbol {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: SymbolRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value: ::core::convert::Into::into(value.value()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for SymbolRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for SymbolRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[SymbolRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Symbol>> for Symbol {
            type Value = ::planus::Offset<Symbol>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Symbol>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for SymbolRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[SymbolRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Uuid` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `Uuid` in the file `../../../schema/schema/common.fbs:38`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Uuid {
            /// The field `data` in the table `Uuid`
            pub data: ::planus::alloc::vec::Vec<u8>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Uuid {
            fn default() -> Self {
                Self {
                    data: ::core::default::Default::default(),
                }
            }
        }

        impl Uuid {
            /// Creates a [UuidBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UuidBuilder<()> {
                UuidBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_data = field_data.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[u8]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_data);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Uuid>> for Uuid {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Uuid> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Uuid>> for Uuid {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Uuid>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Uuid> for Uuid {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Uuid> {
                Uuid::create(builder, &self.data)
            }
        }

        /// Builder for serializing an instance of the [Uuid] type.
        ///
        /// Can be created using the [Uuid::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UuidBuilder<State>(State);

        impl UuidBuilder<()> {
            /// Setter for the [`data` field](Uuid#structfield.data).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn data<T0>(self, value: T0) -> UuidBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
            {
                UuidBuilder((value,))
            }
        }

        impl<T0> UuidBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Uuid].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Uuid>
            where
                Self: ::planus::WriteAsOffset<Uuid>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAs<::planus::Offset<Uuid>> for UuidBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Uuid>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Uuid> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAsOptional<::planus::Offset<Uuid>> for UuidBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Uuid>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Uuid>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>> ::planus::WriteAsOffset<Uuid>
            for UuidBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Uuid> {
                let (v0,) = &self.0;
                Uuid::create(builder, v0)
            }
        }

        /// Reference to a deserialized [Uuid].
        #[derive(Copy, Clone)]
        pub struct UuidRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UuidRef<'a> {
            /// Getter for the [`data` field](Uuid#structfield.data).
            #[inline]
            pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                self.0.access_required(0, "Uuid", "data")
            }
        }

        impl<'a> ::core::fmt::Debug for UuidRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UuidRef");
                f.field("data", &self.data());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UuidRef<'a>> for Uuid {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UuidRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    data: value.data()?.to_vec(),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UuidRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UuidRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[UuidRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Uuid>> for Uuid {
            type Value = ::planus::Offset<Uuid>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Uuid>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UuidRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UuidRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `ObjUnion` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Union `ObjUnion` in the file `../../../schema/schema/common.fbs:46`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum ObjUnion {
            /// The variant of type `ObjId` in the union `ObjUnion`
            ObjId(::planus::alloc::boxed::Box<self::ObjId>),

            /// The variant of type `UuObjId` in the union `ObjUnion`
            UuObjId(::planus::alloc::boxed::Box<self::UuObjId>),

            /// The variant of type `AnonymousObjId` in the union `ObjUnion`
            AnonymousObjId(::planus::alloc::boxed::Box<self::AnonymousObjId>),
        }

        impl ObjUnion {
            /// Creates a [ObjUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjUnionBuilder<::planus::Uninitialized> {
                ObjUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_obj_id(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjId>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_uu_obj_id(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::UuObjId>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_anonymous_obj_id(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::AnonymousObjId>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<ObjUnion> for ObjUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::ObjId(value) => Self::create_obj_id(builder, value),
                    Self::UuObjId(value) => Self::create_uu_obj_id(builder, value),
                    Self::AnonymousObjId(value) => Self::create_anonymous_obj_id(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<ObjUnion> for ObjUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [ObjUnion] type.
        ///
        /// Can be created using the [ObjUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjUnionBuilder<T>(T);

        impl ObjUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`ObjId` variant](ObjUnion#variant.ObjId).
            #[inline]
            pub fn obj_id<T>(self, value: T) -> ObjUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjId>,
            {
                ObjUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`UuObjId` variant](ObjUnion#variant.UuObjId).
            #[inline]
            pub fn uu_obj_id<T>(self, value: T) -> ObjUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::UuObjId>,
            {
                ObjUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`AnonymousObjId` variant](ObjUnion#variant.AnonymousObjId).
            #[inline]
            pub fn anonymous_obj_id<T>(
                self,
                value: T,
            ) -> ObjUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::AnonymousObjId>,
            {
                ObjUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> ObjUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [ObjUnion].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<ObjUnion>
            where
                Self: ::planus::WriteAsUnion<ObjUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjId>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<ObjUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjId>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::UuObjId>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<ObjUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::UuObjId>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::AnonymousObjId>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<ObjUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::AnonymousObjId>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [ObjUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum ObjUnionRef<'a> {
            ObjId(self::ObjIdRef<'a>),
            UuObjId(self::UuObjIdRef<'a>),
            AnonymousObjId(self::AnonymousObjIdRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<ObjUnionRef<'a>> for ObjUnion {
            type Error = ::planus::Error;

            fn try_from(value: ObjUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    ObjUnionRef::ObjId(value) => Self::ObjId(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    ObjUnionRef::UuObjId(value) => Self::UuObjId(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    ObjUnionRef::AnonymousObjId(value) => {
                        Self::AnonymousObjId(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for ObjUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::ObjId(::planus::TableRead::from_buffer(
                        buffer,
                        field_offset,
                    )?)),
                    2 => ::core::result::Result::Ok(Self::UuObjId(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::AnonymousObjId(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for ObjUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[ObjUnionRef]";
        }

        /// The table `ObjId` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ObjId` in the file `../../../schema/schema/common.fbs:52`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjId {
            /// The field `id` in the table `ObjId`
            pub id: i32,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ObjId {
            fn default() -> Self {
                Self { id: 0 }
            }
        }

        impl ObjId {
            /// Creates a [ObjIdBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjIdBuilder<()> {
                ObjIdBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_id: impl ::planus::WriteAsDefault<i32, i32>,
            ) -> ::planus::Offset<Self> {
                let prepared_id = field_id.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_id.is_some() {
                    table_writer.write_entry::<i32>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_id) = prepared_id {
                            object_writer.write::<_, _, 4>(&prepared_id);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjId>> for ObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjId>> for ObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjId> for ObjId {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjId> {
                ObjId::create(builder, self.id)
            }
        }

        /// Builder for serializing an instance of the [ObjId] type.
        ///
        /// Can be created using the [ObjId::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjIdBuilder<State>(State);

        impl ObjIdBuilder<()> {
            /// Setter for the [`id` field](ObjId#structfield.id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id<T0>(self, value: T0) -> ObjIdBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<i32, i32>,
            {
                ObjIdBuilder((value,))
            }

            /// Sets the [`id` field](ObjId#structfield.id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id_as_default(self) -> ObjIdBuilder<(::planus::DefaultValue,)> {
                self.id(::planus::DefaultValue)
            }
        }

        impl<T0> ObjIdBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjId].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjId>
            where
                Self: ::planus::WriteAsOffset<ObjId>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i32, i32>> ::planus::WriteAs<::planus::Offset<ObjId>>
            for ObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjId>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i32, i32>>
            ::planus::WriteAsOptional<::planus::Offset<ObjId>> for ObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjId>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<i32, i32>> ::planus::WriteAsOffset<ObjId>
            for ObjIdBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjId> {
                let (v0,) = &self.0;
                ObjId::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjId].
        #[derive(Copy, Clone)]
        pub struct ObjIdRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjIdRef<'a> {
            /// Getter for the [`id` field](ObjId#structfield.id).
            #[inline]
            pub fn id(&self) -> ::planus::Result<i32> {
                ::core::result::Result::Ok(self.0.access(0, "ObjId", "id")?.unwrap_or(0))
            }
        }

        impl<'a> ::core::fmt::Debug for ObjIdRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjIdRef");
                f.field("id", &self.id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjIdRef<'a>> for ObjId {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjIdRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    id: ::core::convert::TryInto::try_into(value.id()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjIdRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjIdRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[ObjIdRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjId>> for ObjId {
            type Value = ::planus::Offset<ObjId>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjId>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjIdRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjIdRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `UuObjId` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `UuObjId` in the file `../../../schema/schema/common.fbs:56`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct UuObjId {
            /// The field `packed_value` in the table `UuObjId`
            pub packed_value: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for UuObjId {
            fn default() -> Self {
                Self { packed_value: 0 }
            }
        }

        impl UuObjId {
            /// Creates a [UuObjIdBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UuObjIdBuilder<()> {
                UuObjIdBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_packed_value: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_packed_value = field_packed_value.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_packed_value.is_some() {
                    table_writer.write_entry::<u64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_packed_value) =
                            prepared_packed_value
                        {
                            object_writer.write::<_, _, 8>(&prepared_packed_value);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<UuObjId>> for UuObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UuObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<UuObjId>> for UuObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UuObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<UuObjId> for UuObjId {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UuObjId> {
                UuObjId::create(builder, self.packed_value)
            }
        }

        /// Builder for serializing an instance of the [UuObjId] type.
        ///
        /// Can be created using the [UuObjId::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UuObjIdBuilder<State>(State);

        impl UuObjIdBuilder<()> {
            /// Setter for the [`packed_value` field](UuObjId#structfield.packed_value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn packed_value<T0>(self, value: T0) -> UuObjIdBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                UuObjIdBuilder((value,))
            }

            /// Sets the [`packed_value` field](UuObjId#structfield.packed_value) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn packed_value_as_default(self) -> UuObjIdBuilder<(::planus::DefaultValue,)> {
                self.packed_value(::planus::DefaultValue)
            }
        }

        impl<T0> UuObjIdBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UuObjId].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<UuObjId>
            where
                Self: ::planus::WriteAsOffset<UuObjId>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAs<::planus::Offset<UuObjId>>
            for UuObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<UuObjId>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UuObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<UuObjId>> for UuObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<UuObjId>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UuObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAsOffset<UuObjId>
            for UuObjIdBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UuObjId> {
                let (v0,) = &self.0;
                UuObjId::create(builder, v0)
            }
        }

        /// Reference to a deserialized [UuObjId].
        #[derive(Copy, Clone)]
        pub struct UuObjIdRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UuObjIdRef<'a> {
            /// Getter for the [`packed_value` field](UuObjId#structfield.packed_value).
            #[inline]
            pub fn packed_value(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0.access(0, "UuObjId", "packed_value")?.unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for UuObjIdRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UuObjIdRef");
                f.field("packed_value", &self.packed_value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UuObjIdRef<'a>> for UuObjId {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UuObjIdRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    packed_value: ::core::convert::TryInto::try_into(value.packed_value()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UuObjIdRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UuObjIdRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[UuObjIdRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<UuObjId>> for UuObjId {
            type Value = ::planus::Offset<UuObjId>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<UuObjId>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UuObjIdRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UuObjIdRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `AnonymousObjId` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `AnonymousObjId` in the file `../../../schema/schema/common.fbs:61`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct AnonymousObjId {
            /// The field `packed_value` in the table `AnonymousObjId`
            pub packed_value: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for AnonymousObjId {
            fn default() -> Self {
                Self { packed_value: 0 }
            }
        }

        impl AnonymousObjId {
            /// Creates a [AnonymousObjIdBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AnonymousObjIdBuilder<()> {
                AnonymousObjIdBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_packed_value: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_packed_value = field_packed_value.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_packed_value.is_some() {
                    table_writer.write_entry::<u64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_packed_value) =
                            prepared_packed_value
                        {
                            object_writer.write::<_, _, 8>(&prepared_packed_value);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<AnonymousObjId>> for AnonymousObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AnonymousObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<AnonymousObjId>> for AnonymousObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AnonymousObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<AnonymousObjId> for AnonymousObjId {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AnonymousObjId> {
                AnonymousObjId::create(builder, self.packed_value)
            }
        }

        /// Builder for serializing an instance of the [AnonymousObjId] type.
        ///
        /// Can be created using the [AnonymousObjId::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AnonymousObjIdBuilder<State>(State);

        impl AnonymousObjIdBuilder<()> {
            /// Setter for the [`packed_value` field](AnonymousObjId#structfield.packed_value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn packed_value<T0>(self, value: T0) -> AnonymousObjIdBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                AnonymousObjIdBuilder((value,))
            }

            /// Sets the [`packed_value` field](AnonymousObjId#structfield.packed_value) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn packed_value_as_default(
                self,
            ) -> AnonymousObjIdBuilder<(::planus::DefaultValue,)> {
                self.packed_value(::planus::DefaultValue)
            }
        }

        impl<T0> AnonymousObjIdBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AnonymousObjId].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<AnonymousObjId>
            where
                Self: ::planus::WriteAsOffset<AnonymousObjId>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAs<::planus::Offset<AnonymousObjId>> for AnonymousObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<AnonymousObjId>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AnonymousObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<AnonymousObjId>>
            for AnonymousObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<AnonymousObjId>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AnonymousObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAsOffset<AnonymousObjId>
            for AnonymousObjIdBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AnonymousObjId> {
                let (v0,) = &self.0;
                AnonymousObjId::create(builder, v0)
            }
        }

        /// Reference to a deserialized [AnonymousObjId].
        #[derive(Copy, Clone)]
        pub struct AnonymousObjIdRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AnonymousObjIdRef<'a> {
            /// Getter for the [`packed_value` field](AnonymousObjId#structfield.packed_value).
            #[inline]
            pub fn packed_value(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "AnonymousObjId", "packed_value")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for AnonymousObjIdRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AnonymousObjIdRef");
                f.field("packed_value", &self.packed_value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AnonymousObjIdRef<'a>> for AnonymousObjId {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AnonymousObjIdRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    packed_value: ::core::convert::TryInto::try_into(value.packed_value()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AnonymousObjIdRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AnonymousObjIdRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[AnonymousObjIdRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<AnonymousObjId>> for AnonymousObjId {
            type Value = ::planus::Offset<AnonymousObjId>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<AnonymousObjId>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AnonymousObjIdRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AnonymousObjIdRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Obj` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `Obj` in the file `../../../schema/schema/common.fbs:66`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Obj {
            /// The field `obj` in the table `Obj`
            pub obj: self::ObjUnion,
        }

        impl Obj {
            /// Creates a [ObjBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjBuilder<()> {
                ObjBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAsUnion<self::ObjUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ObjUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj.offset());
                        object_writer.write::<_, _, 1>(&prepared_obj.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Obj>> for Obj {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Obj> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Obj>> for Obj {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Obj>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Obj> for Obj {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Obj> {
                Obj::create(builder, &self.obj)
            }
        }

        /// Builder for serializing an instance of the [Obj] type.
        ///
        /// Can be created using the [Obj::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjBuilder<State>(State);

        impl ObjBuilder<()> {
            /// Setter for the [`obj` field](Obj#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> ObjBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::ObjUnion>,
            {
                ObjBuilder((value,))
            }
        }

        impl<T0> ObjBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Obj].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Obj>
            where
                Self: ::planus::WriteAsOffset<Obj>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjUnion>> ::planus::WriteAs<::planus::Offset<Obj>>
            for ObjBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Obj>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Obj> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjUnion>>
            ::planus::WriteAsOptional<::planus::Offset<Obj>> for ObjBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Obj>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Obj>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjUnion>> ::planus::WriteAsOffset<Obj>
            for ObjBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Obj> {
                let (v0,) = &self.0;
                Obj::create(builder, v0)
            }
        }

        /// Reference to a deserialized [Obj].
        #[derive(Copy, Clone)]
        pub struct ObjRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjRef<'a> {
            /// Getter for the [`obj` field](Obj#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjUnionRef<'a>> {
                self.0.access_union_required(0, "Obj", "obj")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjRef");
                f.field("obj", &self.obj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjRef<'a>> for Obj {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::core::convert::TryInto::try_into(value.obj()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[ObjRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Obj>> for Obj {
            type Value = ::planus::Offset<Obj>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Obj>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| error_kind.with_error_location("[ObjRef]", "read_as_root", 0))
            }
        }

        /// The enum `ErrorCode` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Enum `ErrorCode` in the file `../../../schema/schema/common.fbs:74`
        #[derive(
            Copy,
            Clone,
            Debug,
            PartialEq,
            Eq,
            PartialOrd,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        #[repr(u8)]
        pub enum ErrorCode {
            /// The variant `E_NONE` in the enum `ErrorCode`
            ENone = 0,

            /// The variant `E_TYPE` in the enum `ErrorCode`
            EType = 1,

            /// The variant `E_DIV` in the enum `ErrorCode`
            EDiv = 2,

            /// The variant `E_PERM` in the enum `ErrorCode`
            EPerm = 3,

            /// The variant `E_PROPNF` in the enum `ErrorCode`
            EPropnf = 4,

            /// The variant `E_VERBNF` in the enum `ErrorCode`
            EVerbnf = 5,

            /// The variant `E_VARNF` in the enum `ErrorCode`
            EVarnf = 6,

            /// The variant `E_INVIND` in the enum `ErrorCode`
            EInvind = 7,

            /// The variant `E_RECMOVE` in the enum `ErrorCode`
            ERecmove = 8,

            /// The variant `E_MAXREC` in the enum `ErrorCode`
            EMaxrec = 9,

            /// The variant `E_RANGE` in the enum `ErrorCode`
            ERange = 10,

            /// The variant `E_ARGS` in the enum `ErrorCode`
            EArgs = 11,

            /// The variant `E_NACC` in the enum `ErrorCode`
            ENacc = 12,

            /// The variant `E_INVARG` in the enum `ErrorCode`
            EInvarg = 13,

            /// The variant `E_QUOTA` in the enum `ErrorCode`
            EQuota = 14,

            /// The variant `E_FLOAT` in the enum `ErrorCode`
            EFloat = 15,

            /// The variant `E_FILE` in the enum `ErrorCode`
            EFile = 16,

            /// The variant `E_EXEC` in the enum `ErrorCode`
            EExec = 17,

            /// The variant `E_INTRPT` in the enum `ErrorCode`
            EIntrpt = 18,

            /// The variant `ErrCustom` in the enum `ErrorCode`
            ErrCustom = 255,
        }

        impl ErrorCode {
            /// Array containing all valid variants of ErrorCode
            pub const ENUM_VALUES: [Self; 20] = [
                Self::ENone,
                Self::EType,
                Self::EDiv,
                Self::EPerm,
                Self::EPropnf,
                Self::EVerbnf,
                Self::EVarnf,
                Self::EInvind,
                Self::ERecmove,
                Self::EMaxrec,
                Self::ERange,
                Self::EArgs,
                Self::ENacc,
                Self::EInvarg,
                Self::EQuota,
                Self::EFloat,
                Self::EFile,
                Self::EExec,
                Self::EIntrpt,
                Self::ErrCustom,
            ];
        }

        impl ::core::convert::TryFrom<u8> for ErrorCode {
            type Error = ::planus::errors::UnknownEnumTagKind;
            #[inline]
            fn try_from(
                value: u8,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind> {
                #[allow(clippy::match_single_binding)]
                match value {
                    0 => ::core::result::Result::Ok(ErrorCode::ENone),
                    1 => ::core::result::Result::Ok(ErrorCode::EType),
                    2 => ::core::result::Result::Ok(ErrorCode::EDiv),
                    3 => ::core::result::Result::Ok(ErrorCode::EPerm),
                    4 => ::core::result::Result::Ok(ErrorCode::EPropnf),
                    5 => ::core::result::Result::Ok(ErrorCode::EVerbnf),
                    6 => ::core::result::Result::Ok(ErrorCode::EVarnf),
                    7 => ::core::result::Result::Ok(ErrorCode::EInvind),
                    8 => ::core::result::Result::Ok(ErrorCode::ERecmove),
                    9 => ::core::result::Result::Ok(ErrorCode::EMaxrec),
                    10 => ::core::result::Result::Ok(ErrorCode::ERange),
                    11 => ::core::result::Result::Ok(ErrorCode::EArgs),
                    12 => ::core::result::Result::Ok(ErrorCode::ENacc),
                    13 => ::core::result::Result::Ok(ErrorCode::EInvarg),
                    14 => ::core::result::Result::Ok(ErrorCode::EQuota),
                    15 => ::core::result::Result::Ok(ErrorCode::EFloat),
                    16 => ::core::result::Result::Ok(ErrorCode::EFile),
                    17 => ::core::result::Result::Ok(ErrorCode::EExec),
                    18 => ::core::result::Result::Ok(ErrorCode::EIntrpt),
                    255 => ::core::result::Result::Ok(ErrorCode::ErrCustom),

                    _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                        tag: value as i128,
                    }),
                }
            }
        }

        impl ::core::convert::From<ErrorCode> for u8 {
            #[inline]
            fn from(value: ErrorCode) -> Self {
                value as u8
            }
        }

        /// # Safety
        /// The Planus compiler correctly calculates `ALIGNMENT` and `SIZE`.
        unsafe impl ::planus::Primitive for ErrorCode {
            const ALIGNMENT: usize = 1;
            const SIZE: usize = 1;
        }

        impl ::planus::WriteAsPrimitive<ErrorCode> for ErrorCode {
            #[inline]
            fn write<const N: usize>(&self, cursor: ::planus::Cursor<'_, N>, buffer_position: u32) {
                (*self as u8).write(cursor, buffer_position);
            }
        }

        impl ::planus::WriteAs<ErrorCode> for ErrorCode {
            type Prepared = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> ErrorCode {
                *self
            }
        }

        impl ::planus::WriteAsDefault<ErrorCode, ErrorCode> for ErrorCode {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
                default: &ErrorCode,
            ) -> ::core::option::Option<ErrorCode> {
                if self == default {
                    ::core::option::Option::None
                } else {
                    ::core::option::Option::Some(*self)
                }
            }
        }

        impl ::planus::WriteAsOptional<ErrorCode> for ErrorCode {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<ErrorCode> {
                ::core::option::Option::Some(*self)
            }
        }

        impl<'buf> ::planus::TableRead<'buf> for ErrorCode {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
            }
        }

        impl<'buf> ::planus::VectorReadInner<'buf> for ErrorCode {
            type Error = ::planus::errors::UnknownEnumTag;
            const STRIDE: usize = 1;
            #[inline]
            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag> {
                let value = unsafe { *buffer.buffer.get_unchecked(offset) };
                let value: ::core::result::Result<Self, _> =
                    ::core::convert::TryInto::try_into(value);
                value.map_err(|error_kind| {
                    error_kind.with_error_location(
                        "ErrorCode",
                        "VectorRead::from_buffer",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<ErrorCode> for ErrorCode {
            const STRIDE: usize = 1;

            type Value = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                *self
            }

            #[inline]
            unsafe fn write_values(
                values: &[Self],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - i as u32,
                    );
                }
            }
        }

        /// The table `Error` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `Error` in the file `../../../schema/schema/common.fbs:97`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct Error {
            /// The field `err_type` in the table `Error`
            pub err_type: self::ErrorCode,
            /// The field `msg` in the table `Error`
            pub msg: ::core::option::Option<::planus::alloc::string::String>,
            /// The field `value` in the table `Error`
            pub value: ::core::option::Option<::planus::alloc::boxed::Box<super::moor_var::Var>>,
            /// The field `custom_symbol` in the table `Error`
            pub custom_symbol: ::core::option::Option<::planus::alloc::boxed::Box<self::Symbol>>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Error {
            fn default() -> Self {
                Self {
                    err_type: self::ErrorCode::ENone,
                    msg: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    custom_symbol: ::core::default::Default::default(),
                }
            }
        }

        impl Error {
            /// Creates a [ErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ErrorBuilder<()> {
                ErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_err_type: impl ::planus::WriteAsDefault<self::ErrorCode, self::ErrorCode>,
                field_msg: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                field_value: impl ::planus::WriteAsOptional<::planus::Offset<super::moor_var::Var>>,
                field_custom_symbol: impl ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_err_type = field_err_type.prepare(builder, &self::ErrorCode::ENone);
                let prepared_msg = field_msg.prepare(builder);
                let prepared_value = field_value.prepare(builder);
                let prepared_custom_symbol = field_custom_symbol.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                if prepared_msg.is_some() {
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                }
                if prepared_value.is_some() {
                    table_writer.write_entry::<::planus::Offset<super::moor_var::Var>>(2);
                }
                if prepared_custom_symbol.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::Symbol>>(3);
                }
                if prepared_err_type.is_some() {
                    table_writer.write_entry::<self::ErrorCode>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_msg) = prepared_msg {
                            object_writer.write::<_, _, 4>(&prepared_msg);
                        }
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            object_writer.write::<_, _, 4>(&prepared_value);
                        }
                        if let ::core::option::Option::Some(prepared_custom_symbol) =
                            prepared_custom_symbol
                        {
                            object_writer.write::<_, _, 4>(&prepared_custom_symbol);
                        }
                        if let ::core::option::Option::Some(prepared_err_type) = prepared_err_type {
                            object_writer.write::<_, _, 1>(&prepared_err_type);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Error>> for Error {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Error> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Error>> for Error {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Error>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Error> for Error {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Error> {
                Error::create(
                    builder,
                    self.err_type,
                    &self.msg,
                    &self.value,
                    &self.custom_symbol,
                )
            }
        }

        /// Builder for serializing an instance of the [Error] type.
        ///
        /// Can be created using the [Error::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ErrorBuilder<State>(State);

        impl ErrorBuilder<()> {
            /// Setter for the [`err_type` field](Error#structfield.err_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn err_type<T0>(self, value: T0) -> ErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<self::ErrorCode, self::ErrorCode>,
            {
                ErrorBuilder((value,))
            }

            /// Sets the [`err_type` field](Error#structfield.err_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn err_type_as_default(self) -> ErrorBuilder<(::planus::DefaultValue,)> {
                self.err_type(::planus::DefaultValue)
            }
        }

        impl<T0> ErrorBuilder<(T0,)> {
            /// Setter for the [`msg` field](Error#structfield.msg).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn msg<T1>(self, value: T1) -> ErrorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            {
                let (v0,) = self.0;
                ErrorBuilder((v0, value))
            }

            /// Sets the [`msg` field](Error#structfield.msg) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn msg_as_null(self) -> ErrorBuilder<(T0, ())> {
                self.msg(())
            }
        }

        impl<T0, T1> ErrorBuilder<(T0, T1)> {
            /// Setter for the [`value` field](Error#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T2>(self, value: T2) -> ErrorBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsOptional<::planus::Offset<super::moor_var::Var>>,
            {
                let (v0, v1) = self.0;
                ErrorBuilder((v0, v1, value))
            }

            /// Sets the [`value` field](Error#structfield.value) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value_as_null(self) -> ErrorBuilder<(T0, T1, ())> {
                self.value(())
            }
        }

        impl<T0, T1, T2> ErrorBuilder<(T0, T1, T2)> {
            /// Setter for the [`custom_symbol` field](Error#structfield.custom_symbol).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn custom_symbol<T3>(self, value: T3) -> ErrorBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            {
                let (v0, v1, v2) = self.0;
                ErrorBuilder((v0, v1, v2, value))
            }

            /// Sets the [`custom_symbol` field](Error#structfield.custom_symbol) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn custom_symbol_as_null(self) -> ErrorBuilder<(T0, T1, T2, ())> {
                self.custom_symbol(())
            }
        }

        impl<T0, T1, T2, T3> ErrorBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Error].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Error>
            where
                Self: ::planus::WriteAsOffset<Error>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::ErrorCode, self::ErrorCode>,
            T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<super::moor_var::Var>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<Error>> for ErrorBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<Error>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Error> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::ErrorCode, self::ErrorCode>,
            T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<super::moor_var::Var>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<Error>> for ErrorBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<Error>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Error>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::ErrorCode, self::ErrorCode>,
            T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<super::moor_var::Var>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<Error> for ErrorBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Error> {
                let (v0, v1, v2, v3) = &self.0;
                Error::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [Error].
        #[derive(Copy, Clone)]
        pub struct ErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ErrorRef<'a> {
            /// Getter for the [`err_type` field](Error#structfield.err_type).
            #[inline]
            pub fn err_type(&self) -> ::planus::Result<self::ErrorCode> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "Error", "err_type")?
                        .unwrap_or(self::ErrorCode::ENone),
                )
            }

            /// Getter for the [`msg` field](Error#structfield.msg).
            #[inline]
            pub fn msg(
                &self,
            ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>> {
                self.0.access(1, "Error", "msg")
            }

            /// Getter for the [`value` field](Error#structfield.value).
            #[inline]
            pub fn value(
                &self,
            ) -> ::planus::Result<::core::option::Option<super::moor_var::VarRef<'a>>> {
                self.0.access(2, "Error", "value")
            }

            /// Getter for the [`custom_symbol` field](Error#structfield.custom_symbol).
            #[inline]
            pub fn custom_symbol(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::SymbolRef<'a>>> {
                self.0.access(3, "Error", "custom_symbol")
            }
        }

        impl<'a> ::core::fmt::Debug for ErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ErrorRef");
                f.field("err_type", &self.err_type());
                if let ::core::option::Option::Some(field_msg) = self.msg().transpose() {
                    f.field("msg", &field_msg);
                }
                if let ::core::option::Option::Some(field_value) = self.value().transpose() {
                    f.field("value", &field_value);
                }
                if let ::core::option::Option::Some(field_custom_symbol) =
                    self.custom_symbol().transpose()
                {
                    f.field("custom_symbol", &field_custom_symbol);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ErrorRef<'a>> for Error {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    err_type: ::core::convert::TryInto::try_into(value.err_type()?)?,
                    msg: value.msg()?.map(::core::convert::Into::into),
                    value: if let ::core::option::Option::Some(value) = value.value()? {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                    custom_symbol: if let ::core::option::Option::Some(custom_symbol) =
                        value.custom_symbol()?
                    {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(custom_symbol)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[ErrorRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Error>> for Error {
            type Value = ::planus::Offset<Error>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Error>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `NarrativeEvent` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `NarrativeEvent` in the file `../../../schema/schema/common.fbs:108`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct NarrativeEvent {
            /// The field `event_id` in the table `NarrativeEvent`
            pub event_id: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `timestamp` in the table `NarrativeEvent`
            pub timestamp: u64,
            /// The field `author` in the table `NarrativeEvent`
            pub author: ::planus::alloc::boxed::Box<super::moor_var::Var>,
            /// The field `event` in the table `NarrativeEvent`
            pub event: ::planus::alloc::boxed::Box<self::Event>,
        }

        impl NarrativeEvent {
            /// Creates a [NarrativeEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> NarrativeEventBuilder<()> {
                NarrativeEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_event_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                field_author: impl ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
                field_event: impl ::planus::WriteAs<::planus::Offset<self::Event>>,
            ) -> ::planus::Offset<Self> {
                let prepared_event_id = field_event_id.prepare(builder);
                let prepared_timestamp = field_timestamp.prepare(builder, &0);
                let prepared_author = field_author.prepare(builder);
                let prepared_event = field_event.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                if prepared_timestamp.is_some() {
                    table_writer.write_entry::<u64>(1);
                }
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(0);
                table_writer.write_entry::<::planus::Offset<super::moor_var::Var>>(2);
                table_writer.write_entry::<::planus::Offset<self::Event>>(3);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            object_writer.write::<_, _, 8>(&prepared_timestamp);
                        }
                        object_writer.write::<_, _, 4>(&prepared_event_id);
                        object_writer.write::<_, _, 4>(&prepared_author);
                        object_writer.write::<_, _, 4>(&prepared_event);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NarrativeEvent>> for NarrativeEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NarrativeEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NarrativeEvent>> for NarrativeEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NarrativeEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NarrativeEvent> for NarrativeEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NarrativeEvent> {
                NarrativeEvent::create(
                    builder,
                    &self.event_id,
                    self.timestamp,
                    &self.author,
                    &self.event,
                )
            }
        }

        /// Builder for serializing an instance of the [NarrativeEvent] type.
        ///
        /// Can be created using the [NarrativeEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct NarrativeEventBuilder<State>(State);

        impl NarrativeEventBuilder<()> {
            /// Setter for the [`event_id` field](NarrativeEvent#structfield.event_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event_id<T0>(self, value: T0) -> NarrativeEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                NarrativeEventBuilder((value,))
            }
        }

        impl<T0> NarrativeEventBuilder<(T0,)> {
            /// Setter for the [`timestamp` field](NarrativeEvent#structfield.timestamp).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp<T1>(self, value: T1) -> NarrativeEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                NarrativeEventBuilder((v0, value))
            }

            /// Sets the [`timestamp` field](NarrativeEvent#structfield.timestamp) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp_as_default(
                self,
            ) -> NarrativeEventBuilder<(T0, ::planus::DefaultValue)> {
                self.timestamp(::planus::DefaultValue)
            }
        }

        impl<T0, T1> NarrativeEventBuilder<(T0, T1)> {
            /// Setter for the [`author` field](NarrativeEvent#structfield.author).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn author<T2>(self, value: T2) -> NarrativeEventBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
            {
                let (v0, v1) = self.0;
                NarrativeEventBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> NarrativeEventBuilder<(T0, T1, T2)> {
            /// Setter for the [`event` field](NarrativeEvent#structfield.event).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event<T3>(self, value: T3) -> NarrativeEventBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<self::Event>>,
            {
                let (v0, v1, v2) = self.0;
                NarrativeEventBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> NarrativeEventBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NarrativeEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<NarrativeEvent>
            where
                Self: ::planus::WriteAsOffset<NarrativeEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Event>>,
        > ::planus::WriteAs<::planus::Offset<NarrativeEvent>>
            for NarrativeEventBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<NarrativeEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NarrativeEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Event>>,
        > ::planus::WriteAsOptional<::planus::Offset<NarrativeEvent>>
            for NarrativeEventBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<NarrativeEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NarrativeEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Event>>,
        > ::planus::WriteAsOffset<NarrativeEvent> for NarrativeEventBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NarrativeEvent> {
                let (v0, v1, v2, v3) = &self.0;
                NarrativeEvent::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [NarrativeEvent].
        #[derive(Copy, Clone)]
        pub struct NarrativeEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> NarrativeEventRef<'a> {
            /// Getter for the [`event_id` field](NarrativeEvent#structfield.event_id).
            #[inline]
            pub fn event_id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(0, "NarrativeEvent", "event_id")
            }

            /// Getter for the [`timestamp` field](NarrativeEvent#structfield.timestamp).
            #[inline]
            pub fn timestamp(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "NarrativeEvent", "timestamp")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`author` field](NarrativeEvent#structfield.author).
            #[inline]
            pub fn author(&self) -> ::planus::Result<super::moor_var::VarRef<'a>> {
                self.0.access_required(2, "NarrativeEvent", "author")
            }

            /// Getter for the [`event` field](NarrativeEvent#structfield.event).
            #[inline]
            pub fn event(&self) -> ::planus::Result<self::EventRef<'a>> {
                self.0.access_required(3, "NarrativeEvent", "event")
            }
        }

        impl<'a> ::core::fmt::Debug for NarrativeEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("NarrativeEventRef");
                f.field("event_id", &self.event_id());
                f.field("timestamp", &self.timestamp());
                f.field("author", &self.author());
                f.field("event", &self.event());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<NarrativeEventRef<'a>> for NarrativeEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: NarrativeEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    event_id: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.event_id()?,
                    )?),
                    timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                    author: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.author()?,
                    )?),
                    event: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.event()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for NarrativeEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for NarrativeEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[NarrativeEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<NarrativeEvent>> for NarrativeEvent {
            type Value = ::planus::Offset<NarrativeEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<NarrativeEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for NarrativeEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[NarrativeEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `EventUnion` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Union `EventUnion` in the file `../../../schema/schema/common.fbs:115`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub enum EventUnion {
            /// The variant of type `NotifyEvent` in the union `EventUnion`
            NotifyEvent(::planus::alloc::boxed::Box<self::NotifyEvent>),

            /// The variant of type `PresentEvent` in the union `EventUnion`
            PresentEvent(::planus::alloc::boxed::Box<self::PresentEvent>),

            /// The variant of type `UnpresentEvent` in the union `EventUnion`
            UnpresentEvent(::planus::alloc::boxed::Box<self::UnpresentEvent>),

            /// The variant of type `TracebackEvent` in the union `EventUnion`
            TracebackEvent(::planus::alloc::boxed::Box<self::TracebackEvent>),
        }

        impl EventUnion {
            /// Creates a [EventUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> EventUnionBuilder<::planus::Uninitialized> {
                EventUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_notify_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::NotifyEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_present_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PresentEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_unpresent_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::UnpresentEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_traceback_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::TracebackEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<EventUnion> for EventUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::NotifyEvent(value) => Self::create_notify_event(builder, value),
                    Self::PresentEvent(value) => Self::create_present_event(builder, value),
                    Self::UnpresentEvent(value) => Self::create_unpresent_event(builder, value),
                    Self::TracebackEvent(value) => Self::create_traceback_event(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<EventUnion> for EventUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [EventUnion] type.
        ///
        /// Can be created using the [EventUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct EventUnionBuilder<T>(T);

        impl EventUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`NotifyEvent` variant](EventUnion#variant.NotifyEvent).
            #[inline]
            pub fn notify_event<T>(self, value: T) -> EventUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::NotifyEvent>,
            {
                EventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PresentEvent` variant](EventUnion#variant.PresentEvent).
            #[inline]
            pub fn present_event<T>(
                self,
                value: T,
            ) -> EventUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::PresentEvent>,
            {
                EventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`UnpresentEvent` variant](EventUnion#variant.UnpresentEvent).
            #[inline]
            pub fn unpresent_event<T>(
                self,
                value: T,
            ) -> EventUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::UnpresentEvent>,
            {
                EventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`TracebackEvent` variant](EventUnion#variant.TracebackEvent).
            #[inline]
            pub fn traceback_event<T>(
                self,
                value: T,
            ) -> EventUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::TracebackEvent>,
            {
                EventUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> EventUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [EventUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<EventUnion>
            where
                Self: ::planus::WriteAsUnion<EventUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<EventUnion> for EventUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::NotifyEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<EventUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<EventUnion>
            for EventUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::NotifyEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<EventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<EventUnion> for EventUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::PresentEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<EventUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<EventUnion>
            for EventUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::PresentEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<EventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<EventUnion> for EventUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::UnpresentEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<EventUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<EventUnion>
            for EventUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::UnpresentEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<EventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<EventUnion> for EventUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::TracebackEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<EventUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<EventUnion>
            for EventUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::TracebackEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<EventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [EventUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum EventUnionRef<'a> {
            NotifyEvent(self::NotifyEventRef<'a>),
            PresentEvent(self::PresentEventRef<'a>),
            UnpresentEvent(self::UnpresentEventRef<'a>),
            TracebackEvent(self::TracebackEventRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<EventUnionRef<'a>> for EventUnion {
            type Error = ::planus::Error;

            fn try_from(value: EventUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    EventUnionRef::NotifyEvent(value) => {
                        Self::NotifyEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    EventUnionRef::PresentEvent(value) => {
                        Self::PresentEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    EventUnionRef::UnpresentEvent(value) => {
                        Self::UnpresentEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    EventUnionRef::TracebackEvent(value) => {
                        Self::TracebackEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for EventUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::NotifyEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::PresentEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::UnpresentEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::TracebackEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for EventUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[EventUnionRef]";
        }

        /// The table `NotifyEvent` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `NotifyEvent` in the file `../../../schema/schema/common.fbs:122`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct NotifyEvent {
            /// The field `value` in the table `NotifyEvent`
            pub value: ::planus::alloc::boxed::Box<super::moor_var::Var>,
            /// The field `content_type` in the table `NotifyEvent`
            pub content_type: ::core::option::Option<::planus::alloc::boxed::Box<self::Symbol>>,
            /// The field `no_flush` in the table `NotifyEvent`
            pub no_flush: bool,
            /// The field `no_newline` in the table `NotifyEvent`
            pub no_newline: bool,
        }

        impl NotifyEvent {
            /// Creates a [NotifyEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> NotifyEventBuilder<()> {
                NotifyEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value: impl ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
                field_content_type: impl ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
                field_no_flush: impl ::planus::WriteAsDefault<bool, bool>,
                field_no_newline: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_value = field_value.prepare(builder);
                let prepared_content_type = field_content_type.prepare(builder);
                let prepared_no_flush = field_no_flush.prepare(builder, &false);
                let prepared_no_newline = field_no_newline.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<super::moor_var::Var>>(0);
                if prepared_content_type.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);
                }
                if prepared_no_flush.is_some() {
                    table_writer.write_entry::<bool>(2);
                }
                if prepared_no_newline.is_some() {
                    table_writer.write_entry::<bool>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_value);
                        if let ::core::option::Option::Some(prepared_content_type) =
                            prepared_content_type
                        {
                            object_writer.write::<_, _, 4>(&prepared_content_type);
                        }
                        if let ::core::option::Option::Some(prepared_no_flush) = prepared_no_flush {
                            object_writer.write::<_, _, 1>(&prepared_no_flush);
                        }
                        if let ::core::option::Option::Some(prepared_no_newline) =
                            prepared_no_newline
                        {
                            object_writer.write::<_, _, 1>(&prepared_no_newline);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NotifyEvent>> for NotifyEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NotifyEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NotifyEvent>> for NotifyEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NotifyEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NotifyEvent> for NotifyEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NotifyEvent> {
                NotifyEvent::create(
                    builder,
                    &self.value,
                    &self.content_type,
                    self.no_flush,
                    self.no_newline,
                )
            }
        }

        /// Builder for serializing an instance of the [NotifyEvent] type.
        ///
        /// Can be created using the [NotifyEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct NotifyEventBuilder<State>(State);

        impl NotifyEventBuilder<()> {
            /// Setter for the [`value` field](NotifyEvent#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T0>(self, value: T0) -> NotifyEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
            {
                NotifyEventBuilder((value,))
            }
        }

        impl<T0> NotifyEventBuilder<(T0,)> {
            /// Setter for the [`content_type` field](NotifyEvent#structfield.content_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn content_type<T1>(self, value: T1) -> NotifyEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                NotifyEventBuilder((v0, value))
            }

            /// Sets the [`content_type` field](NotifyEvent#structfield.content_type) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn content_type_as_null(self) -> NotifyEventBuilder<(T0, ())> {
                self.content_type(())
            }
        }

        impl<T0, T1> NotifyEventBuilder<(T0, T1)> {
            /// Setter for the [`no_flush` field](NotifyEvent#structfield.no_flush).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn no_flush<T2>(self, value: T2) -> NotifyEventBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1) = self.0;
                NotifyEventBuilder((v0, v1, value))
            }

            /// Sets the [`no_flush` field](NotifyEvent#structfield.no_flush) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn no_flush_as_default(
                self,
            ) -> NotifyEventBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.no_flush(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> NotifyEventBuilder<(T0, T1, T2)> {
            /// Setter for the [`no_newline` field](NotifyEvent#structfield.no_newline).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn no_newline<T3>(self, value: T3) -> NotifyEventBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2) = self.0;
                NotifyEventBuilder((v0, v1, v2, value))
            }

            /// Sets the [`no_newline` field](NotifyEvent#structfield.no_newline) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn no_newline_as_default(
                self,
            ) -> NotifyEventBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.no_newline(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> NotifyEventBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NotifyEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<NotifyEvent>
            where
                Self: ::planus::WriteAsOffset<NotifyEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            T2: ::planus::WriteAsDefault<bool, bool>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAs<::planus::Offset<NotifyEvent>>
            for NotifyEventBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<NotifyEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NotifyEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            T2: ::planus::WriteAsDefault<bool, bool>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOptional<::planus::Offset<NotifyEvent>>
            for NotifyEventBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<NotifyEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NotifyEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_var::Var>>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            T2: ::planus::WriteAsDefault<bool, bool>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOffset<NotifyEvent> for NotifyEventBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NotifyEvent> {
                let (v0, v1, v2, v3) = &self.0;
                NotifyEvent::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [NotifyEvent].
        #[derive(Copy, Clone)]
        pub struct NotifyEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> NotifyEventRef<'a> {
            /// Getter for the [`value` field](NotifyEvent#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<super::moor_var::VarRef<'a>> {
                self.0.access_required(0, "NotifyEvent", "value")
            }

            /// Getter for the [`content_type` field](NotifyEvent#structfield.content_type).
            #[inline]
            pub fn content_type(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::SymbolRef<'a>>> {
                self.0.access(1, "NotifyEvent", "content_type")
            }

            /// Getter for the [`no_flush` field](NotifyEvent#structfield.no_flush).
            #[inline]
            pub fn no_flush(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "NotifyEvent", "no_flush")?
                        .unwrap_or(false),
                )
            }

            /// Getter for the [`no_newline` field](NotifyEvent#structfield.no_newline).
            #[inline]
            pub fn no_newline(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "NotifyEvent", "no_newline")?
                        .unwrap_or(false),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for NotifyEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("NotifyEventRef");
                f.field("value", &self.value());
                if let ::core::option::Option::Some(field_content_type) =
                    self.content_type().transpose()
                {
                    f.field("content_type", &field_content_type);
                }
                f.field("no_flush", &self.no_flush());
                f.field("no_newline", &self.no_newline());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<NotifyEventRef<'a>> for NotifyEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: NotifyEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.value()?,
                    )?),
                    content_type: if let ::core::option::Option::Some(content_type) =
                        value.content_type()?
                    {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(content_type)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                    no_flush: ::core::convert::TryInto::try_into(value.no_flush()?)?,
                    no_newline: ::core::convert::TryInto::try_into(value.no_newline()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for NotifyEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for NotifyEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[NotifyEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<NotifyEvent>> for NotifyEvent {
            type Value = ::planus::Offset<NotifyEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<NotifyEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for NotifyEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[NotifyEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PresentEvent` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `PresentEvent` in the file `../../../schema/schema/common.fbs:129`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PresentEvent {
            /// The field `presentation` in the table `PresentEvent`
            pub presentation: ::planus::alloc::boxed::Box<self::Presentation>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PresentEvent {
            fn default() -> Self {
                Self {
                    presentation: ::core::default::Default::default(),
                }
            }
        }

        impl PresentEvent {
            /// Creates a [PresentEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PresentEventBuilder<()> {
                PresentEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_presentation: impl ::planus::WriteAs<::planus::Offset<self::Presentation>>,
            ) -> ::planus::Offset<Self> {
                let prepared_presentation = field_presentation.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Presentation>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_presentation);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PresentEvent>> for PresentEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PresentEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PresentEvent>> for PresentEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PresentEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PresentEvent> for PresentEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PresentEvent> {
                PresentEvent::create(builder, &self.presentation)
            }
        }

        /// Builder for serializing an instance of the [PresentEvent] type.
        ///
        /// Can be created using the [PresentEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PresentEventBuilder<State>(State);

        impl PresentEventBuilder<()> {
            /// Setter for the [`presentation` field](PresentEvent#structfield.presentation).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn presentation<T0>(self, value: T0) -> PresentEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Presentation>>,
            {
                PresentEventBuilder((value,))
            }
        }

        impl<T0> PresentEventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PresentEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PresentEvent>
            where
                Self: ::planus::WriteAsOffset<PresentEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Presentation>>>
            ::planus::WriteAs<::planus::Offset<PresentEvent>> for PresentEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PresentEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PresentEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Presentation>>>
            ::planus::WriteAsOptional<::planus::Offset<PresentEvent>>
            for PresentEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PresentEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PresentEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Presentation>>>
            ::planus::WriteAsOffset<PresentEvent> for PresentEventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PresentEvent> {
                let (v0,) = &self.0;
                PresentEvent::create(builder, v0)
            }
        }

        /// Reference to a deserialized [PresentEvent].
        #[derive(Copy, Clone)]
        pub struct PresentEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PresentEventRef<'a> {
            /// Getter for the [`presentation` field](PresentEvent#structfield.presentation).
            #[inline]
            pub fn presentation(&self) -> ::planus::Result<self::PresentationRef<'a>> {
                self.0.access_required(0, "PresentEvent", "presentation")
            }
        }

        impl<'a> ::core::fmt::Debug for PresentEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PresentEventRef");
                f.field("presentation", &self.presentation());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PresentEventRef<'a>> for PresentEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PresentEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    presentation: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.presentation()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PresentEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PresentEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PresentEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PresentEvent>> for PresentEvent {
            type Value = ::planus::Offset<PresentEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PresentEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PresentEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PresentEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `UnpresentEvent` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `UnpresentEvent` in the file `../../../schema/schema/common.fbs:133`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct UnpresentEvent {
            /// The field `presentation_id` in the table `UnpresentEvent`
            pub presentation_id: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for UnpresentEvent {
            fn default() -> Self {
                Self {
                    presentation_id: ::core::default::Default::default(),
                }
            }
        }

        impl UnpresentEvent {
            /// Creates a [UnpresentEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UnpresentEventBuilder<()> {
                UnpresentEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_presentation_id: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_presentation_id = field_presentation_id.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_presentation_id);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<UnpresentEvent>> for UnpresentEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UnpresentEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<UnpresentEvent>> for UnpresentEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnpresentEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<UnpresentEvent> for UnpresentEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UnpresentEvent> {
                UnpresentEvent::create(builder, &self.presentation_id)
            }
        }

        /// Builder for serializing an instance of the [UnpresentEvent] type.
        ///
        /// Can be created using the [UnpresentEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UnpresentEventBuilder<State>(State);

        impl UnpresentEventBuilder<()> {
            /// Setter for the [`presentation_id` field](UnpresentEvent#structfield.presentation_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn presentation_id<T0>(self, value: T0) -> UnpresentEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                UnpresentEventBuilder((value,))
            }
        }

        impl<T0> UnpresentEventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UnpresentEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<UnpresentEvent>
            where
                Self: ::planus::WriteAsOffset<UnpresentEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<UnpresentEvent>> for UnpresentEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<UnpresentEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UnpresentEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<UnpresentEvent>>
            for UnpresentEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<UnpresentEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnpresentEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<UnpresentEvent>
            for UnpresentEventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UnpresentEvent> {
                let (v0,) = &self.0;
                UnpresentEvent::create(builder, v0)
            }
        }

        /// Reference to a deserialized [UnpresentEvent].
        #[derive(Copy, Clone)]
        pub struct UnpresentEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UnpresentEventRef<'a> {
            /// Getter for the [`presentation_id` field](UnpresentEvent#structfield.presentation_id).
            #[inline]
            pub fn presentation_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(0, "UnpresentEvent", "presentation_id")
            }
        }

        impl<'a> ::core::fmt::Debug for UnpresentEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UnpresentEventRef");
                f.field("presentation_id", &self.presentation_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UnpresentEventRef<'a>> for UnpresentEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UnpresentEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    presentation_id: ::core::convert::Into::into(value.presentation_id()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UnpresentEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UnpresentEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[UnpresentEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<UnpresentEvent>> for UnpresentEvent {
            type Value = ::planus::Offset<UnpresentEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<UnpresentEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UnpresentEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UnpresentEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `TracebackEvent` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `TracebackEvent` in the file `../../../schema/schema/common.fbs:137`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct TracebackEvent {
            /// The field `exception` in the table `TracebackEvent`
            pub exception: ::planus::alloc::boxed::Box<self::Exception>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for TracebackEvent {
            fn default() -> Self {
                Self {
                    exception: ::core::default::Default::default(),
                }
            }
        }

        impl TracebackEvent {
            /// Creates a [TracebackEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> TracebackEventBuilder<()> {
                TracebackEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_exception: impl ::planus::WriteAs<::planus::Offset<self::Exception>>,
            ) -> ::planus::Offset<Self> {
                let prepared_exception = field_exception.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Exception>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_exception);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TracebackEvent>> for TracebackEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TracebackEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TracebackEvent>> for TracebackEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TracebackEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TracebackEvent> for TracebackEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TracebackEvent> {
                TracebackEvent::create(builder, &self.exception)
            }
        }

        /// Builder for serializing an instance of the [TracebackEvent] type.
        ///
        /// Can be created using the [TracebackEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct TracebackEventBuilder<State>(State);

        impl TracebackEventBuilder<()> {
            /// Setter for the [`exception` field](TracebackEvent#structfield.exception).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn exception<T0>(self, value: T0) -> TracebackEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Exception>>,
            {
                TracebackEventBuilder((value,))
            }
        }

        impl<T0> TracebackEventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TracebackEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<TracebackEvent>
            where
                Self: ::planus::WriteAsOffset<TracebackEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Exception>>>
            ::planus::WriteAs<::planus::Offset<TracebackEvent>> for TracebackEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TracebackEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TracebackEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Exception>>>
            ::planus::WriteAsOptional<::planus::Offset<TracebackEvent>>
            for TracebackEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TracebackEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TracebackEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Exception>>>
            ::planus::WriteAsOffset<TracebackEvent> for TracebackEventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TracebackEvent> {
                let (v0,) = &self.0;
                TracebackEvent::create(builder, v0)
            }
        }

        /// Reference to a deserialized [TracebackEvent].
        #[derive(Copy, Clone)]
        pub struct TracebackEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> TracebackEventRef<'a> {
            /// Getter for the [`exception` field](TracebackEvent#structfield.exception).
            #[inline]
            pub fn exception(&self) -> ::planus::Result<self::ExceptionRef<'a>> {
                self.0.access_required(0, "TracebackEvent", "exception")
            }
        }

        impl<'a> ::core::fmt::Debug for TracebackEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("TracebackEventRef");
                f.field("exception", &self.exception());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<TracebackEventRef<'a>> for TracebackEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: TracebackEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    exception: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.exception()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for TracebackEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for TracebackEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[TracebackEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<TracebackEvent>> for TracebackEvent {
            type Value = ::planus::Offset<TracebackEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<TracebackEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for TracebackEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[TracebackEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Event` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `Event` in the file `../../../schema/schema/common.fbs:141`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct Event {
            /// The field `event` in the table `Event`
            pub event: self::EventUnion,
        }

        impl Event {
            /// Creates a [EventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> EventBuilder<()> {
                EventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_event: impl ::planus::WriteAsUnion<self::EventUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_event = field_event.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::EventUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_event.offset());
                        object_writer.write::<_, _, 1>(&prepared_event.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Event>> for Event {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Event> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Event>> for Event {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Event>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Event> for Event {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Event> {
                Event::create(builder, &self.event)
            }
        }

        /// Builder for serializing an instance of the [Event] type.
        ///
        /// Can be created using the [Event::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct EventBuilder<State>(State);

        impl EventBuilder<()> {
            /// Setter for the [`event` field](Event#structfield.event).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event<T0>(self, value: T0) -> EventBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::EventUnion>,
            {
                EventBuilder((value,))
            }
        }

        impl<T0> EventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Event].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Event>
            where
                Self: ::planus::WriteAsOffset<Event>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::EventUnion>>
            ::planus::WriteAs<::planus::Offset<Event>> for EventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Event>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Event> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::EventUnion>>
            ::planus::WriteAsOptional<::planus::Offset<Event>> for EventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Event>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Event>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::EventUnion>> ::planus::WriteAsOffset<Event>
            for EventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Event> {
                let (v0,) = &self.0;
                Event::create(builder, v0)
            }
        }

        /// Reference to a deserialized [Event].
        #[derive(Copy, Clone)]
        pub struct EventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> EventRef<'a> {
            /// Getter for the [`event` field](Event#structfield.event).
            #[inline]
            pub fn event(&self) -> ::planus::Result<self::EventUnionRef<'a>> {
                self.0.access_union_required(0, "Event", "event")
            }
        }

        impl<'a> ::core::fmt::Debug for EventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("EventRef");
                f.field("event", &self.event());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<EventRef<'a>> for Event {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: EventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    event: ::core::convert::TryInto::try_into(value.event()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for EventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for EventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[EventRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Event>> for Event {
            type Value = ::planus::Offset<Event>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Event>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for EventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[EventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Presentation` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `Presentation` in the file `../../../schema/schema/common.fbs:145`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Presentation {
            /// The field `id` in the table `Presentation`
            pub id: ::planus::alloc::string::String,
            /// The field `content_type` in the table `Presentation`
            pub content_type: ::planus::alloc::string::String,
            /// The field `content` in the table `Presentation`
            pub content: ::planus::alloc::string::String,
            /// The field `target` in the table `Presentation`
            pub target: ::planus::alloc::string::String,
            /// The field `attributes` in the table `Presentation`
            pub attributes: ::planus::alloc::vec::Vec<self::PresentationAttribute>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Presentation {
            fn default() -> Self {
                Self {
                    id: ::core::default::Default::default(),
                    content_type: ::core::default::Default::default(),
                    content: ::core::default::Default::default(),
                    target: ::core::default::Default::default(),
                    attributes: ::core::default::Default::default(),
                }
            }
        }

        impl Presentation {
            /// Creates a [PresentationBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PresentationBuilder<()> {
                PresentationBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_content_type: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_content: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_target: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_attributes: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_id = field_id.prepare(builder);
                let prepared_content_type = field_content_type.prepare(builder);
                let prepared_content = field_content.prepare(builder);
                let prepared_target = field_target.prepare(builder);
                let prepared_attributes = field_attributes.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<14> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);
                table_writer.write_entry::<::planus::Offset<str>>(2);
                table_writer.write_entry::<::planus::Offset<str>>(3);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>>(4);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_id);
                        object_writer.write::<_, _, 4>(&prepared_content_type);
                        object_writer.write::<_, _, 4>(&prepared_content);
                        object_writer.write::<_, _, 4>(&prepared_target);
                        object_writer.write::<_, _, 4>(&prepared_attributes);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Presentation>> for Presentation {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Presentation> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Presentation>> for Presentation {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Presentation>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Presentation> for Presentation {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Presentation> {
                Presentation::create(
                    builder,
                    &self.id,
                    &self.content_type,
                    &self.content,
                    &self.target,
                    &self.attributes,
                )
            }
        }

        /// Builder for serializing an instance of the [Presentation] type.
        ///
        /// Can be created using the [Presentation::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PresentationBuilder<State>(State);

        impl PresentationBuilder<()> {
            /// Setter for the [`id` field](Presentation#structfield.id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id<T0>(self, value: T0) -> PresentationBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                PresentationBuilder((value,))
            }
        }

        impl<T0> PresentationBuilder<(T0,)> {
            /// Setter for the [`content_type` field](Presentation#structfield.content_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn content_type<T1>(self, value: T1) -> PresentationBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                PresentationBuilder((v0, value))
            }
        }

        impl<T0, T1> PresentationBuilder<(T0, T1)> {
            /// Setter for the [`content` field](Presentation#structfield.content).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn content<T2>(self, value: T2) -> PresentationBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1) = self.0;
                PresentationBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> PresentationBuilder<(T0, T1, T2)> {
            /// Setter for the [`target` field](Presentation#structfield.target).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn target<T3>(self, value: T3) -> PresentationBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1, v2) = self.0;
                PresentationBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> PresentationBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`attributes` field](Presentation#structfield.attributes).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn attributes<T4>(self, value: T4) -> PresentationBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>,
                    >,
            {
                let (v0, v1, v2, v3) = self.0;
                PresentationBuilder((v0, v1, v2, v3, value))
            }
        }

        impl<T0, T1, T2, T3, T4> PresentationBuilder<(T0, T1, T2, T3, T4)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Presentation].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Presentation>
            where
                Self: ::planus::WriteAsOffset<Presentation>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>>,
        > ::planus::WriteAs<::planus::Offset<Presentation>>
            for PresentationBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<Presentation>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Presentation> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<Presentation>>
            for PresentationBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<Presentation>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Presentation>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>>,
        > ::planus::WriteAsOffset<Presentation> for PresentationBuilder<(T0, T1, T2, T3, T4)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Presentation> {
                let (v0, v1, v2, v3, v4) = &self.0;
                Presentation::create(builder, v0, v1, v2, v3, v4)
            }
        }

        /// Reference to a deserialized [Presentation].
        #[derive(Copy, Clone)]
        pub struct PresentationRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PresentationRef<'a> {
            /// Getter for the [`id` field](Presentation#structfield.id).
            #[inline]
            pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "Presentation", "id")
            }

            /// Getter for the [`content_type` field](Presentation#structfield.content_type).
            #[inline]
            pub fn content_type(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "Presentation", "content_type")
            }

            /// Getter for the [`content` field](Presentation#structfield.content).
            #[inline]
            pub fn content(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(2, "Presentation", "content")
            }

            /// Getter for the [`target` field](Presentation#structfield.target).
            #[inline]
            pub fn target(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(3, "Presentation", "target")
            }

            /// Getter for the [`attributes` field](Presentation#structfield.attributes).
            #[inline]
            pub fn attributes(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::PresentationAttributeRef<'a>>>,
            > {
                self.0.access_required(4, "Presentation", "attributes")
            }
        }

        impl<'a> ::core::fmt::Debug for PresentationRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PresentationRef");
                f.field("id", &self.id());
                f.field("content_type", &self.content_type());
                f.field("content", &self.content());
                f.field("target", &self.target());
                f.field("attributes", &self.attributes());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PresentationRef<'a>> for Presentation {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PresentationRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    id: ::core::convert::Into::into(value.id()?),
                    content_type: ::core::convert::Into::into(value.content_type()?),
                    content: ::core::convert::Into::into(value.content()?),
                    target: ::core::convert::Into::into(value.target()?),
                    attributes: value.attributes()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PresentationRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PresentationRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PresentationRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Presentation>> for Presentation {
            type Value = ::planus::Offset<Presentation>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Presentation>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PresentationRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PresentationRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PresentationAttribute` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `PresentationAttribute` in the file `../../../schema/schema/common.fbs:153`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PresentationAttribute {
            /// The field `key` in the table `PresentationAttribute`
            pub key: ::planus::alloc::string::String,
            /// The field `value` in the table `PresentationAttribute`
            pub value: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PresentationAttribute {
            fn default() -> Self {
                Self {
                    key: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }

        impl PresentationAttribute {
            /// Creates a [PresentationAttributeBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PresentationAttributeBuilder<()> {
                PresentationAttributeBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_key: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_key = field_key.prepare(builder);
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_key);
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PresentationAttribute>> for PresentationAttribute {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationAttribute> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PresentationAttribute>> for PresentationAttribute {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PresentationAttribute>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PresentationAttribute> for PresentationAttribute {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationAttribute> {
                PresentationAttribute::create(builder, &self.key, &self.value)
            }
        }

        /// Builder for serializing an instance of the [PresentationAttribute] type.
        ///
        /// Can be created using the [PresentationAttribute::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PresentationAttributeBuilder<State>(State);

        impl PresentationAttributeBuilder<()> {
            /// Setter for the [`key` field](PresentationAttribute#structfield.key).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn key<T0>(self, value: T0) -> PresentationAttributeBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                PresentationAttributeBuilder((value,))
            }
        }

        impl<T0> PresentationAttributeBuilder<(T0,)> {
            /// Setter for the [`value` field](PresentationAttribute#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T1>(self, value: T1) -> PresentationAttributeBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                PresentationAttributeBuilder((v0, value))
            }
        }

        impl<T0, T1> PresentationAttributeBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PresentationAttribute].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationAttribute>
            where
                Self: ::planus::WriteAsOffset<PresentationAttribute>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<PresentationAttribute>>
            for PresentationAttributeBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PresentationAttribute>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationAttribute> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<PresentationAttribute>>
            for PresentationAttributeBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PresentationAttribute>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PresentationAttribute>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<PresentationAttribute>
            for PresentationAttributeBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationAttribute> {
                let (v0, v1) = &self.0;
                PresentationAttribute::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [PresentationAttribute].
        #[derive(Copy, Clone)]
        pub struct PresentationAttributeRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PresentationAttributeRef<'a> {
            /// Getter for the [`key` field](PresentationAttribute#structfield.key).
            #[inline]
            pub fn key(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "PresentationAttribute", "key")
            }

            /// Getter for the [`value` field](PresentationAttribute#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "PresentationAttribute", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for PresentationAttributeRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PresentationAttributeRef");
                f.field("key", &self.key());
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PresentationAttributeRef<'a>> for PresentationAttribute {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PresentationAttributeRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    key: ::core::convert::Into::into(value.key()?),
                    value: ::core::convert::Into::into(value.value()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PresentationAttributeRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PresentationAttributeRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PresentationAttributeRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PresentationAttribute>>
            for PresentationAttribute
        {
            type Value = ::planus::Offset<PresentationAttribute>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PresentationAttribute>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PresentationAttributeRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PresentationAttributeRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Exception` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `Exception` in the file `../../../schema/schema/common.fbs:158`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct Exception {
            /// The field `error` in the table `Exception`
            pub error: ::planus::alloc::boxed::Box<self::Error>,
            /// The field `stack` in the table `Exception`
            pub stack: ::planus::alloc::vec::Vec<super::moor_var::Var>,
            /// The field `backtrace` in the table `Exception`
            pub backtrace: ::planus::alloc::vec::Vec<super::moor_var::Var>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Exception {
            fn default() -> Self {
                Self {
                    error: ::core::default::Default::default(),
                    stack: ::core::default::Default::default(),
                    backtrace: ::core::default::Default::default(),
                }
            }
        }

        impl Exception {
            /// Creates a [ExceptionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ExceptionBuilder<()> {
                ExceptionBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::Error>>,
                field_stack: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<super::moor_var::Var>]>,
                >,
                field_backtrace: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<super::moor_var::Var>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);
                let prepared_stack = field_stack.prepare(builder);
                let prepared_backtrace = field_backtrace.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Error>>(0);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>(1);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                        object_writer.write::<_, _, 4>(&prepared_stack);
                        object_writer.write::<_, _, 4>(&prepared_backtrace);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Exception>> for Exception {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Exception> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Exception>> for Exception {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Exception>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Exception> for Exception {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Exception> {
                Exception::create(builder, &self.error, &self.stack, &self.backtrace)
            }
        }

        /// Builder for serializing an instance of the [Exception] type.
        ///
        /// Can be created using the [Exception::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ExceptionBuilder<State>(State);

        impl ExceptionBuilder<()> {
            /// Setter for the [`error` field](Exception#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> ExceptionBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Error>>,
            {
                ExceptionBuilder((value,))
            }
        }

        impl<T0> ExceptionBuilder<(T0,)> {
            /// Setter for the [`stack` field](Exception#structfield.stack).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn stack<T1>(self, value: T1) -> ExceptionBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
            {
                let (v0,) = self.0;
                ExceptionBuilder((v0, value))
            }
        }

        impl<T0, T1> ExceptionBuilder<(T0, T1)> {
            /// Setter for the [`backtrace` field](Exception#structfield.backtrace).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn backtrace<T2>(self, value: T2) -> ExceptionBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
            {
                let (v0, v1) = self.0;
                ExceptionBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> ExceptionBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Exception].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Exception>
            where
                Self: ::planus::WriteAsOffset<Exception>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Error>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
        > ::planus::WriteAs<::planus::Offset<Exception>> for ExceptionBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<Exception>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Exception> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Error>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<Exception>>
            for ExceptionBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<Exception>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Exception>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Error>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
        > ::planus::WriteAsOffset<Exception> for ExceptionBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Exception> {
                let (v0, v1, v2) = &self.0;
                Exception::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [Exception].
        #[derive(Copy, Clone)]
        pub struct ExceptionRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ExceptionRef<'a> {
            /// Getter for the [`error` field](Exception#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::ErrorRef<'a>> {
                self.0.access_required(0, "Exception", "error")
            }

            /// Getter for the [`stack` field](Exception#structfield.stack).
            #[inline]
            pub fn stack(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<super::moor_var::VarRef<'a>>>>
            {
                self.0.access_required(1, "Exception", "stack")
            }

            /// Getter for the [`backtrace` field](Exception#structfield.backtrace).
            #[inline]
            pub fn backtrace(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<super::moor_var::VarRef<'a>>>>
            {
                self.0.access_required(2, "Exception", "backtrace")
            }
        }

        impl<'a> ::core::fmt::Debug for ExceptionRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ExceptionRef");
                f.field("error", &self.error());
                f.field("stack", &self.stack());
                f.field("backtrace", &self.backtrace());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ExceptionRef<'a>> for Exception {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ExceptionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                    stack: value.stack()?.to_vec_result()?,
                    backtrace: value.backtrace()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ExceptionRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ExceptionRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ExceptionRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Exception>> for Exception {
            type Value = ::planus::Offset<Exception>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Exception>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ExceptionRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ExceptionRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `CompileContext` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `CompileContext` in the file `../../../schema/schema/common.fbs:168`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CompileContext {
            /// The field `line` in the table `CompileContext`
            pub line: u64,
            /// The field `col` in the table `CompileContext`
            pub col: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for CompileContext {
            fn default() -> Self {
                Self { line: 0, col: 0 }
            }
        }

        impl CompileContext {
            /// Creates a [CompileContextBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CompileContextBuilder<()> {
                CompileContextBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_line: impl ::planus::WriteAsDefault<u64, u64>,
                field_col: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_line = field_line.prepare(builder, &0);
                let prepared_col = field_col.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_line.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                if prepared_col.is_some() {
                    table_writer.write_entry::<u64>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_line) = prepared_line {
                            object_writer.write::<_, _, 8>(&prepared_line);
                        }
                        if let ::core::option::Option::Some(prepared_col) = prepared_col {
                            object_writer.write::<_, _, 8>(&prepared_col);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CompileContext>> for CompileContext {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileContext> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CompileContext>> for CompileContext {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CompileContext>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CompileContext> for CompileContext {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileContext> {
                CompileContext::create(builder, self.line, self.col)
            }
        }

        /// Builder for serializing an instance of the [CompileContext] type.
        ///
        /// Can be created using the [CompileContext::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CompileContextBuilder<State>(State);

        impl CompileContextBuilder<()> {
            /// Setter for the [`line` field](CompileContext#structfield.line).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn line<T0>(self, value: T0) -> CompileContextBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                CompileContextBuilder((value,))
            }

            /// Sets the [`line` field](CompileContext#structfield.line) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn line_as_default(self) -> CompileContextBuilder<(::planus::DefaultValue,)> {
                self.line(::planus::DefaultValue)
            }
        }

        impl<T0> CompileContextBuilder<(T0,)> {
            /// Setter for the [`col` field](CompileContext#structfield.col).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn col<T1>(self, value: T1) -> CompileContextBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                CompileContextBuilder((v0, value))
            }

            /// Sets the [`col` field](CompileContext#structfield.col) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn col_as_default(self) -> CompileContextBuilder<(T0, ::planus::DefaultValue)> {
                self.col(::planus::DefaultValue)
            }
        }

        impl<T0, T1> CompileContextBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CompileContext].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileContext>
            where
                Self: ::planus::WriteAsOffset<CompileContext>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAs<::planus::Offset<CompileContext>>
            for CompileContextBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<CompileContext>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileContext> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<CompileContext>>
            for CompileContextBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<CompileContext>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CompileContext>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOffset<CompileContext> for CompileContextBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileContext> {
                let (v0, v1) = &self.0;
                CompileContext::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [CompileContext].
        #[derive(Copy, Clone)]
        pub struct CompileContextRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CompileContextRef<'a> {
            /// Getter for the [`line` field](CompileContext#structfield.line).
            #[inline]
            pub fn line(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(0, "CompileContext", "line")?.unwrap_or(0))
            }

            /// Getter for the [`col` field](CompileContext#structfield.col).
            #[inline]
            pub fn col(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(1, "CompileContext", "col")?.unwrap_or(0))
            }
        }

        impl<'a> ::core::fmt::Debug for CompileContextRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CompileContextRef");
                f.field("line", &self.line());
                f.field("col", &self.col());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CompileContextRef<'a>> for CompileContext {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CompileContextRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    line: ::core::convert::TryInto::try_into(value.line()?)?,
                    col: ::core::convert::TryInto::try_into(value.col()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CompileContextRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CompileContextRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CompileContextRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CompileContext>> for CompileContext {
            type Value = ::planus::Offset<CompileContext>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CompileContext>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CompileContextRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CompileContextRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StringLexError` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `StringLexError` in the file `../../../schema/schema/common.fbs:173`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StringLexError {
            /// The field `context` in the table `StringLexError`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `message` in the table `StringLexError`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StringLexError {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl StringLexError {
            /// Creates a [StringLexErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StringLexErrorBuilder<()> {
                StringLexErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StringLexError>> for StringLexError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StringLexError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StringLexError>> for StringLexError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StringLexError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StringLexError> for StringLexError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StringLexError> {
                StringLexError::create(builder, &self.context, &self.message)
            }
        }

        /// Builder for serializing an instance of the [StringLexError] type.
        ///
        /// Can be created using the [StringLexError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StringLexErrorBuilder<State>(State);

        impl StringLexErrorBuilder<()> {
            /// Setter for the [`context` field](StringLexError#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> StringLexErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                StringLexErrorBuilder((value,))
            }
        }

        impl<T0> StringLexErrorBuilder<(T0,)> {
            /// Setter for the [`message` field](StringLexError#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T1>(self, value: T1) -> StringLexErrorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                StringLexErrorBuilder((v0, value))
            }
        }

        impl<T0, T1> StringLexErrorBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StringLexError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<StringLexError>
            where
                Self: ::planus::WriteAsOffset<StringLexError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<StringLexError>> for StringLexErrorBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<StringLexError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StringLexError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<StringLexError>>
            for StringLexErrorBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<StringLexError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StringLexError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<StringLexError> for StringLexErrorBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StringLexError> {
                let (v0, v1) = &self.0;
                StringLexError::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [StringLexError].
        #[derive(Copy, Clone)]
        pub struct StringLexErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StringLexErrorRef<'a> {
            /// Getter for the [`context` field](StringLexError#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "StringLexError", "context")
            }

            /// Getter for the [`message` field](StringLexError#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "StringLexError", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for StringLexErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StringLexErrorRef");
                f.field("context", &self.context());
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StringLexErrorRef<'a>> for StringLexError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StringLexErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StringLexErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StringLexErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StringLexErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StringLexError>> for StringLexError {
            type Value = ::planus::Offset<StringLexError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StringLexError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StringLexErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StringLexErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ParseError` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ParseError` in the file `../../../schema/schema/common.fbs:178`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ParseError {
            /// The field `error_position` in the table `ParseError`
            pub error_position: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `context` in the table `ParseError`
            pub context: ::planus::alloc::string::String,
            /// The field `end_line` in the table `ParseError`
            pub end_line: u64,
            /// The field `end_col` in the table `ParseError`
            pub end_col: u64,
            /// The field `has_end` in the table `ParseError`
            pub has_end: bool,
            /// The field `message` in the table `ParseError`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ParseError {
            fn default() -> Self {
                Self {
                    error_position: ::core::default::Default::default(),
                    context: ::core::default::Default::default(),
                    end_line: 0,
                    end_col: 0,
                    has_end: false,
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl ParseError {
            /// Creates a [ParseErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ParseErrorBuilder<()> {
                ParseErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error_position: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_context: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_end_line: impl ::planus::WriteAsDefault<u64, u64>,
                field_end_col: impl ::planus::WriteAsDefault<u64, u64>,
                field_has_end: impl ::planus::WriteAsDefault<bool, bool>,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error_position = field_error_position.prepare(builder);
                let prepared_context = field_context.prepare(builder);
                let prepared_end_line = field_end_line.prepare(builder, &0);
                let prepared_end_col = field_end_col.prepare(builder, &0);
                let prepared_has_end = field_has_end.prepare(builder, &false);
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<16> =
                    ::core::default::Default::default();
                if prepared_end_line.is_some() {
                    table_writer.write_entry::<u64>(2);
                }
                if prepared_end_col.is_some() {
                    table_writer.write_entry::<u64>(3);
                }
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);
                table_writer.write_entry::<::planus::Offset<str>>(5);
                if prepared_has_end.is_some() {
                    table_writer.write_entry::<bool>(4);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_end_line) = prepared_end_line {
                            object_writer.write::<_, _, 8>(&prepared_end_line);
                        }
                        if let ::core::option::Option::Some(prepared_end_col) = prepared_end_col {
                            object_writer.write::<_, _, 8>(&prepared_end_col);
                        }
                        object_writer.write::<_, _, 4>(&prepared_error_position);
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_message);
                        if let ::core::option::Option::Some(prepared_has_end) = prepared_has_end {
                            object_writer.write::<_, _, 1>(&prepared_has_end);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ParseError>> for ParseError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ParseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ParseError>> for ParseError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ParseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ParseError> for ParseError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ParseError> {
                ParseError::create(
                    builder,
                    &self.error_position,
                    &self.context,
                    self.end_line,
                    self.end_col,
                    self.has_end,
                    &self.message,
                )
            }
        }

        /// Builder for serializing an instance of the [ParseError] type.
        ///
        /// Can be created using the [ParseError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ParseErrorBuilder<State>(State);

        impl ParseErrorBuilder<()> {
            /// Setter for the [`error_position` field](ParseError#structfield.error_position).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error_position<T0>(self, value: T0) -> ParseErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                ParseErrorBuilder((value,))
            }
        }

        impl<T0> ParseErrorBuilder<(T0,)> {
            /// Setter for the [`context` field](ParseError#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T1>(self, value: T1) -> ParseErrorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                ParseErrorBuilder((v0, value))
            }
        }

        impl<T0, T1> ParseErrorBuilder<(T0, T1)> {
            /// Setter for the [`end_line` field](ParseError#structfield.end_line).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_line<T2>(self, value: T2) -> ParseErrorBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1) = self.0;
                ParseErrorBuilder((v0, v1, value))
            }

            /// Sets the [`end_line` field](ParseError#structfield.end_line) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_line_as_default(
                self,
            ) -> ParseErrorBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.end_line(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> ParseErrorBuilder<(T0, T1, T2)> {
            /// Setter for the [`end_col` field](ParseError#structfield.end_col).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_col<T3>(self, value: T3) -> ParseErrorBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1, v2) = self.0;
                ParseErrorBuilder((v0, v1, v2, value))
            }

            /// Sets the [`end_col` field](ParseError#structfield.end_col) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_col_as_default(
                self,
            ) -> ParseErrorBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.end_col(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> ParseErrorBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`has_end` field](ParseError#structfield.has_end).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn has_end<T4>(self, value: T4) -> ParseErrorBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3) = self.0;
                ParseErrorBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`has_end` field](ParseError#structfield.has_end) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn has_end_as_default(
                self,
            ) -> ParseErrorBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.has_end(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> ParseErrorBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`message` field](ParseError#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T5>(self, value: T5) -> ParseErrorBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                ParseErrorBuilder((v0, v1, v2, v3, v4, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5> ParseErrorBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ParseError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ParseError>
            where
                Self: ::planus::WriteAsOffset<ParseError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u64, u64>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<ParseError>>
            for ParseErrorBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            type Prepared = ::planus::Offset<ParseError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ParseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u64, u64>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<ParseError>>
            for ParseErrorBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            type Prepared = ::planus::Offset<ParseError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ParseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u64, u64>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<ParseError> for ParseErrorBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ParseError> {
                let (v0, v1, v2, v3, v4, v5) = &self.0;
                ParseError::create(builder, v0, v1, v2, v3, v4, v5)
            }
        }

        /// Reference to a deserialized [ParseError].
        #[derive(Copy, Clone)]
        pub struct ParseErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ParseErrorRef<'a> {
            /// Getter for the [`error_position` field](ParseError#structfield.error_position).
            #[inline]
            pub fn error_position(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "ParseError", "error_position")
            }

            /// Getter for the [`context` field](ParseError#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "ParseError", "context")
            }

            /// Getter for the [`end_line` field](ParseError#structfield.end_line).
            #[inline]
            pub fn end_line(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(2, "ParseError", "end_line")?.unwrap_or(0))
            }

            /// Getter for the [`end_col` field](ParseError#structfield.end_col).
            #[inline]
            pub fn end_col(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(3, "ParseError", "end_col")?.unwrap_or(0))
            }

            /// Getter for the [`has_end` field](ParseError#structfield.has_end).
            #[inline]
            pub fn has_end(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0.access(4, "ParseError", "has_end")?.unwrap_or(false),
                )
            }

            /// Getter for the [`message` field](ParseError#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(5, "ParseError", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for ParseErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ParseErrorRef");
                f.field("error_position", &self.error_position());
                f.field("context", &self.context());
                f.field("end_line", &self.end_line());
                f.field("end_col", &self.end_col());
                f.field("has_end", &self.has_end());
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ParseErrorRef<'a>> for ParseError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ParseErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error_position: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.error_position()?)?,
                    ),
                    context: ::core::convert::Into::into(value.context()?),
                    end_line: ::core::convert::TryInto::try_into(value.end_line()?)?,
                    end_col: ::core::convert::TryInto::try_into(value.end_col()?)?,
                    has_end: ::core::convert::TryInto::try_into(value.has_end()?)?,
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ParseErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ParseErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ParseErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ParseError>> for ParseError {
            type Value = ::planus::Offset<ParseError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ParseError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ParseErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ParseErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `UnknownBuiltinFunction` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `UnknownBuiltinFunction` in the file `../../../schema/schema/common.fbs:187`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct UnknownBuiltinFunction {
            /// The field `context` in the table `UnknownBuiltinFunction`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `name` in the table `UnknownBuiltinFunction`
            pub name: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for UnknownBuiltinFunction {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                }
            }
        }

        impl UnknownBuiltinFunction {
            /// Creates a [UnknownBuiltinFunctionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UnknownBuiltinFunctionBuilder<()> {
                UnknownBuiltinFunctionBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_name: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_name = field_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<UnknownBuiltinFunction>> for UnknownBuiltinFunction {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownBuiltinFunction> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<UnknownBuiltinFunction>>
            for UnknownBuiltinFunction
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownBuiltinFunction>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<UnknownBuiltinFunction> for UnknownBuiltinFunction {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownBuiltinFunction> {
                UnknownBuiltinFunction::create(builder, &self.context, &self.name)
            }
        }

        /// Builder for serializing an instance of the [UnknownBuiltinFunction] type.
        ///
        /// Can be created using the [UnknownBuiltinFunction::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UnknownBuiltinFunctionBuilder<State>(State);

        impl UnknownBuiltinFunctionBuilder<()> {
            /// Setter for the [`context` field](UnknownBuiltinFunction#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> UnknownBuiltinFunctionBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                UnknownBuiltinFunctionBuilder((value,))
            }
        }

        impl<T0> UnknownBuiltinFunctionBuilder<(T0,)> {
            /// Setter for the [`name` field](UnknownBuiltinFunction#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T1>(self, value: T1) -> UnknownBuiltinFunctionBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                UnknownBuiltinFunctionBuilder((v0, value))
            }
        }

        impl<T0, T1> UnknownBuiltinFunctionBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UnknownBuiltinFunction].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownBuiltinFunction>
            where
                Self: ::planus::WriteAsOffset<UnknownBuiltinFunction>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<UnknownBuiltinFunction>>
            for UnknownBuiltinFunctionBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownBuiltinFunction>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownBuiltinFunction> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<UnknownBuiltinFunction>>
            for UnknownBuiltinFunctionBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownBuiltinFunction>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownBuiltinFunction>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<UnknownBuiltinFunction>
            for UnknownBuiltinFunctionBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownBuiltinFunction> {
                let (v0, v1) = &self.0;
                UnknownBuiltinFunction::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [UnknownBuiltinFunction].
        #[derive(Copy, Clone)]
        pub struct UnknownBuiltinFunctionRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UnknownBuiltinFunctionRef<'a> {
            /// Getter for the [`context` field](UnknownBuiltinFunction#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0
                    .access_required(0, "UnknownBuiltinFunction", "context")
            }

            /// Getter for the [`name` field](UnknownBuiltinFunction#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "UnknownBuiltinFunction", "name")
            }
        }

        impl<'a> ::core::fmt::Debug for UnknownBuiltinFunctionRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UnknownBuiltinFunctionRef");
                f.field("context", &self.context());
                f.field("name", &self.name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UnknownBuiltinFunctionRef<'a>> for UnknownBuiltinFunction {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UnknownBuiltinFunctionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    name: ::core::convert::Into::into(value.name()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UnknownBuiltinFunctionRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UnknownBuiltinFunctionRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[UnknownBuiltinFunctionRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<UnknownBuiltinFunction>>
            for UnknownBuiltinFunction
        {
            type Value = ::planus::Offset<UnknownBuiltinFunction>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<UnknownBuiltinFunction>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UnknownBuiltinFunctionRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UnknownBuiltinFunctionRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `UnknownTypeConstant` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `UnknownTypeConstant` in the file `../../../schema/schema/common.fbs:192`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct UnknownTypeConstant {
            /// The field `context` in the table `UnknownTypeConstant`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `name` in the table `UnknownTypeConstant`
            pub name: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for UnknownTypeConstant {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                }
            }
        }

        impl UnknownTypeConstant {
            /// Creates a [UnknownTypeConstantBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UnknownTypeConstantBuilder<()> {
                UnknownTypeConstantBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_name: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_name = field_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<UnknownTypeConstant>> for UnknownTypeConstant {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownTypeConstant> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<UnknownTypeConstant>> for UnknownTypeConstant {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownTypeConstant>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<UnknownTypeConstant> for UnknownTypeConstant {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownTypeConstant> {
                UnknownTypeConstant::create(builder, &self.context, &self.name)
            }
        }

        /// Builder for serializing an instance of the [UnknownTypeConstant] type.
        ///
        /// Can be created using the [UnknownTypeConstant::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UnknownTypeConstantBuilder<State>(State);

        impl UnknownTypeConstantBuilder<()> {
            /// Setter for the [`context` field](UnknownTypeConstant#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> UnknownTypeConstantBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                UnknownTypeConstantBuilder((value,))
            }
        }

        impl<T0> UnknownTypeConstantBuilder<(T0,)> {
            /// Setter for the [`name` field](UnknownTypeConstant#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T1>(self, value: T1) -> UnknownTypeConstantBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                UnknownTypeConstantBuilder((v0, value))
            }
        }

        impl<T0, T1> UnknownTypeConstantBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UnknownTypeConstant].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownTypeConstant>
            where
                Self: ::planus::WriteAsOffset<UnknownTypeConstant>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<UnknownTypeConstant>>
            for UnknownTypeConstantBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownTypeConstant>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownTypeConstant> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<UnknownTypeConstant>>
            for UnknownTypeConstantBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownTypeConstant>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownTypeConstant>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<UnknownTypeConstant> for UnknownTypeConstantBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownTypeConstant> {
                let (v0, v1) = &self.0;
                UnknownTypeConstant::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [UnknownTypeConstant].
        #[derive(Copy, Clone)]
        pub struct UnknownTypeConstantRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UnknownTypeConstantRef<'a> {
            /// Getter for the [`context` field](UnknownTypeConstant#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "UnknownTypeConstant", "context")
            }

            /// Getter for the [`name` field](UnknownTypeConstant#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "UnknownTypeConstant", "name")
            }
        }

        impl<'a> ::core::fmt::Debug for UnknownTypeConstantRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UnknownTypeConstantRef");
                f.field("context", &self.context());
                f.field("name", &self.name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UnknownTypeConstantRef<'a>> for UnknownTypeConstant {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UnknownTypeConstantRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    name: ::core::convert::Into::into(value.name()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UnknownTypeConstantRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UnknownTypeConstantRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[UnknownTypeConstantRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<UnknownTypeConstant>> for UnknownTypeConstant {
            type Value = ::planus::Offset<UnknownTypeConstant>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<UnknownTypeConstant>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UnknownTypeConstantRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UnknownTypeConstantRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `UnknownLoopLabel` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `UnknownLoopLabel` in the file `../../../schema/schema/common.fbs:197`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct UnknownLoopLabel {
            /// The field `context` in the table `UnknownLoopLabel`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `label` in the table `UnknownLoopLabel`
            pub label: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for UnknownLoopLabel {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    label: ::core::default::Default::default(),
                }
            }
        }

        impl UnknownLoopLabel {
            /// Creates a [UnknownLoopLabelBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UnknownLoopLabelBuilder<()> {
                UnknownLoopLabelBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_label: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_label = field_label.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_label);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<UnknownLoopLabel>> for UnknownLoopLabel {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownLoopLabel> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<UnknownLoopLabel>> for UnknownLoopLabel {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownLoopLabel>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<UnknownLoopLabel> for UnknownLoopLabel {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownLoopLabel> {
                UnknownLoopLabel::create(builder, &self.context, &self.label)
            }
        }

        /// Builder for serializing an instance of the [UnknownLoopLabel] type.
        ///
        /// Can be created using the [UnknownLoopLabel::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UnknownLoopLabelBuilder<State>(State);

        impl UnknownLoopLabelBuilder<()> {
            /// Setter for the [`context` field](UnknownLoopLabel#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> UnknownLoopLabelBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                UnknownLoopLabelBuilder((value,))
            }
        }

        impl<T0> UnknownLoopLabelBuilder<(T0,)> {
            /// Setter for the [`label` field](UnknownLoopLabel#structfield.label).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn label<T1>(self, value: T1) -> UnknownLoopLabelBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                UnknownLoopLabelBuilder((v0, value))
            }
        }

        impl<T0, T1> UnknownLoopLabelBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UnknownLoopLabel].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownLoopLabel>
            where
                Self: ::planus::WriteAsOffset<UnknownLoopLabel>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<UnknownLoopLabel>>
            for UnknownLoopLabelBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownLoopLabel>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownLoopLabel> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<UnknownLoopLabel>>
            for UnknownLoopLabelBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownLoopLabel>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownLoopLabel>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<UnknownLoopLabel> for UnknownLoopLabelBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownLoopLabel> {
                let (v0, v1) = &self.0;
                UnknownLoopLabel::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [UnknownLoopLabel].
        #[derive(Copy, Clone)]
        pub struct UnknownLoopLabelRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UnknownLoopLabelRef<'a> {
            /// Getter for the [`context` field](UnknownLoopLabel#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "UnknownLoopLabel", "context")
            }

            /// Getter for the [`label` field](UnknownLoopLabel#structfield.label).
            #[inline]
            pub fn label(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "UnknownLoopLabel", "label")
            }
        }

        impl<'a> ::core::fmt::Debug for UnknownLoopLabelRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UnknownLoopLabelRef");
                f.field("context", &self.context());
                f.field("label", &self.label());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UnknownLoopLabelRef<'a>> for UnknownLoopLabel {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UnknownLoopLabelRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    label: ::core::convert::Into::into(value.label()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UnknownLoopLabelRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UnknownLoopLabelRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[UnknownLoopLabelRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<UnknownLoopLabel>> for UnknownLoopLabel {
            type Value = ::planus::Offset<UnknownLoopLabel>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<UnknownLoopLabel>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UnknownLoopLabelRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UnknownLoopLabelRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DuplicateVariable` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `DuplicateVariable` in the file `../../../schema/schema/common.fbs:202`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DuplicateVariable {
            /// The field `context` in the table `DuplicateVariable`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `var_name` in the table `DuplicateVariable`
            pub var_name: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DuplicateVariable {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    var_name: ::core::default::Default::default(),
                }
            }
        }

        impl DuplicateVariable {
            /// Creates a [DuplicateVariableBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DuplicateVariableBuilder<()> {
                DuplicateVariableBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_var_name: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_var_name = field_var_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_var_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DuplicateVariable>> for DuplicateVariable {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicateVariable> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DuplicateVariable>> for DuplicateVariable {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicateVariable>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DuplicateVariable> for DuplicateVariable {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicateVariable> {
                DuplicateVariable::create(builder, &self.context, &self.var_name)
            }
        }

        /// Builder for serializing an instance of the [DuplicateVariable] type.
        ///
        /// Can be created using the [DuplicateVariable::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DuplicateVariableBuilder<State>(State);

        impl DuplicateVariableBuilder<()> {
            /// Setter for the [`context` field](DuplicateVariable#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> DuplicateVariableBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                DuplicateVariableBuilder((value,))
            }
        }

        impl<T0> DuplicateVariableBuilder<(T0,)> {
            /// Setter for the [`var_name` field](DuplicateVariable#structfield.var_name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn var_name<T1>(self, value: T1) -> DuplicateVariableBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                DuplicateVariableBuilder((v0, value))
            }
        }

        impl<T0, T1> DuplicateVariableBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DuplicateVariable].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicateVariable>
            where
                Self: ::planus::WriteAsOffset<DuplicateVariable>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<DuplicateVariable>>
            for DuplicateVariableBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicateVariable>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicateVariable> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<DuplicateVariable>>
            for DuplicateVariableBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicateVariable>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicateVariable>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<DuplicateVariable> for DuplicateVariableBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicateVariable> {
                let (v0, v1) = &self.0;
                DuplicateVariable::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [DuplicateVariable].
        #[derive(Copy, Clone)]
        pub struct DuplicateVariableRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DuplicateVariableRef<'a> {
            /// Getter for the [`context` field](DuplicateVariable#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "DuplicateVariable", "context")
            }

            /// Getter for the [`var_name` field](DuplicateVariable#structfield.var_name).
            #[inline]
            pub fn var_name(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(1, "DuplicateVariable", "var_name")
            }
        }

        impl<'a> ::core::fmt::Debug for DuplicateVariableRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DuplicateVariableRef");
                f.field("context", &self.context());
                f.field("var_name", &self.var_name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DuplicateVariableRef<'a>> for DuplicateVariable {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DuplicateVariableRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    var_name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.var_name()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DuplicateVariableRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DuplicateVariableRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DuplicateVariableRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DuplicateVariable>> for DuplicateVariable {
            type Value = ::planus::Offset<DuplicateVariable>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DuplicateVariable>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DuplicateVariableRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DuplicateVariableRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `AssignToConst` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `AssignToConst` in the file `../../../schema/schema/common.fbs:207`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct AssignToConst {
            /// The field `context` in the table `AssignToConst`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `var_name` in the table `AssignToConst`
            pub var_name: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for AssignToConst {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    var_name: ::core::default::Default::default(),
                }
            }
        }

        impl AssignToConst {
            /// Creates a [AssignToConstBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AssignToConstBuilder<()> {
                AssignToConstBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_var_name: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_var_name = field_var_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_var_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<AssignToConst>> for AssignToConst {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AssignToConst> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<AssignToConst>> for AssignToConst {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AssignToConst>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<AssignToConst> for AssignToConst {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AssignToConst> {
                AssignToConst::create(builder, &self.context, &self.var_name)
            }
        }

        /// Builder for serializing an instance of the [AssignToConst] type.
        ///
        /// Can be created using the [AssignToConst::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AssignToConstBuilder<State>(State);

        impl AssignToConstBuilder<()> {
            /// Setter for the [`context` field](AssignToConst#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> AssignToConstBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                AssignToConstBuilder((value,))
            }
        }

        impl<T0> AssignToConstBuilder<(T0,)> {
            /// Setter for the [`var_name` field](AssignToConst#structfield.var_name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn var_name<T1>(self, value: T1) -> AssignToConstBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                AssignToConstBuilder((v0, value))
            }
        }

        impl<T0, T1> AssignToConstBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AssignToConst].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<AssignToConst>
            where
                Self: ::planus::WriteAsOffset<AssignToConst>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<AssignToConst>> for AssignToConstBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<AssignToConst>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AssignToConst> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<AssignToConst>>
            for AssignToConstBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<AssignToConst>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AssignToConst>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<AssignToConst> for AssignToConstBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AssignToConst> {
                let (v0, v1) = &self.0;
                AssignToConst::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [AssignToConst].
        #[derive(Copy, Clone)]
        pub struct AssignToConstRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AssignToConstRef<'a> {
            /// Getter for the [`context` field](AssignToConst#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "AssignToConst", "context")
            }

            /// Getter for the [`var_name` field](AssignToConst#structfield.var_name).
            #[inline]
            pub fn var_name(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(1, "AssignToConst", "var_name")
            }
        }

        impl<'a> ::core::fmt::Debug for AssignToConstRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AssignToConstRef");
                f.field("context", &self.context());
                f.field("var_name", &self.var_name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AssignToConstRef<'a>> for AssignToConst {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AssignToConstRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    var_name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.var_name()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AssignToConstRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AssignToConstRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[AssignToConstRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<AssignToConst>> for AssignToConst {
            type Value = ::planus::Offset<AssignToConst>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<AssignToConst>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AssignToConstRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AssignToConstRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DisabledFeature` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `DisabledFeature` in the file `../../../schema/schema/common.fbs:212`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DisabledFeature {
            /// The field `context` in the table `DisabledFeature`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `feature` in the table `DisabledFeature`
            pub feature: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DisabledFeature {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    feature: ::core::default::Default::default(),
                }
            }
        }

        impl DisabledFeature {
            /// Creates a [DisabledFeatureBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DisabledFeatureBuilder<()> {
                DisabledFeatureBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_feature: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_feature = field_feature.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_feature);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DisabledFeature>> for DisabledFeature {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisabledFeature> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DisabledFeature>> for DisabledFeature {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DisabledFeature>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DisabledFeature> for DisabledFeature {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisabledFeature> {
                DisabledFeature::create(builder, &self.context, &self.feature)
            }
        }

        /// Builder for serializing an instance of the [DisabledFeature] type.
        ///
        /// Can be created using the [DisabledFeature::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DisabledFeatureBuilder<State>(State);

        impl DisabledFeatureBuilder<()> {
            /// Setter for the [`context` field](DisabledFeature#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> DisabledFeatureBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                DisabledFeatureBuilder((value,))
            }
        }

        impl<T0> DisabledFeatureBuilder<(T0,)> {
            /// Setter for the [`feature` field](DisabledFeature#structfield.feature).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn feature<T1>(self, value: T1) -> DisabledFeatureBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                DisabledFeatureBuilder((v0, value))
            }
        }

        impl<T0, T1> DisabledFeatureBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DisabledFeature].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisabledFeature>
            where
                Self: ::planus::WriteAsOffset<DisabledFeature>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<DisabledFeature>>
            for DisabledFeatureBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DisabledFeature>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisabledFeature> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<DisabledFeature>>
            for DisabledFeatureBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DisabledFeature>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DisabledFeature>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<DisabledFeature> for DisabledFeatureBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisabledFeature> {
                let (v0, v1) = &self.0;
                DisabledFeature::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [DisabledFeature].
        #[derive(Copy, Clone)]
        pub struct DisabledFeatureRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DisabledFeatureRef<'a> {
            /// Getter for the [`context` field](DisabledFeature#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "DisabledFeature", "context")
            }

            /// Getter for the [`feature` field](DisabledFeature#structfield.feature).
            #[inline]
            pub fn feature(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "DisabledFeature", "feature")
            }
        }

        impl<'a> ::core::fmt::Debug for DisabledFeatureRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DisabledFeatureRef");
                f.field("context", &self.context());
                f.field("feature", &self.feature());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DisabledFeatureRef<'a>> for DisabledFeature {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DisabledFeatureRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    feature: ::core::convert::Into::into(value.feature()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DisabledFeatureRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DisabledFeatureRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DisabledFeatureRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DisabledFeature>> for DisabledFeature {
            type Value = ::planus::Offset<DisabledFeature>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DisabledFeature>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DisabledFeatureRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DisabledFeatureRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `BadSlotName` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `BadSlotName` in the file `../../../schema/schema/common.fbs:217`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct BadSlotName {
            /// The field `context` in the table `BadSlotName`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `slot` in the table `BadSlotName`
            pub slot: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for BadSlotName {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    slot: ::core::default::Default::default(),
                }
            }
        }

        impl BadSlotName {
            /// Creates a [BadSlotNameBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> BadSlotNameBuilder<()> {
                BadSlotNameBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_slot: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_slot = field_slot.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_slot);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<BadSlotName>> for BadSlotName {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BadSlotName> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<BadSlotName>> for BadSlotName {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<BadSlotName>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<BadSlotName> for BadSlotName {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BadSlotName> {
                BadSlotName::create(builder, &self.context, &self.slot)
            }
        }

        /// Builder for serializing an instance of the [BadSlotName] type.
        ///
        /// Can be created using the [BadSlotName::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct BadSlotNameBuilder<State>(State);

        impl BadSlotNameBuilder<()> {
            /// Setter for the [`context` field](BadSlotName#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> BadSlotNameBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                BadSlotNameBuilder((value,))
            }
        }

        impl<T0> BadSlotNameBuilder<(T0,)> {
            /// Setter for the [`slot` field](BadSlotName#structfield.slot).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn slot<T1>(self, value: T1) -> BadSlotNameBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                BadSlotNameBuilder((v0, value))
            }
        }

        impl<T0, T1> BadSlotNameBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BadSlotName].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<BadSlotName>
            where
                Self: ::planus::WriteAsOffset<BadSlotName>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<BadSlotName>> for BadSlotNameBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<BadSlotName>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BadSlotName> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<BadSlotName>>
            for BadSlotNameBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<BadSlotName>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<BadSlotName>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<BadSlotName> for BadSlotNameBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BadSlotName> {
                let (v0, v1) = &self.0;
                BadSlotName::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [BadSlotName].
        #[derive(Copy, Clone)]
        pub struct BadSlotNameRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> BadSlotNameRef<'a> {
            /// Getter for the [`context` field](BadSlotName#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "BadSlotName", "context")
            }

            /// Getter for the [`slot` field](BadSlotName#structfield.slot).
            #[inline]
            pub fn slot(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "BadSlotName", "slot")
            }
        }

        impl<'a> ::core::fmt::Debug for BadSlotNameRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("BadSlotNameRef");
                f.field("context", &self.context());
                f.field("slot", &self.slot());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<BadSlotNameRef<'a>> for BadSlotName {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: BadSlotNameRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    slot: ::core::convert::Into::into(value.slot()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for BadSlotNameRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for BadSlotNameRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[BadSlotNameRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<BadSlotName>> for BadSlotName {
            type Value = ::planus::Offset<BadSlotName>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<BadSlotName>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for BadSlotNameRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[BadSlotNameRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `InvalidAssignment` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `InvalidAssignment` in the file `../../../schema/schema/common.fbs:222`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct InvalidAssignment {
            /// The field `context` in the table `InvalidAssignment`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for InvalidAssignment {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                }
            }
        }

        impl InvalidAssignment {
            /// Creates a [InvalidAssignmentBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> InvalidAssignmentBuilder<()> {
                InvalidAssignmentBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<InvalidAssignment>> for InvalidAssignment {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidAssignment> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<InvalidAssignment>> for InvalidAssignment {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidAssignment>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<InvalidAssignment> for InvalidAssignment {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidAssignment> {
                InvalidAssignment::create(builder, &self.context)
            }
        }

        /// Builder for serializing an instance of the [InvalidAssignment] type.
        ///
        /// Can be created using the [InvalidAssignment::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct InvalidAssignmentBuilder<State>(State);

        impl InvalidAssignmentBuilder<()> {
            /// Setter for the [`context` field](InvalidAssignment#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> InvalidAssignmentBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                InvalidAssignmentBuilder((value,))
            }
        }

        impl<T0> InvalidAssignmentBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [InvalidAssignment].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidAssignment>
            where
                Self: ::planus::WriteAsOffset<InvalidAssignment>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>>
            ::planus::WriteAs<::planus::Offset<InvalidAssignment>>
            for InvalidAssignmentBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidAssignment>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidAssignment> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>>
            ::planus::WriteAsOptional<::planus::Offset<InvalidAssignment>>
            for InvalidAssignmentBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidAssignment>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidAssignment>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>>
            ::planus::WriteAsOffset<InvalidAssignment> for InvalidAssignmentBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidAssignment> {
                let (v0,) = &self.0;
                InvalidAssignment::create(builder, v0)
            }
        }

        /// Reference to a deserialized [InvalidAssignment].
        #[derive(Copy, Clone)]
        pub struct InvalidAssignmentRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> InvalidAssignmentRef<'a> {
            /// Getter for the [`context` field](InvalidAssignment#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "InvalidAssignment", "context")
            }
        }

        impl<'a> ::core::fmt::Debug for InvalidAssignmentRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("InvalidAssignmentRef");
                f.field("context", &self.context());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<InvalidAssignmentRef<'a>> for InvalidAssignment {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: InvalidAssignmentRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for InvalidAssignmentRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for InvalidAssignmentRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[InvalidAssignmentRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<InvalidAssignment>> for InvalidAssignment {
            type Value = ::planus::Offset<InvalidAssignment>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<InvalidAssignment>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for InvalidAssignmentRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[InvalidAssignmentRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `CompileErrorUnion` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Union `CompileErrorUnion` in the file `../../../schema/schema/common.fbs:226`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum CompileErrorUnion {
            /// The variant of type `StringLexError` in the union `CompileErrorUnion`
            StringLexError(::planus::alloc::boxed::Box<self::StringLexError>),

            /// The variant of type `ParseError` in the union `CompileErrorUnion`
            ParseError(::planus::alloc::boxed::Box<self::ParseError>),

            /// The variant of type `UnknownBuiltinFunction` in the union `CompileErrorUnion`
            UnknownBuiltinFunction(::planus::alloc::boxed::Box<self::UnknownBuiltinFunction>),

            /// The variant of type `UnknownTypeConstant` in the union `CompileErrorUnion`
            UnknownTypeConstant(::planus::alloc::boxed::Box<self::UnknownTypeConstant>),

            /// The variant of type `UnknownLoopLabel` in the union `CompileErrorUnion`
            UnknownLoopLabel(::planus::alloc::boxed::Box<self::UnknownLoopLabel>),

            /// The variant of type `DuplicateVariable` in the union `CompileErrorUnion`
            DuplicateVariable(::planus::alloc::boxed::Box<self::DuplicateVariable>),

            /// The variant of type `AssignToConst` in the union `CompileErrorUnion`
            AssignToConst(::planus::alloc::boxed::Box<self::AssignToConst>),

            /// The variant of type `DisabledFeature` in the union `CompileErrorUnion`
            DisabledFeature(::planus::alloc::boxed::Box<self::DisabledFeature>),

            /// The variant of type `BadSlotName` in the union `CompileErrorUnion`
            BadSlotName(::planus::alloc::boxed::Box<self::BadSlotName>),

            /// The variant of type `InvalidAssignment` in the union `CompileErrorUnion`
            InvalidAssignment(::planus::alloc::boxed::Box<self::InvalidAssignment>),
        }

        impl CompileErrorUnion {
            /// Creates a [CompileErrorUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CompileErrorUnionBuilder<::planus::Uninitialized> {
                CompileErrorUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_string_lex_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::StringLexError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_parse_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ParseError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_unknown_builtin_function(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::UnknownBuiltinFunction>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_unknown_type_constant(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::UnknownTypeConstant>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_unknown_loop_label(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::UnknownLoopLabel>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_duplicate_variable(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DuplicateVariable>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_assign_to_const(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::AssignToConst>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_disabled_feature(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DisabledFeature>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_bad_slot_name(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::BadSlotName>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_invalid_assignment(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::InvalidAssignment>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<CompileErrorUnion> for CompileErrorUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::StringLexError(value) => Self::create_string_lex_error(builder, value),
                    Self::ParseError(value) => Self::create_parse_error(builder, value),
                    Self::UnknownBuiltinFunction(value) => {
                        Self::create_unknown_builtin_function(builder, value)
                    }
                    Self::UnknownTypeConstant(value) => {
                        Self::create_unknown_type_constant(builder, value)
                    }
                    Self::UnknownLoopLabel(value) => {
                        Self::create_unknown_loop_label(builder, value)
                    }
                    Self::DuplicateVariable(value) => {
                        Self::create_duplicate_variable(builder, value)
                    }
                    Self::AssignToConst(value) => Self::create_assign_to_const(builder, value),
                    Self::DisabledFeature(value) => Self::create_disabled_feature(builder, value),
                    Self::BadSlotName(value) => Self::create_bad_slot_name(builder, value),
                    Self::InvalidAssignment(value) => {
                        Self::create_invalid_assignment(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<CompileErrorUnion> for CompileErrorUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [CompileErrorUnion] type.
        ///
        /// Can be created using the [CompileErrorUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CompileErrorUnionBuilder<T>(T);

        impl CompileErrorUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`StringLexError` variant](CompileErrorUnion#variant.StringLexError).
            #[inline]
            pub fn string_lex_error<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::StringLexError>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ParseError` variant](CompileErrorUnion#variant.ParseError).
            #[inline]
            pub fn parse_error<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::ParseError>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`UnknownBuiltinFunction` variant](CompileErrorUnion#variant.UnknownBuiltinFunction).
            #[inline]
            pub fn unknown_builtin_function<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::UnknownBuiltinFunction>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`UnknownTypeConstant` variant](CompileErrorUnion#variant.UnknownTypeConstant).
            #[inline]
            pub fn unknown_type_constant<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::UnknownTypeConstant>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`UnknownLoopLabel` variant](CompileErrorUnion#variant.UnknownLoopLabel).
            #[inline]
            pub fn unknown_loop_label<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::UnknownLoopLabel>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DuplicateVariable` variant](CompileErrorUnion#variant.DuplicateVariable).
            #[inline]
            pub fn duplicate_variable<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::DuplicateVariable>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`AssignToConst` variant](CompileErrorUnion#variant.AssignToConst).
            #[inline]
            pub fn assign_to_const<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<self::AssignToConst>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DisabledFeature` variant](CompileErrorUnion#variant.DisabledFeature).
            #[inline]
            pub fn disabled_feature<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<self::DisabledFeature>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`BadSlotName` variant](CompileErrorUnion#variant.BadSlotName).
            #[inline]
            pub fn bad_slot_name<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<self::BadSlotName>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`InvalidAssignment` variant](CompileErrorUnion#variant.InvalidAssignment).
            #[inline]
            pub fn invalid_assignment<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<self::InvalidAssignment>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> CompileErrorUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [CompileErrorUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion>
            where
                Self: ::planus::WriteAsUnion<CompileErrorUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::StringLexError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::StringLexError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ParseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ParseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownBuiltinFunction>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownBuiltinFunction>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownTypeConstant>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownTypeConstant>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownLoopLabel>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownLoopLabel>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicateVariable>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicateVariable>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::AssignToConst>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::AssignToConst>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::DisabledFeature>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::DisabledFeature>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::BadSlotName>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::BadSlotName>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidAssignment>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidAssignment>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [CompileErrorUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum CompileErrorUnionRef<'a> {
            StringLexError(self::StringLexErrorRef<'a>),
            ParseError(self::ParseErrorRef<'a>),
            UnknownBuiltinFunction(self::UnknownBuiltinFunctionRef<'a>),
            UnknownTypeConstant(self::UnknownTypeConstantRef<'a>),
            UnknownLoopLabel(self::UnknownLoopLabelRef<'a>),
            DuplicateVariable(self::DuplicateVariableRef<'a>),
            AssignToConst(self::AssignToConstRef<'a>),
            DisabledFeature(self::DisabledFeatureRef<'a>),
            BadSlotName(self::BadSlotNameRef<'a>),
            InvalidAssignment(self::InvalidAssignmentRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<CompileErrorUnionRef<'a>> for CompileErrorUnion {
            type Error = ::planus::Error;

            fn try_from(value: CompileErrorUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    CompileErrorUnionRef::StringLexError(value) => {
                        Self::StringLexError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::ParseError(value) => {
                        Self::ParseError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::UnknownBuiltinFunction(value) => {
                        Self::UnknownBuiltinFunction(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::UnknownTypeConstant(value) => {
                        Self::UnknownTypeConstant(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::UnknownLoopLabel(value) => {
                        Self::UnknownLoopLabel(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::DuplicateVariable(value) => {
                        Self::DuplicateVariable(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::AssignToConst(value) => {
                        Self::AssignToConst(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::DisabledFeature(value) => {
                        Self::DisabledFeature(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::BadSlotName(value) => {
                        Self::BadSlotName(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::InvalidAssignment(value) => {
                        Self::InvalidAssignment(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for CompileErrorUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::StringLexError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::ParseError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::UnknownBuiltinFunction(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::UnknownTypeConstant(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::UnknownLoopLabel(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    6 => ::core::result::Result::Ok(Self::DuplicateVariable(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    7 => ::core::result::Result::Ok(Self::AssignToConst(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    8 => ::core::result::Result::Ok(Self::DisabledFeature(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    9 => ::core::result::Result::Ok(Self::BadSlotName(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    10 => ::core::result::Result::Ok(Self::InvalidAssignment(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for CompileErrorUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[CompileErrorUnionRef]";
        }

        /// The table `CompileError` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `CompileError` in the file `../../../schema/schema/common.fbs:239`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CompileError {
            /// The field `error` in the table `CompileError`
            pub error: self::CompileErrorUnion,
        }

        impl CompileError {
            /// Creates a [CompileErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CompileErrorBuilder<()> {
                CompileErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAsUnion<self::CompileErrorUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileErrorUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error.offset());
                        object_writer.write::<_, _, 1>(&prepared_error.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CompileError>> for CompileError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CompileError>> for CompileError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CompileError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CompileError> for CompileError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileError> {
                CompileError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [CompileError] type.
        ///
        /// Can be created using the [CompileError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CompileErrorBuilder<State>(State);

        impl CompileErrorBuilder<()> {
            /// Setter for the [`error` field](CompileError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> CompileErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::CompileErrorUnion>,
            {
                CompileErrorBuilder((value,))
            }
        }

        impl<T0> CompileErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CompileError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileError>
            where
                Self: ::planus::WriteAsOffset<CompileError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::CompileErrorUnion>>
            ::planus::WriteAs<::planus::Offset<CompileError>> for CompileErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CompileError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::CompileErrorUnion>>
            ::planus::WriteAsOptional<::planus::Offset<CompileError>>
            for CompileErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CompileError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CompileError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::CompileErrorUnion>>
            ::planus::WriteAsOffset<CompileError> for CompileErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileError> {
                let (v0,) = &self.0;
                CompileError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [CompileError].
        #[derive(Copy, Clone)]
        pub struct CompileErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CompileErrorRef<'a> {
            /// Getter for the [`error` field](CompileError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::CompileErrorUnionRef<'a>> {
                self.0.access_union_required(0, "CompileError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for CompileErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CompileErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CompileErrorRef<'a>> for CompileError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CompileErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::core::convert::TryInto::try_into(value.error()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CompileErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CompileErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CompileErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CompileError>> for CompileError {
            type Value = ::planus::Offset<CompileError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CompileError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CompileErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CompileErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `ObjectRefUnion` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Union `ObjectRefUnion` in the file `../../../schema/schema/common.fbs:247`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum ObjectRefUnion {
            /// The variant of type `ObjectRefId` in the union `ObjectRefUnion`
            ObjectRefId(::planus::alloc::boxed::Box<self::ObjectRefId>),

            /// The variant of type `ObjectRefSysObj` in the union `ObjectRefUnion`
            ObjectRefSysObj(::planus::alloc::boxed::Box<self::ObjectRefSysObj>),

            /// The variant of type `ObjectRefMatch` in the union `ObjectRefUnion`
            ObjectRefMatch(::planus::alloc::boxed::Box<self::ObjectRefMatch>),
        }

        impl ObjectRefUnion {
            /// Creates a [ObjectRefUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectRefUnionBuilder<::planus::Uninitialized> {
                ObjectRefUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_object_ref_id(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectRefId>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_object_ref_sys_obj(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectRefSysObj>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_object_ref_match(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectRefMatch>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<ObjectRefUnion> for ObjectRefUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::ObjectRefId(value) => Self::create_object_ref_id(builder, value),
                    Self::ObjectRefSysObj(value) => Self::create_object_ref_sys_obj(builder, value),
                    Self::ObjectRefMatch(value) => Self::create_object_ref_match(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<ObjectRefUnion> for ObjectRefUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [ObjectRefUnion] type.
        ///
        /// Can be created using the [ObjectRefUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectRefUnionBuilder<T>(T);

        impl ObjectRefUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`ObjectRefId` variant](ObjectRefUnion#variant.ObjectRefId).
            #[inline]
            pub fn object_ref_id<T>(
                self,
                value: T,
            ) -> ObjectRefUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectRefId>,
            {
                ObjectRefUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ObjectRefSysObj` variant](ObjectRefUnion#variant.ObjectRefSysObj).
            #[inline]
            pub fn object_ref_sys_obj<T>(
                self,
                value: T,
            ) -> ObjectRefUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectRefSysObj>,
            {
                ObjectRefUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ObjectRefMatch` variant](ObjectRefUnion#variant.ObjectRefMatch).
            #[inline]
            pub fn object_ref_match<T>(
                self,
                value: T,
            ) -> ObjectRefUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectRefMatch>,
            {
                ObjectRefUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> ObjectRefUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [ObjectRefUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ObjectRefUnion>
            where
                Self: ::planus::WriteAsUnion<ObjectRefUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefId>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ObjectRefUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefId>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjectRefUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefSysObj>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ObjectRefUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefSysObj>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjectRefUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ObjectRefUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjectRefUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [ObjectRefUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum ObjectRefUnionRef<'a> {
            ObjectRefId(self::ObjectRefIdRef<'a>),
            ObjectRefSysObj(self::ObjectRefSysObjRef<'a>),
            ObjectRefMatch(self::ObjectRefMatchRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<ObjectRefUnionRef<'a>> for ObjectRefUnion {
            type Error = ::planus::Error;

            fn try_from(value: ObjectRefUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    ObjectRefUnionRef::ObjectRefId(value) => {
                        Self::ObjectRefId(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ObjectRefUnionRef::ObjectRefSysObj(value) => {
                        Self::ObjectRefSysObj(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ObjectRefUnionRef::ObjectRefMatch(value) => {
                        Self::ObjectRefMatch(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for ObjectRefUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::ObjectRefId(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::ObjectRefSysObj(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::ObjectRefMatch(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for ObjectRefUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[ObjectRefUnionRef]";
        }

        /// The table `ObjectRefId` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ObjectRefId` in the file `../../../schema/schema/common.fbs:253`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectRefId {
            /// The field `obj` in the table `ObjectRefId`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
        }

        impl ObjectRefId {
            /// Creates a [ObjectRefIdBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectRefIdBuilder<()> {
                ObjectRefIdBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectRefId>> for ObjectRefId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectRefId>> for ObjectRefId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectRefId> for ObjectRefId {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefId> {
                ObjectRefId::create(builder, &self.obj)
            }
        }

        /// Builder for serializing an instance of the [ObjectRefId] type.
        ///
        /// Can be created using the [ObjectRefId::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectRefIdBuilder<State>(State);

        impl ObjectRefIdBuilder<()> {
            /// Setter for the [`obj` field](ObjectRefId#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> ObjectRefIdBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                ObjectRefIdBuilder((value,))
            }
        }

        impl<T0> ObjectRefIdBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectRefId].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefId>
            where
                Self: ::planus::WriteAsOffset<ObjectRefId>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAs<::planus::Offset<ObjectRefId>> for ObjectRefIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefId>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectRefId>> for ObjectRefIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefId>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAsOffset<ObjectRefId> for ObjectRefIdBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefId> {
                let (v0,) = &self.0;
                ObjectRefId::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectRefId].
        #[derive(Copy, Clone)]
        pub struct ObjectRefIdRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectRefIdRef<'a> {
            /// Getter for the [`obj` field](ObjectRefId#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "ObjectRefId", "obj")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectRefIdRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectRefIdRef");
                f.field("obj", &self.obj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectRefIdRef<'a>> for ObjectRefId {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectRefIdRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectRefIdRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectRefIdRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectRefIdRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectRefId>> for ObjectRefId {
            type Value = ::planus::Offset<ObjectRefId>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectRefId>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectRefIdRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectRefIdRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectRefSysObj` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ObjectRefSysObj` in the file `../../../schema/schema/common.fbs:257`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectRefSysObj {
            /// The field `symbols` in the table `ObjectRefSysObj`
            pub symbols: ::planus::alloc::vec::Vec<self::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ObjectRefSysObj {
            fn default() -> Self {
                Self {
                    symbols: ::core::default::Default::default(),
                }
            }
        }

        impl ObjectRefSysObj {
            /// Creates a [ObjectRefSysObjBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectRefSysObjBuilder<()> {
                ObjectRefSysObjBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_symbols: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::Symbol>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_symbols = field_symbols.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Symbol>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_symbols);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectRefSysObj>> for ObjectRefSysObj {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectRefSysObj> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectRefSysObj>> for ObjectRefSysObj {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefSysObj>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectRefSysObj> for ObjectRefSysObj {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectRefSysObj> {
                ObjectRefSysObj::create(builder, &self.symbols)
            }
        }

        /// Builder for serializing an instance of the [ObjectRefSysObj] type.
        ///
        /// Can be created using the [ObjectRefSysObj::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectRefSysObjBuilder<State>(State);

        impl ObjectRefSysObjBuilder<()> {
            /// Setter for the [`symbols` field](ObjectRefSysObj#structfield.symbols).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn symbols<T0>(self, value: T0) -> ObjectRefSysObjBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            {
                ObjectRefSysObjBuilder((value,))
            }
        }

        impl<T0> ObjectRefSysObjBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectRefSysObj].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectRefSysObj>
            where
                Self: ::planus::WriteAsOffset<ObjectRefSysObj>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>>
            ::planus::WriteAs<::planus::Offset<ObjectRefSysObj>> for ObjectRefSysObjBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefSysObj>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectRefSysObj> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectRefSysObj>>
            for ObjectRefSysObjBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefSysObj>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefSysObj>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>>
            ::planus::WriteAsOffset<ObjectRefSysObj> for ObjectRefSysObjBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectRefSysObj> {
                let (v0,) = &self.0;
                ObjectRefSysObj::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectRefSysObj].
        #[derive(Copy, Clone)]
        pub struct ObjectRefSysObjRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectRefSysObjRef<'a> {
            /// Getter for the [`symbols` field](ObjectRefSysObj#structfield.symbols).
            #[inline]
            pub fn symbols(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::SymbolRef<'a>>>>
            {
                self.0.access_required(0, "ObjectRefSysObj", "symbols")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectRefSysObjRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectRefSysObjRef");
                f.field("symbols", &self.symbols());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectRefSysObjRef<'a>> for ObjectRefSysObj {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectRefSysObjRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    symbols: value.symbols()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectRefSysObjRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectRefSysObjRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectRefSysObjRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectRefSysObj>> for ObjectRefSysObj {
            type Value = ::planus::Offset<ObjectRefSysObj>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectRefSysObj>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectRefSysObjRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectRefSysObjRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectRefMatch` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ObjectRefMatch` in the file `../../../schema/schema/common.fbs:261`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectRefMatch {
            /// The field `match_string` in the table `ObjectRefMatch`
            pub match_string: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ObjectRefMatch {
            fn default() -> Self {
                Self {
                    match_string: ::core::default::Default::default(),
                }
            }
        }

        impl ObjectRefMatch {
            /// Creates a [ObjectRefMatchBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectRefMatchBuilder<()> {
                ObjectRefMatchBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_match_string: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_match_string = field_match_string.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_match_string);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectRefMatch>> for ObjectRefMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectRefMatch>> for ObjectRefMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectRefMatch> for ObjectRefMatch {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefMatch> {
                ObjectRefMatch::create(builder, &self.match_string)
            }
        }

        /// Builder for serializing an instance of the [ObjectRefMatch] type.
        ///
        /// Can be created using the [ObjectRefMatch::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectRefMatchBuilder<State>(State);

        impl ObjectRefMatchBuilder<()> {
            /// Setter for the [`match_string` field](ObjectRefMatch#structfield.match_string).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn match_string<T0>(self, value: T0) -> ObjectRefMatchBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                ObjectRefMatchBuilder((value,))
            }
        }

        impl<T0> ObjectRefMatchBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectRefMatch].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefMatch>
            where
                Self: ::planus::WriteAsOffset<ObjectRefMatch>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<ObjectRefMatch>> for ObjectRefMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefMatch>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectRefMatch>>
            for ObjectRefMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefMatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<ObjectRefMatch>
            for ObjectRefMatchBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefMatch> {
                let (v0,) = &self.0;
                ObjectRefMatch::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectRefMatch].
        #[derive(Copy, Clone)]
        pub struct ObjectRefMatchRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectRefMatchRef<'a> {
            /// Getter for the [`match_string` field](ObjectRefMatch#structfield.match_string).
            #[inline]
            pub fn match_string(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "ObjectRefMatch", "match_string")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectRefMatchRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectRefMatchRef");
                f.field("match_string", &self.match_string());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectRefMatchRef<'a>> for ObjectRefMatch {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectRefMatchRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    match_string: ::core::convert::Into::into(value.match_string()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectRefMatchRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectRefMatchRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectRefMatchRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectRefMatch>> for ObjectRefMatch {
            type Value = ::planus::Offset<ObjectRefMatch>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectRefMatch>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectRefMatchRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectRefMatchRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectRef` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ObjectRef` in the file `../../../schema/schema/common.fbs:265`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectRef {
            /// The field `ref` in the table `ObjectRef`
            pub ref_: self::ObjectRefUnion,
        }

        impl ObjectRef {
            /// Creates a [ObjectRefBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectRefBuilder<()> {
                ObjectRefBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_ref_: impl ::planus::WriteAsUnion<self::ObjectRefUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_ref_ = field_ref_.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ObjectRefUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_ref_.offset());
                        object_writer.write::<_, _, 1>(&prepared_ref_.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectRef>> for ObjectRef {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRef> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectRef>> for ObjectRef {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRef>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectRef> for ObjectRef {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRef> {
                ObjectRef::create(builder, &self.ref_)
            }
        }

        /// Builder for serializing an instance of the [ObjectRef] type.
        ///
        /// Can be created using the [ObjectRef::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectRefBuilder<State>(State);

        impl ObjectRefBuilder<()> {
            /// Setter for the [`ref` field](ObjectRef#structfield.ref_).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn ref_<T0>(self, value: T0) -> ObjectRefBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::ObjectRefUnion>,
            {
                ObjectRefBuilder((value,))
            }
        }

        impl<T0> ObjectRefBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectRef].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRef>
            where
                Self: ::planus::WriteAsOffset<ObjectRef>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjectRefUnion>>
            ::planus::WriteAs<::planus::Offset<ObjectRef>> for ObjectRefBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRef>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRef> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjectRefUnion>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectRef>> for ObjectRefBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRef>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRef>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjectRefUnion>> ::planus::WriteAsOffset<ObjectRef>
            for ObjectRefBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRef> {
                let (v0,) = &self.0;
                ObjectRef::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectRef].
        #[derive(Copy, Clone)]
        pub struct ObjectRefRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectRefRef<'a> {
            /// Getter for the [`ref` field](ObjectRef#structfield.ref_).
            #[inline]
            pub fn ref_(&self) -> ::planus::Result<self::ObjectRefUnionRef<'a>> {
                self.0.access_union_required(0, "ObjectRef", "ref_")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectRefRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectRefRef");
                f.field("ref_", &self.ref_());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectRefRef<'a>> for ObjectRef {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectRefRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    ref_: ::core::convert::TryInto::try_into(value.ref_()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectRefRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectRefRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectRefRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectRef>> for ObjectRef {
            type Value = ::planus::Offset<ObjectRef>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectRef>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectRefRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectRefRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `WorldStateErrorUnion` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Union `WorldStateErrorUnion` in the file `../../../schema/schema/common.fbs:273`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum WorldStateErrorUnion {
            /// The variant of type `ObjectNotFound` in the union `WorldStateErrorUnion`
            ObjectNotFound(::planus::alloc::boxed::Box<self::ObjectNotFound>),

            /// The variant of type `ObjectAlreadyExists` in the union `WorldStateErrorUnion`
            ObjectAlreadyExists(::planus::alloc::boxed::Box<self::ObjectAlreadyExists>),

            /// The variant of type `RecursiveMove` in the union `WorldStateErrorUnion`
            RecursiveMove(::planus::alloc::boxed::Box<self::RecursiveMove>),

            /// The variant of type `ObjectPermissionDenied` in the union `WorldStateErrorUnion`
            ObjectPermissionDenied(::planus::alloc::boxed::Box<self::ObjectPermissionDenied>),

            /// The variant of type `PropertyNotFound` in the union `WorldStateErrorUnion`
            PropertyNotFound(::planus::alloc::boxed::Box<self::PropertyNotFound>),

            /// The variant of type `PropertyPermissionDenied` in the union `WorldStateErrorUnion`
            PropertyPermissionDenied(::planus::alloc::boxed::Box<self::PropertyPermissionDenied>),

            /// The variant of type `PropertyDefinitionNotFound` in the union `WorldStateErrorUnion`
            PropertyDefinitionNotFound(
                ::planus::alloc::boxed::Box<self::PropertyDefinitionNotFound>,
            ),

            /// The variant of type `DuplicatePropertyDefinition` in the union `WorldStateErrorUnion`
            DuplicatePropertyDefinition(
                ::planus::alloc::boxed::Box<self::DuplicatePropertyDefinition>,
            ),

            /// The variant of type `ChparentPropertyNameConflict` in the union `WorldStateErrorUnion`
            ChparentPropertyNameConflict(
                ::planus::alloc::boxed::Box<self::ChparentPropertyNameConflict>,
            ),

            /// The variant of type `PropertyTypeMismatch` in the union `WorldStateErrorUnion`
            PropertyTypeMismatch(::planus::alloc::boxed::Box<self::PropertyTypeMismatch>),

            /// The variant of type `VerbNotFound` in the union `WorldStateErrorUnion`
            VerbNotFound(::planus::alloc::boxed::Box<self::VerbNotFound>),

            /// The variant of type `InvalidVerb` in the union `WorldStateErrorUnion`
            InvalidVerb(::planus::alloc::boxed::Box<self::InvalidVerb>),

            /// The variant of type `VerbDecodeError` in the union `WorldStateErrorUnion`
            VerbDecodeError(::planus::alloc::boxed::Box<self::VerbDecodeError>),

            /// The variant of type `VerbPermissionDenied` in the union `WorldStateErrorUnion`
            VerbPermissionDenied(::planus::alloc::boxed::Box<self::VerbPermissionDenied>),

            /// The variant of type `DuplicateVerb` in the union `WorldStateErrorUnion`
            DuplicateVerb(::planus::alloc::boxed::Box<self::DuplicateVerb>),

            /// The variant of type `FailedMatch` in the union `WorldStateErrorUnion`
            FailedMatch(::planus::alloc::boxed::Box<self::FailedMatch>),

            /// The variant of type `AmbiguousMatch` in the union `WorldStateErrorUnion`
            AmbiguousMatch(::planus::alloc::boxed::Box<self::AmbiguousMatch>),

            /// The variant of type `InvalidRenumber` in the union `WorldStateErrorUnion`
            InvalidRenumber(::planus::alloc::boxed::Box<self::InvalidRenumber>),

            /// The variant of type `WorldStateDatabaseError` in the union `WorldStateErrorUnion`
            WorldStateDatabaseError(::planus::alloc::boxed::Box<self::WorldStateDatabaseError>),

            /// The variant of type `RollbackRetry` in the union `WorldStateErrorUnion`
            RollbackRetry(::planus::alloc::boxed::Box<self::RollbackRetry>),
        }

        impl WorldStateErrorUnion {
            /// Creates a [WorldStateErrorUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorldStateErrorUnionBuilder<::planus::Uninitialized> {
                WorldStateErrorUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_object_not_found(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectNotFound>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_object_already_exists(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectAlreadyExists>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_recursive_move(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RecursiveMove>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_object_permission_denied(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectPermissionDenied>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_property_not_found(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertyNotFound>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_property_permission_denied(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertyPermissionDenied>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_property_definition_not_found(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertyDefinitionNotFound>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_duplicate_property_definition(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DuplicatePropertyDefinition>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_chparent_property_name_conflict(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ChparentPropertyNameConflict>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_property_type_mismatch(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertyTypeMismatch>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_not_found(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbNotFound>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_invalid_verb(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::InvalidVerb>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_decode_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbDecodeError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_permission_denied(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbPermissionDenied>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(14, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_duplicate_verb(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DuplicateVerb>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(15, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_failed_match(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::FailedMatch>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(16, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_ambiguous_match(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::AmbiguousMatch>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(17, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_invalid_renumber(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::InvalidRenumber>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(18, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_world_state_database_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorldStateDatabaseError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(19, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_rollback_retry(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RollbackRetry>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(20, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<WorldStateErrorUnion> for WorldStateErrorUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::ObjectNotFound(value) => Self::create_object_not_found(builder, value),
                    Self::ObjectAlreadyExists(value) => {
                        Self::create_object_already_exists(builder, value)
                    }
                    Self::RecursiveMove(value) => Self::create_recursive_move(builder, value),
                    Self::ObjectPermissionDenied(value) => {
                        Self::create_object_permission_denied(builder, value)
                    }
                    Self::PropertyNotFound(value) => {
                        Self::create_property_not_found(builder, value)
                    }
                    Self::PropertyPermissionDenied(value) => {
                        Self::create_property_permission_denied(builder, value)
                    }
                    Self::PropertyDefinitionNotFound(value) => {
                        Self::create_property_definition_not_found(builder, value)
                    }
                    Self::DuplicatePropertyDefinition(value) => {
                        Self::create_duplicate_property_definition(builder, value)
                    }
                    Self::ChparentPropertyNameConflict(value) => {
                        Self::create_chparent_property_name_conflict(builder, value)
                    }
                    Self::PropertyTypeMismatch(value) => {
                        Self::create_property_type_mismatch(builder, value)
                    }
                    Self::VerbNotFound(value) => Self::create_verb_not_found(builder, value),
                    Self::InvalidVerb(value) => Self::create_invalid_verb(builder, value),
                    Self::VerbDecodeError(value) => Self::create_verb_decode_error(builder, value),
                    Self::VerbPermissionDenied(value) => {
                        Self::create_verb_permission_denied(builder, value)
                    }
                    Self::DuplicateVerb(value) => Self::create_duplicate_verb(builder, value),
                    Self::FailedMatch(value) => Self::create_failed_match(builder, value),
                    Self::AmbiguousMatch(value) => Self::create_ambiguous_match(builder, value),
                    Self::InvalidRenumber(value) => Self::create_invalid_renumber(builder, value),
                    Self::WorldStateDatabaseError(value) => {
                        Self::create_world_state_database_error(builder, value)
                    }
                    Self::RollbackRetry(value) => Self::create_rollback_retry(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<WorldStateErrorUnion> for WorldStateErrorUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [WorldStateErrorUnion] type.
        ///
        /// Can be created using the [WorldStateErrorUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorldStateErrorUnionBuilder<T>(T);

        impl WorldStateErrorUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`ObjectNotFound` variant](WorldStateErrorUnion#variant.ObjectNotFound).
            #[inline]
            pub fn object_not_found<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectNotFound>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ObjectAlreadyExists` variant](WorldStateErrorUnion#variant.ObjectAlreadyExists).
            #[inline]
            pub fn object_already_exists<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectAlreadyExists>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RecursiveMove` variant](WorldStateErrorUnion#variant.RecursiveMove).
            #[inline]
            pub fn recursive_move<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::RecursiveMove>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ObjectPermissionDenied` variant](WorldStateErrorUnion#variant.ObjectPermissionDenied).
            #[inline]
            pub fn object_permission_denied<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectPermissionDenied>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertyNotFound` variant](WorldStateErrorUnion#variant.PropertyNotFound).
            #[inline]
            pub fn property_not_found<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertyNotFound>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertyPermissionDenied` variant](WorldStateErrorUnion#variant.PropertyPermissionDenied).
            #[inline]
            pub fn property_permission_denied<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertyPermissionDenied>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertyDefinitionNotFound` variant](WorldStateErrorUnion#variant.PropertyDefinitionNotFound).
            #[inline]
            pub fn property_definition_not_found<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertyDefinitionNotFound>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DuplicatePropertyDefinition` variant](WorldStateErrorUnion#variant.DuplicatePropertyDefinition).
            #[inline]
            pub fn duplicate_property_definition<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<self::DuplicatePropertyDefinition>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ChparentPropertyNameConflict` variant](WorldStateErrorUnion#variant.ChparentPropertyNameConflict).
            #[inline]
            pub fn chparent_property_name_conflict<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<self::ChparentPropertyNameConflict>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertyTypeMismatch` variant](WorldStateErrorUnion#variant.PropertyTypeMismatch).
            #[inline]
            pub fn property_type_mismatch<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertyTypeMismatch>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbNotFound` variant](WorldStateErrorUnion#variant.VerbNotFound).
            #[inline]
            pub fn verb_not_found<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbNotFound>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`InvalidVerb` variant](WorldStateErrorUnion#variant.InvalidVerb).
            #[inline]
            pub fn invalid_verb<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<self::InvalidVerb>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbDecodeError` variant](WorldStateErrorUnion#variant.VerbDecodeError).
            #[inline]
            pub fn verb_decode_error<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbDecodeError>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbPermissionDenied` variant](WorldStateErrorUnion#variant.VerbPermissionDenied).
            #[inline]
            pub fn verb_permission_denied<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbPermissionDenied>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DuplicateVerb` variant](WorldStateErrorUnion#variant.DuplicateVerb).
            #[inline]
            pub fn duplicate_verb<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<self::DuplicateVerb>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`FailedMatch` variant](WorldStateErrorUnion#variant.FailedMatch).
            #[inline]
            pub fn failed_match<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<16, T>>
            where
                T: ::planus::WriteAsOffset<self::FailedMatch>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`AmbiguousMatch` variant](WorldStateErrorUnion#variant.AmbiguousMatch).
            #[inline]
            pub fn ambiguous_match<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<17, T>>
            where
                T: ::planus::WriteAsOffset<self::AmbiguousMatch>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`InvalidRenumber` variant](WorldStateErrorUnion#variant.InvalidRenumber).
            #[inline]
            pub fn invalid_renumber<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<18, T>>
            where
                T: ::planus::WriteAsOffset<self::InvalidRenumber>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorldStateDatabaseError` variant](WorldStateErrorUnion#variant.WorldStateDatabaseError).
            #[inline]
            pub fn world_state_database_error<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<19, T>>
            where
                T: ::planus::WriteAsOffset<self::WorldStateDatabaseError>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RollbackRetry` variant](WorldStateErrorUnion#variant.RollbackRetry).
            #[inline]
            pub fn rollback_retry<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<20, T>>
            where
                T: ::planus::WriteAsOffset<self::RollbackRetry>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> WorldStateErrorUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [WorldStateErrorUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion>
            where
                Self: ::planus::WriteAsUnion<WorldStateErrorUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectAlreadyExists>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectAlreadyExists>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::RecursiveMove>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::RecursiveMove>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyDefinitionNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyDefinitionNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicatePropertyDefinition>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicatePropertyDefinition>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::ChparentPropertyNameConflict>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::ChparentPropertyNameConflict>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyTypeMismatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyTypeMismatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(11, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidVerb>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(12, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidVerb>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbDecodeError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(13, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbDecodeError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<14, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(14, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<14, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<15, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicateVerb>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(15, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<15, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicateVerb>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<16, T>>
        where
            T: ::planus::WriteAsOffset<self::FailedMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(16, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<16, T>>
        where
            T: ::planus::WriteAsOffset<self::FailedMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<17, T>>
        where
            T: ::planus::WriteAsOffset<self::AmbiguousMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(17, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<17, T>>
        where
            T: ::planus::WriteAsOffset<self::AmbiguousMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<18, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidRenumber>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(18, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<18, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidRenumber>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<19, T>>
        where
            T: ::planus::WriteAsOffset<self::WorldStateDatabaseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(19, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<19, T>>
        where
            T: ::planus::WriteAsOffset<self::WorldStateDatabaseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<20, T>>
        where
            T: ::planus::WriteAsOffset<self::RollbackRetry>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(20, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<20, T>>
        where
            T: ::planus::WriteAsOffset<self::RollbackRetry>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [WorldStateErrorUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum WorldStateErrorUnionRef<'a> {
            ObjectNotFound(self::ObjectNotFoundRef<'a>),
            ObjectAlreadyExists(self::ObjectAlreadyExistsRef<'a>),
            RecursiveMove(self::RecursiveMoveRef<'a>),
            ObjectPermissionDenied(self::ObjectPermissionDeniedRef<'a>),
            PropertyNotFound(self::PropertyNotFoundRef<'a>),
            PropertyPermissionDenied(self::PropertyPermissionDeniedRef<'a>),
            PropertyDefinitionNotFound(self::PropertyDefinitionNotFoundRef<'a>),
            DuplicatePropertyDefinition(self::DuplicatePropertyDefinitionRef<'a>),
            ChparentPropertyNameConflict(self::ChparentPropertyNameConflictRef<'a>),
            PropertyTypeMismatch(self::PropertyTypeMismatchRef<'a>),
            VerbNotFound(self::VerbNotFoundRef<'a>),
            InvalidVerb(self::InvalidVerbRef<'a>),
            VerbDecodeError(self::VerbDecodeErrorRef<'a>),
            VerbPermissionDenied(self::VerbPermissionDeniedRef<'a>),
            DuplicateVerb(self::DuplicateVerbRef<'a>),
            FailedMatch(self::FailedMatchRef<'a>),
            AmbiguousMatch(self::AmbiguousMatchRef<'a>),
            InvalidRenumber(self::InvalidRenumberRef<'a>),
            WorldStateDatabaseError(self::WorldStateDatabaseErrorRef<'a>),
            RollbackRetry(self::RollbackRetryRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<WorldStateErrorUnionRef<'a>> for WorldStateErrorUnion {
            type Error = ::planus::Error;

            fn try_from(value: WorldStateErrorUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    WorldStateErrorUnionRef::ObjectNotFound(value) => {
                        Self::ObjectNotFound(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::ObjectAlreadyExists(value) => {
                        Self::ObjectAlreadyExists(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::RecursiveMove(value) => {
                        Self::RecursiveMove(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::ObjectPermissionDenied(value) => {
                        Self::ObjectPermissionDenied(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::PropertyNotFound(value) => {
                        Self::PropertyNotFound(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::PropertyPermissionDenied(value) => {
                        Self::PropertyPermissionDenied(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::PropertyDefinitionNotFound(value) => {
                        Self::PropertyDefinitionNotFound(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::DuplicatePropertyDefinition(value) => {
                        Self::DuplicatePropertyDefinition(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::ChparentPropertyNameConflict(value) => {
                        Self::ChparentPropertyNameConflict(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::PropertyTypeMismatch(value) => {
                        Self::PropertyTypeMismatch(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::VerbNotFound(value) => {
                        Self::VerbNotFound(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::InvalidVerb(value) => {
                        Self::InvalidVerb(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::VerbDecodeError(value) => {
                        Self::VerbDecodeError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::VerbPermissionDenied(value) => {
                        Self::VerbPermissionDenied(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::DuplicateVerb(value) => {
                        Self::DuplicateVerb(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::FailedMatch(value) => {
                        Self::FailedMatch(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::AmbiguousMatch(value) => {
                        Self::AmbiguousMatch(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::InvalidRenumber(value) => {
                        Self::InvalidRenumber(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::WorldStateDatabaseError(value) => {
                        Self::WorldStateDatabaseError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::RollbackRetry(value) => {
                        Self::RollbackRetry(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for WorldStateErrorUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::ObjectNotFound(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::ObjectAlreadyExists(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::RecursiveMove(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::ObjectPermissionDenied(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::PropertyNotFound(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    6 => ::core::result::Result::Ok(Self::PropertyPermissionDenied(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    7 => ::core::result::Result::Ok(Self::PropertyDefinitionNotFound(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    8 => ::core::result::Result::Ok(Self::DuplicatePropertyDefinition(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    9 => ::core::result::Result::Ok(Self::ChparentPropertyNameConflict(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    10 => ::core::result::Result::Ok(Self::PropertyTypeMismatch(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    11 => ::core::result::Result::Ok(Self::VerbNotFound(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    12 => ::core::result::Result::Ok(Self::InvalidVerb(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    13 => ::core::result::Result::Ok(Self::VerbDecodeError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    14 => ::core::result::Result::Ok(Self::VerbPermissionDenied(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    15 => ::core::result::Result::Ok(Self::DuplicateVerb(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    16 => ::core::result::Result::Ok(Self::FailedMatch(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    17 => ::core::result::Result::Ok(Self::AmbiguousMatch(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    18 => ::core::result::Result::Ok(Self::InvalidRenumber(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    19 => ::core::result::Result::Ok(Self::WorldStateDatabaseError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    20 => ::core::result::Result::Ok(Self::RollbackRetry(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for WorldStateErrorUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[WorldStateErrorUnionRef]";
        }

        /// The table `ObjectNotFound` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ObjectNotFound` in the file `../../../schema/schema/common.fbs:296`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectNotFound {
            /// The field `object_ref` in the table `ObjectNotFound`
            pub object_ref: ::planus::alloc::boxed::Box<self::ObjectRef>,
        }

        impl ObjectNotFound {
            /// Creates a [ObjectNotFoundBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectNotFoundBuilder<()> {
                ObjectNotFoundBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_object_ref: impl ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            ) -> ::planus::Offset<Self> {
                let prepared_object_ref = field_object_ref.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ObjectRef>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_object_ref);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectNotFound>> for ObjectNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectNotFound>> for ObjectNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectNotFound> for ObjectNotFound {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectNotFound> {
                ObjectNotFound::create(builder, &self.object_ref)
            }
        }

        /// Builder for serializing an instance of the [ObjectNotFound] type.
        ///
        /// Can be created using the [ObjectNotFound::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectNotFoundBuilder<State>(State);

        impl ObjectNotFoundBuilder<()> {
            /// Setter for the [`object_ref` field](ObjectNotFound#structfield.object_ref).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn object_ref<T0>(self, value: T0) -> ObjectNotFoundBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            {
                ObjectNotFoundBuilder((value,))
            }
        }

        impl<T0> ObjectNotFoundBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectNotFound].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectNotFound>
            where
                Self: ::planus::WriteAsOffset<ObjectNotFound>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>>
            ::planus::WriteAs<::planus::Offset<ObjectNotFound>> for ObjectNotFoundBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectNotFound>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectNotFound>>
            for ObjectNotFoundBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>>
            ::planus::WriteAsOffset<ObjectNotFound> for ObjectNotFoundBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectNotFound> {
                let (v0,) = &self.0;
                ObjectNotFound::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectNotFound].
        #[derive(Copy, Clone)]
        pub struct ObjectNotFoundRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectNotFoundRef<'a> {
            /// Getter for the [`object_ref` field](ObjectNotFound#structfield.object_ref).
            #[inline]
            pub fn object_ref(&self) -> ::planus::Result<self::ObjectRefRef<'a>> {
                self.0.access_required(0, "ObjectNotFound", "object_ref")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectNotFoundRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectNotFoundRef");
                f.field("object_ref", &self.object_ref());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectNotFoundRef<'a>> for ObjectNotFound {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectNotFoundRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    object_ref: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.object_ref()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectNotFoundRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectNotFoundRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectNotFoundRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectNotFound>> for ObjectNotFound {
            type Value = ::planus::Offset<ObjectNotFound>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectNotFound>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectNotFoundRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectNotFoundRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectAlreadyExists` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ObjectAlreadyExists` in the file `../../../schema/schema/common.fbs:300`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectAlreadyExists {
            /// The field `obj` in the table `ObjectAlreadyExists`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
        }

        impl ObjectAlreadyExists {
            /// Creates a [ObjectAlreadyExistsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectAlreadyExistsBuilder<()> {
                ObjectAlreadyExistsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectAlreadyExists>> for ObjectAlreadyExists {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectAlreadyExists> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectAlreadyExists>> for ObjectAlreadyExists {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectAlreadyExists>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectAlreadyExists> for ObjectAlreadyExists {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectAlreadyExists> {
                ObjectAlreadyExists::create(builder, &self.obj)
            }
        }

        /// Builder for serializing an instance of the [ObjectAlreadyExists] type.
        ///
        /// Can be created using the [ObjectAlreadyExists::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectAlreadyExistsBuilder<State>(State);

        impl ObjectAlreadyExistsBuilder<()> {
            /// Setter for the [`obj` field](ObjectAlreadyExists#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> ObjectAlreadyExistsBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                ObjectAlreadyExistsBuilder((value,))
            }
        }

        impl<T0> ObjectAlreadyExistsBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectAlreadyExists].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectAlreadyExists>
            where
                Self: ::planus::WriteAsOffset<ObjectAlreadyExists>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAs<::planus::Offset<ObjectAlreadyExists>>
            for ObjectAlreadyExistsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectAlreadyExists>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectAlreadyExists> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectAlreadyExists>>
            for ObjectAlreadyExistsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectAlreadyExists>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectAlreadyExists>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAsOffset<ObjectAlreadyExists> for ObjectAlreadyExistsBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectAlreadyExists> {
                let (v0,) = &self.0;
                ObjectAlreadyExists::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectAlreadyExists].
        #[derive(Copy, Clone)]
        pub struct ObjectAlreadyExistsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectAlreadyExistsRef<'a> {
            /// Getter for the [`obj` field](ObjectAlreadyExists#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "ObjectAlreadyExists", "obj")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectAlreadyExistsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectAlreadyExistsRef");
                f.field("obj", &self.obj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectAlreadyExistsRef<'a>> for ObjectAlreadyExists {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectAlreadyExistsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectAlreadyExistsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectAlreadyExistsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectAlreadyExistsRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectAlreadyExists>> for ObjectAlreadyExists {
            type Value = ::planus::Offset<ObjectAlreadyExists>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectAlreadyExists>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectAlreadyExistsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectAlreadyExistsRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `RecursiveMove` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `RecursiveMove` in the file `../../../schema/schema/common.fbs:304`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RecursiveMove {
            /// The field `from_obj` in the table `RecursiveMove`
            pub from_obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `to_obj` in the table `RecursiveMove`
            pub to_obj: ::planus::alloc::boxed::Box<self::Obj>,
        }

        impl RecursiveMove {
            /// Creates a [RecursiveMoveBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RecursiveMoveBuilder<()> {
                RecursiveMoveBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_from_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_to_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_from_obj = field_from_obj.prepare(builder);
                let prepared_to_obj = field_to_obj.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_from_obj);
                        object_writer.write::<_, _, 4>(&prepared_to_obj);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RecursiveMove>> for RecursiveMove {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecursiveMove> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RecursiveMove>> for RecursiveMove {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RecursiveMove>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RecursiveMove> for RecursiveMove {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecursiveMove> {
                RecursiveMove::create(builder, &self.from_obj, &self.to_obj)
            }
        }

        /// Builder for serializing an instance of the [RecursiveMove] type.
        ///
        /// Can be created using the [RecursiveMove::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RecursiveMoveBuilder<State>(State);

        impl RecursiveMoveBuilder<()> {
            /// Setter for the [`from_obj` field](RecursiveMove#structfield.from_obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn from_obj<T0>(self, value: T0) -> RecursiveMoveBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                RecursiveMoveBuilder((value,))
            }
        }

        impl<T0> RecursiveMoveBuilder<(T0,)> {
            /// Setter for the [`to_obj` field](RecursiveMove#structfield.to_obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn to_obj<T1>(self, value: T1) -> RecursiveMoveBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                RecursiveMoveBuilder((v0, value))
            }
        }

        impl<T0, T1> RecursiveMoveBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RecursiveMove].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecursiveMove>
            where
                Self: ::planus::WriteAsOffset<RecursiveMove>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAs<::planus::Offset<RecursiveMove>> for RecursiveMoveBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<RecursiveMove>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecursiveMove> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOptional<::planus::Offset<RecursiveMove>>
            for RecursiveMoveBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<RecursiveMove>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RecursiveMove>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOffset<RecursiveMove> for RecursiveMoveBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecursiveMove> {
                let (v0, v1) = &self.0;
                RecursiveMove::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [RecursiveMove].
        #[derive(Copy, Clone)]
        pub struct RecursiveMoveRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RecursiveMoveRef<'a> {
            /// Getter for the [`from_obj` field](RecursiveMove#structfield.from_obj).
            #[inline]
            pub fn from_obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "RecursiveMove", "from_obj")
            }

            /// Getter for the [`to_obj` field](RecursiveMove#structfield.to_obj).
            #[inline]
            pub fn to_obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "RecursiveMove", "to_obj")
            }
        }

        impl<'a> ::core::fmt::Debug for RecursiveMoveRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RecursiveMoveRef");
                f.field("from_obj", &self.from_obj());
                f.field("to_obj", &self.to_obj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RecursiveMoveRef<'a>> for RecursiveMove {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RecursiveMoveRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    from_obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.from_obj()?,
                    )?),
                    to_obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.to_obj()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RecursiveMoveRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RecursiveMoveRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RecursiveMoveRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RecursiveMove>> for RecursiveMove {
            type Value = ::planus::Offset<RecursiveMove>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RecursiveMove>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RecursiveMoveRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RecursiveMoveRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectPermissionDenied` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ObjectPermissionDenied` in the file `../../../schema/schema/common.fbs:309`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectPermissionDenied {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ObjectPermissionDenied {
            fn default() -> Self {
                Self {}
            }
        }

        impl ObjectPermissionDenied {
            /// Creates a [ObjectPermissionDeniedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectPermissionDeniedBuilder<()> {
                ObjectPermissionDeniedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectPermissionDenied>> for ObjectPermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectPermissionDenied>>
            for ObjectPermissionDenied
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectPermissionDenied> for ObjectPermissionDenied {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectPermissionDenied> {
                ObjectPermissionDenied::create(builder)
            }
        }

        /// Builder for serializing an instance of the [ObjectPermissionDenied] type.
        ///
        /// Can be created using the [ObjectPermissionDenied::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectPermissionDeniedBuilder<State>(State);

        impl ObjectPermissionDeniedBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectPermissionDenied].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectPermissionDenied>
            where
                Self: ::planus::WriteAsOffset<ObjectPermissionDenied>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectPermissionDenied>>
            for ObjectPermissionDeniedBuilder<()>
        {
            type Prepared = ::planus::Offset<ObjectPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectPermissionDenied>>
            for ObjectPermissionDeniedBuilder<()>
        {
            type Prepared = ::planus::Offset<ObjectPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectPermissionDenied> for ObjectPermissionDeniedBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectPermissionDenied> {
                ObjectPermissionDenied::create(builder)
            }
        }

        /// Reference to a deserialized [ObjectPermissionDenied].
        #[derive(Copy, Clone)]
        pub struct ObjectPermissionDeniedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectPermissionDeniedRef<'a> {}

        impl<'a> ::core::fmt::Debug for ObjectPermissionDeniedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectPermissionDeniedRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectPermissionDeniedRef<'a>> for ObjectPermissionDenied {
            type Error = ::planus::Error;

            fn try_from(_value: ObjectPermissionDeniedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectPermissionDeniedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectPermissionDeniedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectPermissionDeniedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectPermissionDenied>>
            for ObjectPermissionDenied
        {
            type Value = ::planus::Offset<ObjectPermissionDenied>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectPermissionDenied>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectPermissionDeniedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectPermissionDeniedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PropertyNotFound` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `PropertyNotFound` in the file `../../../schema/schema/common.fbs:312`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertyNotFound {
            /// The field `obj` in the table `PropertyNotFound`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `property` in the table `PropertyNotFound`
            pub property: ::planus::alloc::string::String,
        }

        impl PropertyNotFound {
            /// Creates a [PropertyNotFoundBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertyNotFoundBuilder<()> {
                PropertyNotFoundBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_property: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_property = field_property.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_property);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyNotFound>> for PropertyNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyNotFound>> for PropertyNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyNotFound> for PropertyNotFound {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyNotFound> {
                PropertyNotFound::create(builder, &self.obj, &self.property)
            }
        }

        /// Builder for serializing an instance of the [PropertyNotFound] type.
        ///
        /// Can be created using the [PropertyNotFound::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertyNotFoundBuilder<State>(State);

        impl PropertyNotFoundBuilder<()> {
            /// Setter for the [`obj` field](PropertyNotFound#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> PropertyNotFoundBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                PropertyNotFoundBuilder((value,))
            }
        }

        impl<T0> PropertyNotFoundBuilder<(T0,)> {
            /// Setter for the [`property` field](PropertyNotFound#structfield.property).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn property<T1>(self, value: T1) -> PropertyNotFoundBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                PropertyNotFoundBuilder((v0, value))
            }
        }

        impl<T0, T1> PropertyNotFoundBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertyNotFound].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyNotFound>
            where
                Self: ::planus::WriteAsOffset<PropertyNotFound>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<PropertyNotFound>>
            for PropertyNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PropertyNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<PropertyNotFound>>
            for PropertyNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PropertyNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<PropertyNotFound> for PropertyNotFoundBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyNotFound> {
                let (v0, v1) = &self.0;
                PropertyNotFound::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [PropertyNotFound].
        #[derive(Copy, Clone)]
        pub struct PropertyNotFoundRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertyNotFoundRef<'a> {
            /// Getter for the [`obj` field](PropertyNotFound#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "PropertyNotFound", "obj")
            }

            /// Getter for the [`property` field](PropertyNotFound#structfield.property).
            #[inline]
            pub fn property(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "PropertyNotFound", "property")
            }
        }

        impl<'a> ::core::fmt::Debug for PropertyNotFoundRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertyNotFoundRef");
                f.field("obj", &self.obj());
                f.field("property", &self.property());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertyNotFoundRef<'a>> for PropertyNotFound {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropertyNotFoundRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    property: ::core::convert::Into::into(value.property()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertyNotFoundRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertyNotFoundRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyNotFoundRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertyNotFound>> for PropertyNotFound {
            type Value = ::planus::Offset<PropertyNotFound>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertyNotFound>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertyNotFoundRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropertyNotFoundRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PropertyPermissionDenied` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `PropertyPermissionDenied` in the file `../../../schema/schema/common.fbs:317`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertyPermissionDenied {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PropertyPermissionDenied {
            fn default() -> Self {
                Self {}
            }
        }

        impl PropertyPermissionDenied {
            /// Creates a [PropertyPermissionDeniedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertyPermissionDeniedBuilder<()> {
                PropertyPermissionDeniedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyPermissionDenied>> for PropertyPermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyPermissionDenied>>
            for PropertyPermissionDenied
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyPermissionDenied> for PropertyPermissionDenied {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyPermissionDenied> {
                PropertyPermissionDenied::create(builder)
            }
        }

        /// Builder for serializing an instance of the [PropertyPermissionDenied] type.
        ///
        /// Can be created using the [PropertyPermissionDenied::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertyPermissionDeniedBuilder<State>(State);

        impl PropertyPermissionDeniedBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertyPermissionDenied].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyPermissionDenied>
            where
                Self: ::planus::WriteAsOffset<PropertyPermissionDenied>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyPermissionDenied>>
            for PropertyPermissionDeniedBuilder<()>
        {
            type Prepared = ::planus::Offset<PropertyPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyPermissionDenied>>
            for PropertyPermissionDeniedBuilder<()>
        {
            type Prepared = ::planus::Offset<PropertyPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyPermissionDenied> for PropertyPermissionDeniedBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyPermissionDenied> {
                PropertyPermissionDenied::create(builder)
            }
        }

        /// Reference to a deserialized [PropertyPermissionDenied].
        #[derive(Copy, Clone)]
        pub struct PropertyPermissionDeniedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertyPermissionDeniedRef<'a> {}

        impl<'a> ::core::fmt::Debug for PropertyPermissionDeniedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertyPermissionDeniedRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertyPermissionDeniedRef<'a>> for PropertyPermissionDenied {
            type Error = ::planus::Error;

            fn try_from(_value: PropertyPermissionDeniedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertyPermissionDeniedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertyPermissionDeniedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyPermissionDeniedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertyPermissionDenied>>
            for PropertyPermissionDenied
        {
            type Value = ::planus::Offset<PropertyPermissionDenied>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertyPermissionDenied>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertyPermissionDeniedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyPermissionDeniedRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `PropertyDefinitionNotFound` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `PropertyDefinitionNotFound` in the file `../../../schema/schema/common.fbs:320`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertyDefinitionNotFound {
            /// The field `obj` in the table `PropertyDefinitionNotFound`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `property` in the table `PropertyDefinitionNotFound`
            pub property: ::planus::alloc::string::String,
        }

        impl PropertyDefinitionNotFound {
            /// Creates a [PropertyDefinitionNotFoundBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertyDefinitionNotFoundBuilder<()> {
                PropertyDefinitionNotFoundBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_property: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_property = field_property.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_property);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyDefinitionNotFound>>
            for PropertyDefinitionNotFound
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyDefinitionNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyDefinitionNotFound>>
            for PropertyDefinitionNotFound
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyDefinitionNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyDefinitionNotFound> for PropertyDefinitionNotFound {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyDefinitionNotFound> {
                PropertyDefinitionNotFound::create(builder, &self.obj, &self.property)
            }
        }

        /// Builder for serializing an instance of the [PropertyDefinitionNotFound] type.
        ///
        /// Can be created using the [PropertyDefinitionNotFound::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertyDefinitionNotFoundBuilder<State>(State);

        impl PropertyDefinitionNotFoundBuilder<()> {
            /// Setter for the [`obj` field](PropertyDefinitionNotFound#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> PropertyDefinitionNotFoundBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                PropertyDefinitionNotFoundBuilder((value,))
            }
        }

        impl<T0> PropertyDefinitionNotFoundBuilder<(T0,)> {
            /// Setter for the [`property` field](PropertyDefinitionNotFound#structfield.property).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn property<T1>(self, value: T1) -> PropertyDefinitionNotFoundBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                PropertyDefinitionNotFoundBuilder((v0, value))
            }
        }

        impl<T0, T1> PropertyDefinitionNotFoundBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertyDefinitionNotFound].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyDefinitionNotFound>
            where
                Self: ::planus::WriteAsOffset<PropertyDefinitionNotFound>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<PropertyDefinitionNotFound>>
            for PropertyDefinitionNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PropertyDefinitionNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyDefinitionNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<PropertyDefinitionNotFound>>
            for PropertyDefinitionNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PropertyDefinitionNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyDefinitionNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<PropertyDefinitionNotFound>
            for PropertyDefinitionNotFoundBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyDefinitionNotFound> {
                let (v0, v1) = &self.0;
                PropertyDefinitionNotFound::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [PropertyDefinitionNotFound].
        #[derive(Copy, Clone)]
        pub struct PropertyDefinitionNotFoundRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertyDefinitionNotFoundRef<'a> {
            /// Getter for the [`obj` field](PropertyDefinitionNotFound#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(0, "PropertyDefinitionNotFound", "obj")
            }

            /// Getter for the [`property` field](PropertyDefinitionNotFound#structfield.property).
            #[inline]
            pub fn property(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(1, "PropertyDefinitionNotFound", "property")
            }
        }

        impl<'a> ::core::fmt::Debug for PropertyDefinitionNotFoundRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertyDefinitionNotFoundRef");
                f.field("obj", &self.obj());
                f.field("property", &self.property());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertyDefinitionNotFoundRef<'a>>
            for PropertyDefinitionNotFound
        {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropertyDefinitionNotFoundRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    property: ::core::convert::Into::into(value.property()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertyDefinitionNotFoundRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertyDefinitionNotFoundRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyDefinitionNotFoundRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertyDefinitionNotFound>>
            for PropertyDefinitionNotFound
        {
            type Value = ::planus::Offset<PropertyDefinitionNotFound>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertyDefinitionNotFound>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertyDefinitionNotFoundRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyDefinitionNotFoundRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `DuplicatePropertyDefinition` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `DuplicatePropertyDefinition` in the file `../../../schema/schema/common.fbs:325`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DuplicatePropertyDefinition {
            /// The field `obj` in the table `DuplicatePropertyDefinition`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `property` in the table `DuplicatePropertyDefinition`
            pub property: ::planus::alloc::string::String,
        }

        impl DuplicatePropertyDefinition {
            /// Creates a [DuplicatePropertyDefinitionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DuplicatePropertyDefinitionBuilder<()> {
                DuplicatePropertyDefinitionBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_property: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_property = field_property.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_property);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DuplicatePropertyDefinition>>
            for DuplicatePropertyDefinition
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicatePropertyDefinition> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DuplicatePropertyDefinition>>
            for DuplicatePropertyDefinition
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicatePropertyDefinition>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DuplicatePropertyDefinition> for DuplicatePropertyDefinition {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicatePropertyDefinition> {
                DuplicatePropertyDefinition::create(builder, &self.obj, &self.property)
            }
        }

        /// Builder for serializing an instance of the [DuplicatePropertyDefinition] type.
        ///
        /// Can be created using the [DuplicatePropertyDefinition::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DuplicatePropertyDefinitionBuilder<State>(State);

        impl DuplicatePropertyDefinitionBuilder<()> {
            /// Setter for the [`obj` field](DuplicatePropertyDefinition#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> DuplicatePropertyDefinitionBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                DuplicatePropertyDefinitionBuilder((value,))
            }
        }

        impl<T0> DuplicatePropertyDefinitionBuilder<(T0,)> {
            /// Setter for the [`property` field](DuplicatePropertyDefinition#structfield.property).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn property<T1>(self, value: T1) -> DuplicatePropertyDefinitionBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                DuplicatePropertyDefinitionBuilder((v0, value))
            }
        }

        impl<T0, T1> DuplicatePropertyDefinitionBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DuplicatePropertyDefinition].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicatePropertyDefinition>
            where
                Self: ::planus::WriteAsOffset<DuplicatePropertyDefinition>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<DuplicatePropertyDefinition>>
            for DuplicatePropertyDefinitionBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicatePropertyDefinition>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicatePropertyDefinition> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<DuplicatePropertyDefinition>>
            for DuplicatePropertyDefinitionBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicatePropertyDefinition>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicatePropertyDefinition>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<DuplicatePropertyDefinition>
            for DuplicatePropertyDefinitionBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicatePropertyDefinition> {
                let (v0, v1) = &self.0;
                DuplicatePropertyDefinition::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [DuplicatePropertyDefinition].
        #[derive(Copy, Clone)]
        pub struct DuplicatePropertyDefinitionRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DuplicatePropertyDefinitionRef<'a> {
            /// Getter for the [`obj` field](DuplicatePropertyDefinition#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(0, "DuplicatePropertyDefinition", "obj")
            }

            /// Getter for the [`property` field](DuplicatePropertyDefinition#structfield.property).
            #[inline]
            pub fn property(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(1, "DuplicatePropertyDefinition", "property")
            }
        }

        impl<'a> ::core::fmt::Debug for DuplicatePropertyDefinitionRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DuplicatePropertyDefinitionRef");
                f.field("obj", &self.obj());
                f.field("property", &self.property());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DuplicatePropertyDefinitionRef<'a>>
            for DuplicatePropertyDefinition
        {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DuplicatePropertyDefinitionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    property: ::core::convert::Into::into(value.property()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DuplicatePropertyDefinitionRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DuplicatePropertyDefinitionRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DuplicatePropertyDefinitionRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DuplicatePropertyDefinition>>
            for DuplicatePropertyDefinition
        {
            type Value = ::planus::Offset<DuplicatePropertyDefinition>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DuplicatePropertyDefinition>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DuplicatePropertyDefinitionRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DuplicatePropertyDefinitionRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `ChparentPropertyNameConflict` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ChparentPropertyNameConflict` in the file `../../../schema/schema/common.fbs:330`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ChparentPropertyNameConflict {
            /// The field `descendant` in the table `ChparentPropertyNameConflict`
            pub descendant: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `ancestor` in the table `ChparentPropertyNameConflict`
            pub ancestor: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `property` in the table `ChparentPropertyNameConflict`
            pub property: ::planus::alloc::string::String,
        }

        impl ChparentPropertyNameConflict {
            /// Creates a [ChparentPropertyNameConflictBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ChparentPropertyNameConflictBuilder<()> {
                ChparentPropertyNameConflictBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_descendant: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_ancestor: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_property: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_descendant = field_descendant.prepare(builder);
                let prepared_ancestor = field_ancestor.prepare(builder);
                let prepared_property = field_property.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);
                table_writer.write_entry::<::planus::Offset<str>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_descendant);
                        object_writer.write::<_, _, 4>(&prepared_ancestor);
                        object_writer.write::<_, _, 4>(&prepared_property);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ChparentPropertyNameConflict>>
            for ChparentPropertyNameConflict
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ChparentPropertyNameConflict> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ChparentPropertyNameConflict>>
            for ChparentPropertyNameConflict
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ChparentPropertyNameConflict>>
            {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ChparentPropertyNameConflict> for ChparentPropertyNameConflict {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ChparentPropertyNameConflict> {
                ChparentPropertyNameConflict::create(
                    builder,
                    &self.descendant,
                    &self.ancestor,
                    &self.property,
                )
            }
        }

        /// Builder for serializing an instance of the [ChparentPropertyNameConflict] type.
        ///
        /// Can be created using the [ChparentPropertyNameConflict::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ChparentPropertyNameConflictBuilder<State>(State);

        impl ChparentPropertyNameConflictBuilder<()> {
            /// Setter for the [`descendant` field](ChparentPropertyNameConflict#structfield.descendant).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn descendant<T0>(self, value: T0) -> ChparentPropertyNameConflictBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                ChparentPropertyNameConflictBuilder((value,))
            }
        }

        impl<T0> ChparentPropertyNameConflictBuilder<(T0,)> {
            /// Setter for the [`ancestor` field](ChparentPropertyNameConflict#structfield.ancestor).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn ancestor<T1>(self, value: T1) -> ChparentPropertyNameConflictBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                ChparentPropertyNameConflictBuilder((v0, value))
            }
        }

        impl<T0, T1> ChparentPropertyNameConflictBuilder<(T0, T1)> {
            /// Setter for the [`property` field](ChparentPropertyNameConflict#structfield.property).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn property<T2>(
                self,
                value: T2,
            ) -> ChparentPropertyNameConflictBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1) = self.0;
                ChparentPropertyNameConflictBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> ChparentPropertyNameConflictBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ChparentPropertyNameConflict].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ChparentPropertyNameConflict>
            where
                Self: ::planus::WriteAsOffset<ChparentPropertyNameConflict>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<ChparentPropertyNameConflict>>
            for ChparentPropertyNameConflictBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<ChparentPropertyNameConflict>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ChparentPropertyNameConflict> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<ChparentPropertyNameConflict>>
            for ChparentPropertyNameConflictBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<ChparentPropertyNameConflict>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ChparentPropertyNameConflict>>
            {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<ChparentPropertyNameConflict>
            for ChparentPropertyNameConflictBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ChparentPropertyNameConflict> {
                let (v0, v1, v2) = &self.0;
                ChparentPropertyNameConflict::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [ChparentPropertyNameConflict].
        #[derive(Copy, Clone)]
        pub struct ChparentPropertyNameConflictRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ChparentPropertyNameConflictRef<'a> {
            /// Getter for the [`descendant` field](ChparentPropertyNameConflict#structfield.descendant).
            #[inline]
            pub fn descendant(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(0, "ChparentPropertyNameConflict", "descendant")
            }

            /// Getter for the [`ancestor` field](ChparentPropertyNameConflict#structfield.ancestor).
            #[inline]
            pub fn ancestor(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(1, "ChparentPropertyNameConflict", "ancestor")
            }

            /// Getter for the [`property` field](ChparentPropertyNameConflict#structfield.property).
            #[inline]
            pub fn property(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(2, "ChparentPropertyNameConflict", "property")
            }
        }

        impl<'a> ::core::fmt::Debug for ChparentPropertyNameConflictRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ChparentPropertyNameConflictRef");
                f.field("descendant", &self.descendant());
                f.field("ancestor", &self.ancestor());
                f.field("property", &self.property());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ChparentPropertyNameConflictRef<'a>>
            for ChparentPropertyNameConflict
        {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ChparentPropertyNameConflictRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    descendant: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.descendant()?)?,
                    ),
                    ancestor: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.ancestor()?,
                    )?),
                    property: ::core::convert::Into::into(value.property()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ChparentPropertyNameConflictRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ChparentPropertyNameConflictRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ChparentPropertyNameConflictRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ChparentPropertyNameConflict>>
            for ChparentPropertyNameConflict
        {
            type Value = ::planus::Offset<ChparentPropertyNameConflict>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ChparentPropertyNameConflict>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ChparentPropertyNameConflictRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ChparentPropertyNameConflictRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `PropertyTypeMismatch` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `PropertyTypeMismatch` in the file `../../../schema/schema/common.fbs:336`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertyTypeMismatch {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PropertyTypeMismatch {
            fn default() -> Self {
                Self {}
            }
        }

        impl PropertyTypeMismatch {
            /// Creates a [PropertyTypeMismatchBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertyTypeMismatchBuilder<()> {
                PropertyTypeMismatchBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyTypeMismatch>> for PropertyTypeMismatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyTypeMismatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyTypeMismatch>> for PropertyTypeMismatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyTypeMismatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyTypeMismatch> for PropertyTypeMismatch {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyTypeMismatch> {
                PropertyTypeMismatch::create(builder)
            }
        }

        /// Builder for serializing an instance of the [PropertyTypeMismatch] type.
        ///
        /// Can be created using the [PropertyTypeMismatch::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertyTypeMismatchBuilder<State>(State);

        impl PropertyTypeMismatchBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertyTypeMismatch].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyTypeMismatch>
            where
                Self: ::planus::WriteAsOffset<PropertyTypeMismatch>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyTypeMismatch>> for PropertyTypeMismatchBuilder<()> {
            type Prepared = ::planus::Offset<PropertyTypeMismatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyTypeMismatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyTypeMismatch>>
            for PropertyTypeMismatchBuilder<()>
        {
            type Prepared = ::planus::Offset<PropertyTypeMismatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyTypeMismatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyTypeMismatch> for PropertyTypeMismatchBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyTypeMismatch> {
                PropertyTypeMismatch::create(builder)
            }
        }

        /// Reference to a deserialized [PropertyTypeMismatch].
        #[derive(Copy, Clone)]
        pub struct PropertyTypeMismatchRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertyTypeMismatchRef<'a> {}

        impl<'a> ::core::fmt::Debug for PropertyTypeMismatchRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertyTypeMismatchRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertyTypeMismatchRef<'a>> for PropertyTypeMismatch {
            type Error = ::planus::Error;

            fn try_from(_value: PropertyTypeMismatchRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertyTypeMismatchRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertyTypeMismatchRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyTypeMismatchRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertyTypeMismatch>> for PropertyTypeMismatch {
            type Value = ::planus::Offset<PropertyTypeMismatch>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertyTypeMismatch>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertyTypeMismatchRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropertyTypeMismatchRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbNotFound` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `VerbNotFound` in the file `../../../schema/schema/common.fbs:339`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbNotFound {
            /// The field `obj` in the table `VerbNotFound`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `verb` in the table `VerbNotFound`
            pub verb: ::planus::alloc::string::String,
        }

        impl VerbNotFound {
            /// Creates a [VerbNotFoundBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbNotFoundBuilder<()> {
                VerbNotFoundBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_verb: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_verb = field_verb.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_verb);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbNotFound>> for VerbNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbNotFound>> for VerbNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbNotFound> for VerbNotFound {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbNotFound> {
                VerbNotFound::create(builder, &self.obj, &self.verb)
            }
        }

        /// Builder for serializing an instance of the [VerbNotFound] type.
        ///
        /// Can be created using the [VerbNotFound::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbNotFoundBuilder<State>(State);

        impl VerbNotFoundBuilder<()> {
            /// Setter for the [`obj` field](VerbNotFound#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> VerbNotFoundBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                VerbNotFoundBuilder((value,))
            }
        }

        impl<T0> VerbNotFoundBuilder<(T0,)> {
            /// Setter for the [`verb` field](VerbNotFound#structfield.verb).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verb<T1>(self, value: T1) -> VerbNotFoundBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                VerbNotFoundBuilder((v0, value))
            }
        }

        impl<T0, T1> VerbNotFoundBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbNotFound].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbNotFound>
            where
                Self: ::planus::WriteAsOffset<VerbNotFound>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<VerbNotFound>> for VerbNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbNotFound>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<VerbNotFound>>
            for VerbNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<VerbNotFound> for VerbNotFoundBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbNotFound> {
                let (v0, v1) = &self.0;
                VerbNotFound::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [VerbNotFound].
        #[derive(Copy, Clone)]
        pub struct VerbNotFoundRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbNotFoundRef<'a> {
            /// Getter for the [`obj` field](VerbNotFound#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "VerbNotFound", "obj")
            }

            /// Getter for the [`verb` field](VerbNotFound#structfield.verb).
            #[inline]
            pub fn verb(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "VerbNotFound", "verb")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbNotFoundRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbNotFoundRef");
                f.field("obj", &self.obj());
                f.field("verb", &self.verb());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbNotFoundRef<'a>> for VerbNotFound {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbNotFoundRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    verb: ::core::convert::Into::into(value.verb()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbNotFoundRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbNotFoundRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbNotFoundRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbNotFound>> for VerbNotFound {
            type Value = ::planus::Offset<VerbNotFound>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbNotFound>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbNotFoundRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbNotFoundRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `InvalidVerb` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `InvalidVerb` in the file `../../../schema/schema/common.fbs:344`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct InvalidVerb {
            /// The field `vid` in the table `InvalidVerb`
            pub vid: i64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for InvalidVerb {
            fn default() -> Self {
                Self { vid: 0 }
            }
        }

        impl InvalidVerb {
            /// Creates a [InvalidVerbBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> InvalidVerbBuilder<()> {
                InvalidVerbBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_vid: impl ::planus::WriteAsDefault<i64, i64>,
            ) -> ::planus::Offset<Self> {
                let prepared_vid = field_vid.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_vid.is_some() {
                    table_writer.write_entry::<i64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_vid) = prepared_vid {
                            object_writer.write::<_, _, 8>(&prepared_vid);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<InvalidVerb>> for InvalidVerb {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvalidVerb> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<InvalidVerb>> for InvalidVerb {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidVerb>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<InvalidVerb> for InvalidVerb {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvalidVerb> {
                InvalidVerb::create(builder, self.vid)
            }
        }

        /// Builder for serializing an instance of the [InvalidVerb] type.
        ///
        /// Can be created using the [InvalidVerb::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct InvalidVerbBuilder<State>(State);

        impl InvalidVerbBuilder<()> {
            /// Setter for the [`vid` field](InvalidVerb#structfield.vid).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn vid<T0>(self, value: T0) -> InvalidVerbBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<i64, i64>,
            {
                InvalidVerbBuilder((value,))
            }

            /// Sets the [`vid` field](InvalidVerb#structfield.vid) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn vid_as_default(self) -> InvalidVerbBuilder<(::planus::DefaultValue,)> {
                self.vid(::planus::DefaultValue)
            }
        }

        impl<T0> InvalidVerbBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [InvalidVerb].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvalidVerb>
            where
                Self: ::planus::WriteAsOffset<InvalidVerb>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i64, i64>>
            ::planus::WriteAs<::planus::Offset<InvalidVerb>> for InvalidVerbBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidVerb>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvalidVerb> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i64, i64>>
            ::planus::WriteAsOptional<::planus::Offset<InvalidVerb>> for InvalidVerbBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidVerb>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidVerb>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<i64, i64>> ::planus::WriteAsOffset<InvalidVerb>
            for InvalidVerbBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvalidVerb> {
                let (v0,) = &self.0;
                InvalidVerb::create(builder, v0)
            }
        }

        /// Reference to a deserialized [InvalidVerb].
        #[derive(Copy, Clone)]
        pub struct InvalidVerbRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> InvalidVerbRef<'a> {
            /// Getter for the [`vid` field](InvalidVerb#structfield.vid).
            #[inline]
            pub fn vid(&self) -> ::planus::Result<i64> {
                ::core::result::Result::Ok(self.0.access(0, "InvalidVerb", "vid")?.unwrap_or(0))
            }
        }

        impl<'a> ::core::fmt::Debug for InvalidVerbRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("InvalidVerbRef");
                f.field("vid", &self.vid());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<InvalidVerbRef<'a>> for InvalidVerb {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: InvalidVerbRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    vid: ::core::convert::TryInto::try_into(value.vid()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for InvalidVerbRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for InvalidVerbRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[InvalidVerbRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<InvalidVerb>> for InvalidVerb {
            type Value = ::planus::Offset<InvalidVerb>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<InvalidVerb>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for InvalidVerbRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[InvalidVerbRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbDecodeError` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `VerbDecodeError` in the file `../../../schema/schema/common.fbs:348`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbDecodeError {
            /// The field `obj` in the table `VerbDecodeError`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `verb` in the table `VerbDecodeError`
            pub verb: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        impl VerbDecodeError {
            /// Creates a [VerbDecodeErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbDecodeErrorBuilder<()> {
                VerbDecodeErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_verb: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_verb = field_verb.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_verb);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbDecodeError>> for VerbDecodeError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDecodeError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbDecodeError>> for VerbDecodeError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbDecodeError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbDecodeError> for VerbDecodeError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDecodeError> {
                VerbDecodeError::create(builder, &self.obj, &self.verb)
            }
        }

        /// Builder for serializing an instance of the [VerbDecodeError] type.
        ///
        /// Can be created using the [VerbDecodeError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbDecodeErrorBuilder<State>(State);

        impl VerbDecodeErrorBuilder<()> {
            /// Setter for the [`obj` field](VerbDecodeError#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> VerbDecodeErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                VerbDecodeErrorBuilder((value,))
            }
        }

        impl<T0> VerbDecodeErrorBuilder<(T0,)> {
            /// Setter for the [`verb` field](VerbDecodeError#structfield.verb).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verb<T1>(self, value: T1) -> VerbDecodeErrorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                VerbDecodeErrorBuilder((v0, value))
            }
        }

        impl<T0, T1> VerbDecodeErrorBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbDecodeError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDecodeError>
            where
                Self: ::planus::WriteAsOffset<VerbDecodeError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<VerbDecodeError>>
            for VerbDecodeErrorBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbDecodeError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDecodeError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<VerbDecodeError>>
            for VerbDecodeErrorBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbDecodeError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbDecodeError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<VerbDecodeError> for VerbDecodeErrorBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDecodeError> {
                let (v0, v1) = &self.0;
                VerbDecodeError::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [VerbDecodeError].
        #[derive(Copy, Clone)]
        pub struct VerbDecodeErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbDecodeErrorRef<'a> {
            /// Getter for the [`obj` field](VerbDecodeError#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "VerbDecodeError", "obj")
            }

            /// Getter for the [`verb` field](VerbDecodeError#structfield.verb).
            #[inline]
            pub fn verb(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(1, "VerbDecodeError", "verb")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbDecodeErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbDecodeErrorRef");
                f.field("obj", &self.obj());
                f.field("verb", &self.verb());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbDecodeErrorRef<'a>> for VerbDecodeError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbDecodeErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    verb: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.verb()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbDecodeErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbDecodeErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbDecodeErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbDecodeError>> for VerbDecodeError {
            type Value = ::planus::Offset<VerbDecodeError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbDecodeError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbDecodeErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbDecodeErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbPermissionDenied` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `VerbPermissionDenied` in the file `../../../schema/schema/common.fbs:353`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbPermissionDenied {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VerbPermissionDenied {
            fn default() -> Self {
                Self {}
            }
        }

        impl VerbPermissionDenied {
            /// Creates a [VerbPermissionDeniedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbPermissionDeniedBuilder<()> {
                VerbPermissionDeniedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbPermissionDenied>> for VerbPermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbPermissionDenied>> for VerbPermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbPermissionDenied> for VerbPermissionDenied {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbPermissionDenied> {
                VerbPermissionDenied::create(builder)
            }
        }

        /// Builder for serializing an instance of the [VerbPermissionDenied] type.
        ///
        /// Can be created using the [VerbPermissionDenied::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbPermissionDeniedBuilder<State>(State);

        impl VerbPermissionDeniedBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbPermissionDenied].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbPermissionDenied>
            where
                Self: ::planus::WriteAsOffset<VerbPermissionDenied>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbPermissionDenied>> for VerbPermissionDeniedBuilder<()> {
            type Prepared = ::planus::Offset<VerbPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbPermissionDenied>>
            for VerbPermissionDeniedBuilder<()>
        {
            type Prepared = ::planus::Offset<VerbPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbPermissionDenied> for VerbPermissionDeniedBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbPermissionDenied> {
                VerbPermissionDenied::create(builder)
            }
        }

        /// Reference to a deserialized [VerbPermissionDenied].
        #[derive(Copy, Clone)]
        pub struct VerbPermissionDeniedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbPermissionDeniedRef<'a> {}

        impl<'a> ::core::fmt::Debug for VerbPermissionDeniedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbPermissionDeniedRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbPermissionDeniedRef<'a>> for VerbPermissionDenied {
            type Error = ::planus::Error;

            fn try_from(_value: VerbPermissionDeniedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbPermissionDeniedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbPermissionDeniedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbPermissionDeniedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbPermissionDenied>> for VerbPermissionDenied {
            type Value = ::planus::Offset<VerbPermissionDenied>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbPermissionDenied>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbPermissionDeniedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbPermissionDeniedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DuplicateVerb` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `DuplicateVerb` in the file `../../../schema/schema/common.fbs:356`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DuplicateVerb {
            /// The field `obj` in the table `DuplicateVerb`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `verb` in the table `DuplicateVerb`
            pub verb: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        impl DuplicateVerb {
            /// Creates a [DuplicateVerbBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DuplicateVerbBuilder<()> {
                DuplicateVerbBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_verb: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_verb = field_verb.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_verb);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DuplicateVerb>> for DuplicateVerb {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DuplicateVerb> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DuplicateVerb>> for DuplicateVerb {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicateVerb>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DuplicateVerb> for DuplicateVerb {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DuplicateVerb> {
                DuplicateVerb::create(builder, &self.obj, &self.verb)
            }
        }

        /// Builder for serializing an instance of the [DuplicateVerb] type.
        ///
        /// Can be created using the [DuplicateVerb::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DuplicateVerbBuilder<State>(State);

        impl DuplicateVerbBuilder<()> {
            /// Setter for the [`obj` field](DuplicateVerb#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> DuplicateVerbBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                DuplicateVerbBuilder((value,))
            }
        }

        impl<T0> DuplicateVerbBuilder<(T0,)> {
            /// Setter for the [`verb` field](DuplicateVerb#structfield.verb).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verb<T1>(self, value: T1) -> DuplicateVerbBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                DuplicateVerbBuilder((v0, value))
            }
        }

        impl<T0, T1> DuplicateVerbBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DuplicateVerb].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<DuplicateVerb>
            where
                Self: ::planus::WriteAsOffset<DuplicateVerb>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<DuplicateVerb>> for DuplicateVerbBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicateVerb>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DuplicateVerb> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<DuplicateVerb>>
            for DuplicateVerbBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicateVerb>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicateVerb>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<DuplicateVerb> for DuplicateVerbBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DuplicateVerb> {
                let (v0, v1) = &self.0;
                DuplicateVerb::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [DuplicateVerb].
        #[derive(Copy, Clone)]
        pub struct DuplicateVerbRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DuplicateVerbRef<'a> {
            /// Getter for the [`obj` field](DuplicateVerb#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "DuplicateVerb", "obj")
            }

            /// Getter for the [`verb` field](DuplicateVerb#structfield.verb).
            #[inline]
            pub fn verb(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(1, "DuplicateVerb", "verb")
            }
        }

        impl<'a> ::core::fmt::Debug for DuplicateVerbRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DuplicateVerbRef");
                f.field("obj", &self.obj());
                f.field("verb", &self.verb());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DuplicateVerbRef<'a>> for DuplicateVerb {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DuplicateVerbRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    verb: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.verb()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DuplicateVerbRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DuplicateVerbRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DuplicateVerbRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DuplicateVerb>> for DuplicateVerb {
            type Value = ::planus::Offset<DuplicateVerb>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DuplicateVerb>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DuplicateVerbRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DuplicateVerbRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `FailedMatch` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `FailedMatch` in the file `../../../schema/schema/common.fbs:361`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct FailedMatch {
            /// The field `match_string` in the table `FailedMatch`
            pub match_string: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for FailedMatch {
            fn default() -> Self {
                Self {
                    match_string: ::core::default::Default::default(),
                }
            }
        }

        impl FailedMatch {
            /// Creates a [FailedMatchBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> FailedMatchBuilder<()> {
                FailedMatchBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_match_string: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_match_string = field_match_string.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_match_string);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<FailedMatch>> for FailedMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FailedMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<FailedMatch>> for FailedMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<FailedMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<FailedMatch> for FailedMatch {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FailedMatch> {
                FailedMatch::create(builder, &self.match_string)
            }
        }

        /// Builder for serializing an instance of the [FailedMatch] type.
        ///
        /// Can be created using the [FailedMatch::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct FailedMatchBuilder<State>(State);

        impl FailedMatchBuilder<()> {
            /// Setter for the [`match_string` field](FailedMatch#structfield.match_string).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn match_string<T0>(self, value: T0) -> FailedMatchBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                FailedMatchBuilder((value,))
            }
        }

        impl<T0> FailedMatchBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [FailedMatch].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<FailedMatch>
            where
                Self: ::planus::WriteAsOffset<FailedMatch>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<FailedMatch>> for FailedMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<FailedMatch>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FailedMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<FailedMatch>> for FailedMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<FailedMatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<FailedMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<FailedMatch>
            for FailedMatchBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FailedMatch> {
                let (v0,) = &self.0;
                FailedMatch::create(builder, v0)
            }
        }

        /// Reference to a deserialized [FailedMatch].
        #[derive(Copy, Clone)]
        pub struct FailedMatchRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> FailedMatchRef<'a> {
            /// Getter for the [`match_string` field](FailedMatch#structfield.match_string).
            #[inline]
            pub fn match_string(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "FailedMatch", "match_string")
            }
        }

        impl<'a> ::core::fmt::Debug for FailedMatchRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("FailedMatchRef");
                f.field("match_string", &self.match_string());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<FailedMatchRef<'a>> for FailedMatch {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: FailedMatchRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    match_string: ::core::convert::Into::into(value.match_string()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for FailedMatchRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for FailedMatchRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[FailedMatchRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<FailedMatch>> for FailedMatch {
            type Value = ::planus::Offset<FailedMatch>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<FailedMatch>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for FailedMatchRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[FailedMatchRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `AmbiguousMatch` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `AmbiguousMatch` in the file `../../../schema/schema/common.fbs:365`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct AmbiguousMatch {
            /// The field `match_string` in the table `AmbiguousMatch`
            pub match_string: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for AmbiguousMatch {
            fn default() -> Self {
                Self {
                    match_string: ::core::default::Default::default(),
                }
            }
        }

        impl AmbiguousMatch {
            /// Creates a [AmbiguousMatchBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AmbiguousMatchBuilder<()> {
                AmbiguousMatchBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_match_string: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_match_string = field_match_string.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_match_string);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<AmbiguousMatch>> for AmbiguousMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AmbiguousMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<AmbiguousMatch>> for AmbiguousMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AmbiguousMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<AmbiguousMatch> for AmbiguousMatch {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AmbiguousMatch> {
                AmbiguousMatch::create(builder, &self.match_string)
            }
        }

        /// Builder for serializing an instance of the [AmbiguousMatch] type.
        ///
        /// Can be created using the [AmbiguousMatch::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AmbiguousMatchBuilder<State>(State);

        impl AmbiguousMatchBuilder<()> {
            /// Setter for the [`match_string` field](AmbiguousMatch#structfield.match_string).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn match_string<T0>(self, value: T0) -> AmbiguousMatchBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                AmbiguousMatchBuilder((value,))
            }
        }

        impl<T0> AmbiguousMatchBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AmbiguousMatch].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<AmbiguousMatch>
            where
                Self: ::planus::WriteAsOffset<AmbiguousMatch>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<AmbiguousMatch>> for AmbiguousMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<AmbiguousMatch>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AmbiguousMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<AmbiguousMatch>>
            for AmbiguousMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<AmbiguousMatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AmbiguousMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<AmbiguousMatch>
            for AmbiguousMatchBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AmbiguousMatch> {
                let (v0,) = &self.0;
                AmbiguousMatch::create(builder, v0)
            }
        }

        /// Reference to a deserialized [AmbiguousMatch].
        #[derive(Copy, Clone)]
        pub struct AmbiguousMatchRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AmbiguousMatchRef<'a> {
            /// Getter for the [`match_string` field](AmbiguousMatch#structfield.match_string).
            #[inline]
            pub fn match_string(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "AmbiguousMatch", "match_string")
            }
        }

        impl<'a> ::core::fmt::Debug for AmbiguousMatchRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AmbiguousMatchRef");
                f.field("match_string", &self.match_string());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AmbiguousMatchRef<'a>> for AmbiguousMatch {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AmbiguousMatchRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    match_string: ::core::convert::Into::into(value.match_string()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AmbiguousMatchRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AmbiguousMatchRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[AmbiguousMatchRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<AmbiguousMatch>> for AmbiguousMatch {
            type Value = ::planus::Offset<AmbiguousMatch>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<AmbiguousMatch>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AmbiguousMatchRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AmbiguousMatchRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `InvalidRenumber` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `InvalidRenumber` in the file `../../../schema/schema/common.fbs:369`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct InvalidRenumber {
            /// The field `message` in the table `InvalidRenumber`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for InvalidRenumber {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl InvalidRenumber {
            /// Creates a [InvalidRenumberBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> InvalidRenumberBuilder<()> {
                InvalidRenumberBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<InvalidRenumber>> for InvalidRenumber {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidRenumber> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<InvalidRenumber>> for InvalidRenumber {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidRenumber>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<InvalidRenumber> for InvalidRenumber {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidRenumber> {
                InvalidRenumber::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [InvalidRenumber] type.
        ///
        /// Can be created using the [InvalidRenumber::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct InvalidRenumberBuilder<State>(State);

        impl InvalidRenumberBuilder<()> {
            /// Setter for the [`message` field](InvalidRenumber#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> InvalidRenumberBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                InvalidRenumberBuilder((value,))
            }
        }

        impl<T0> InvalidRenumberBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [InvalidRenumber].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidRenumber>
            where
                Self: ::planus::WriteAsOffset<InvalidRenumber>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<InvalidRenumber>> for InvalidRenumberBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidRenumber>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidRenumber> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<InvalidRenumber>>
            for InvalidRenumberBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidRenumber>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidRenumber>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<InvalidRenumber>
            for InvalidRenumberBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidRenumber> {
                let (v0,) = &self.0;
                InvalidRenumber::create(builder, v0)
            }
        }

        /// Reference to a deserialized [InvalidRenumber].
        #[derive(Copy, Clone)]
        pub struct InvalidRenumberRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> InvalidRenumberRef<'a> {
            /// Getter for the [`message` field](InvalidRenumber#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "InvalidRenumber", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for InvalidRenumberRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("InvalidRenumberRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<InvalidRenumberRef<'a>> for InvalidRenumber {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: InvalidRenumberRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for InvalidRenumberRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for InvalidRenumberRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[InvalidRenumberRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<InvalidRenumber>> for InvalidRenumber {
            type Value = ::planus::Offset<InvalidRenumber>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<InvalidRenumber>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for InvalidRenumberRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[InvalidRenumberRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorldStateDatabaseError` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `WorldStateDatabaseError` in the file `../../../schema/schema/common.fbs:373`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorldStateDatabaseError {
            /// The field `message` in the table `WorldStateDatabaseError`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorldStateDatabaseError {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl WorldStateDatabaseError {
            /// Creates a [WorldStateDatabaseErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorldStateDatabaseErrorBuilder<()> {
                WorldStateDatabaseErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorldStateDatabaseError>> for WorldStateDatabaseError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateDatabaseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorldStateDatabaseError>>
            for WorldStateDatabaseError
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorldStateDatabaseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorldStateDatabaseError> for WorldStateDatabaseError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateDatabaseError> {
                WorldStateDatabaseError::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [WorldStateDatabaseError] type.
        ///
        /// Can be created using the [WorldStateDatabaseError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorldStateDatabaseErrorBuilder<State>(State);

        impl WorldStateDatabaseErrorBuilder<()> {
            /// Setter for the [`message` field](WorldStateDatabaseError#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> WorldStateDatabaseErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                WorldStateDatabaseErrorBuilder((value,))
            }
        }

        impl<T0> WorldStateDatabaseErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorldStateDatabaseError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateDatabaseError>
            where
                Self: ::planus::WriteAsOffset<WorldStateDatabaseError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<WorldStateDatabaseError>>
            for WorldStateDatabaseErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorldStateDatabaseError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateDatabaseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<WorldStateDatabaseError>>
            for WorldStateDatabaseErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorldStateDatabaseError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorldStateDatabaseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOffset<WorldStateDatabaseError>
            for WorldStateDatabaseErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateDatabaseError> {
                let (v0,) = &self.0;
                WorldStateDatabaseError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorldStateDatabaseError].
        #[derive(Copy, Clone)]
        pub struct WorldStateDatabaseErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorldStateDatabaseErrorRef<'a> {
            /// Getter for the [`message` field](WorldStateDatabaseError#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(0, "WorldStateDatabaseError", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for WorldStateDatabaseErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorldStateDatabaseErrorRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorldStateDatabaseErrorRef<'a>> for WorldStateDatabaseError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorldStateDatabaseErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorldStateDatabaseErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorldStateDatabaseErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorldStateDatabaseErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorldStateDatabaseError>>
            for WorldStateDatabaseError
        {
            type Value = ::planus::Offset<WorldStateDatabaseError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorldStateDatabaseError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorldStateDatabaseErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorldStateDatabaseErrorRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `RollbackRetry` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `RollbackRetry` in the file `../../../schema/schema/common.fbs:377`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RollbackRetry {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for RollbackRetry {
            fn default() -> Self {
                Self {}
            }
        }

        impl RollbackRetry {
            /// Creates a [RollbackRetryBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RollbackRetryBuilder<()> {
                RollbackRetryBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RollbackRetry>> for RollbackRetry {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RollbackRetry> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RollbackRetry>> for RollbackRetry {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RollbackRetry>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RollbackRetry> for RollbackRetry {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RollbackRetry> {
                RollbackRetry::create(builder)
            }
        }

        /// Builder for serializing an instance of the [RollbackRetry] type.
        ///
        /// Can be created using the [RollbackRetry::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RollbackRetryBuilder<State>(State);

        impl RollbackRetryBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RollbackRetry].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RollbackRetry>
            where
                Self: ::planus::WriteAsOffset<RollbackRetry>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RollbackRetry>> for RollbackRetryBuilder<()> {
            type Prepared = ::planus::Offset<RollbackRetry>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RollbackRetry> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RollbackRetry>> for RollbackRetryBuilder<()> {
            type Prepared = ::planus::Offset<RollbackRetry>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RollbackRetry>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RollbackRetry> for RollbackRetryBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RollbackRetry> {
                RollbackRetry::create(builder)
            }
        }

        /// Reference to a deserialized [RollbackRetry].
        #[derive(Copy, Clone)]
        pub struct RollbackRetryRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RollbackRetryRef<'a> {}

        impl<'a> ::core::fmt::Debug for RollbackRetryRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RollbackRetryRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RollbackRetryRef<'a>> for RollbackRetry {
            type Error = ::planus::Error;

            fn try_from(_value: RollbackRetryRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for RollbackRetryRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RollbackRetryRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RollbackRetryRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RollbackRetry>> for RollbackRetry {
            type Value = ::planus::Offset<RollbackRetry>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RollbackRetry>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RollbackRetryRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RollbackRetryRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorldStateError` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `WorldStateError` in the file `../../../schema/schema/common.fbs:380`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorldStateError {
            /// The field `error` in the table `WorldStateError`
            pub error: self::WorldStateErrorUnion,
        }

        impl WorldStateError {
            /// Creates a [WorldStateErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorldStateErrorBuilder<()> {
                WorldStateErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAsUnion<self::WorldStateErrorUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorldStateErrorUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error.offset());
                        object_writer.write::<_, _, 1>(&prepared_error.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorldStateError>> for WorldStateError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorldStateError>> for WorldStateError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorldStateError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorldStateError> for WorldStateError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateError> {
                WorldStateError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [WorldStateError] type.
        ///
        /// Can be created using the [WorldStateError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorldStateErrorBuilder<State>(State);

        impl WorldStateErrorBuilder<()> {
            /// Setter for the [`error` field](WorldStateError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> WorldStateErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::WorldStateErrorUnion>,
            {
                WorldStateErrorBuilder((value,))
            }
        }

        impl<T0> WorldStateErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorldStateError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateError>
            where
                Self: ::planus::WriteAsOffset<WorldStateError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorldStateErrorUnion>>
            ::planus::WriteAs<::planus::Offset<WorldStateError>> for WorldStateErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorldStateError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorldStateErrorUnion>>
            ::planus::WriteAsOptional<::planus::Offset<WorldStateError>>
            for WorldStateErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorldStateError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorldStateError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorldStateErrorUnion>>
            ::planus::WriteAsOffset<WorldStateError> for WorldStateErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateError> {
                let (v0,) = &self.0;
                WorldStateError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorldStateError].
        #[derive(Copy, Clone)]
        pub struct WorldStateErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorldStateErrorRef<'a> {
            /// Getter for the [`error` field](WorldStateError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::WorldStateErrorUnionRef<'a>> {
                self.0.access_union_required(0, "WorldStateError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for WorldStateErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorldStateErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorldStateErrorRef<'a>> for WorldStateError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorldStateErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::core::convert::TryInto::try_into(value.error()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorldStateErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorldStateErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorldStateErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorldStateError>> for WorldStateError {
            type Value = ::planus::Offset<WorldStateError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorldStateError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorldStateErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorldStateErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PropInfo` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `PropInfo` in the file `../../../schema/schema/common.fbs:388`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropInfo {
            /// The field `definer` in the table `PropInfo`
            pub definer: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `location` in the table `PropInfo`
            pub location: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `name` in the table `PropInfo`
            pub name: ::planus::alloc::boxed::Box<self::Symbol>,
            /// The field `owner` in the table `PropInfo`
            pub owner: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `r` in the table `PropInfo`
            pub r: bool,
            /// The field `w` in the table `PropInfo`
            pub w: bool,
            /// The field `chown` in the table `PropInfo`
            pub chown: bool,
        }

        impl PropInfo {
            /// Creates a [PropInfoBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropInfoBuilder<()> {
                PropInfoBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_definer: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_location: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_name: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
                field_owner: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_r: impl ::planus::WriteAsDefault<bool, bool>,
                field_w: impl ::planus::WriteAsDefault<bool, bool>,
                field_chown: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_definer = field_definer.prepare(builder);
                let prepared_location = field_location.prepare(builder);
                let prepared_name = field_name.prepare(builder);
                let prepared_owner = field_owner.prepare(builder);
                let prepared_r = field_r.prepare(builder, &false);
                let prepared_w = field_w.prepare(builder, &false);
                let prepared_chown = field_chown.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<18> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(2);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(3);
                if prepared_r.is_some() {
                    table_writer.write_entry::<bool>(4);
                }
                if prepared_w.is_some() {
                    table_writer.write_entry::<bool>(5);
                }
                if prepared_chown.is_some() {
                    table_writer.write_entry::<bool>(6);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_definer);
                        object_writer.write::<_, _, 4>(&prepared_location);
                        object_writer.write::<_, _, 4>(&prepared_name);
                        object_writer.write::<_, _, 4>(&prepared_owner);
                        if let ::core::option::Option::Some(prepared_r) = prepared_r {
                            object_writer.write::<_, _, 1>(&prepared_r);
                        }
                        if let ::core::option::Option::Some(prepared_w) = prepared_w {
                            object_writer.write::<_, _, 1>(&prepared_w);
                        }
                        if let ::core::option::Option::Some(prepared_chown) = prepared_chown {
                            object_writer.write::<_, _, 1>(&prepared_chown);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropInfo>> for PropInfo {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropInfo> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropInfo>> for PropInfo {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropInfo>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropInfo> for PropInfo {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropInfo> {
                PropInfo::create(
                    builder,
                    &self.definer,
                    &self.location,
                    &self.name,
                    &self.owner,
                    self.r,
                    self.w,
                    self.chown,
                )
            }
        }

        /// Builder for serializing an instance of the [PropInfo] type.
        ///
        /// Can be created using the [PropInfo::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropInfoBuilder<State>(State);

        impl PropInfoBuilder<()> {
            /// Setter for the [`definer` field](PropInfo#structfield.definer).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn definer<T0>(self, value: T0) -> PropInfoBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                PropInfoBuilder((value,))
            }
        }

        impl<T0> PropInfoBuilder<(T0,)> {
            /// Setter for the [`location` field](PropInfo#structfield.location).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn location<T1>(self, value: T1) -> PropInfoBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                PropInfoBuilder((v0, value))
            }
        }

        impl<T0, T1> PropInfoBuilder<(T0, T1)> {
            /// Setter for the [`name` field](PropInfo#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T2>(self, value: T2) -> PropInfoBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0, v1) = self.0;
                PropInfoBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> PropInfoBuilder<(T0, T1, T2)> {
            /// Setter for the [`owner` field](PropInfo#structfield.owner).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn owner<T3>(self, value: T3) -> PropInfoBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1, v2) = self.0;
                PropInfoBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> PropInfoBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`r` field](PropInfo#structfield.r).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn r<T4>(self, value: T4) -> PropInfoBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3) = self.0;
                PropInfoBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`r` field](PropInfo#structfield.r) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn r_as_default(self) -> PropInfoBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.r(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> PropInfoBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`w` field](PropInfo#structfield.w).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn w<T5>(self, value: T5) -> PropInfoBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                PropInfoBuilder((v0, v1, v2, v3, v4, value))
            }

            /// Sets the [`w` field](PropInfo#structfield.w) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn w_as_default(
                self,
            ) -> PropInfoBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                self.w(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5> PropInfoBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Setter for the [`chown` field](PropInfo#structfield.chown).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn chown<T6>(self, value: T6) -> PropInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            where
                T6: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3, v4, v5) = self.0;
                PropInfoBuilder((v0, v1, v2, v3, v4, v5, value))
            }

            /// Sets the [`chown` field](PropInfo#structfield.chown) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn chown_as_default(
                self,
            ) -> PropInfoBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)> {
                self.chown(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6> PropInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropInfo].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropInfo>
            where
                Self: ::planus::WriteAsOffset<PropInfo>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAs<::planus::Offset<PropInfo>>
            for PropInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            type Prepared = ::planus::Offset<PropInfo>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropInfo> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOptional<::planus::Offset<PropInfo>>
            for PropInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            type Prepared = ::planus::Offset<PropInfo>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropInfo>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOffset<PropInfo> for PropInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropInfo> {
                let (v0, v1, v2, v3, v4, v5, v6) = &self.0;
                PropInfo::create(builder, v0, v1, v2, v3, v4, v5, v6)
            }
        }

        /// Reference to a deserialized [PropInfo].
        #[derive(Copy, Clone)]
        pub struct PropInfoRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropInfoRef<'a> {
            /// Getter for the [`definer` field](PropInfo#structfield.definer).
            #[inline]
            pub fn definer(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "PropInfo", "definer")
            }

            /// Getter for the [`location` field](PropInfo#structfield.location).
            #[inline]
            pub fn location(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "PropInfo", "location")
            }

            /// Getter for the [`name` field](PropInfo#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(2, "PropInfo", "name")
            }

            /// Getter for the [`owner` field](PropInfo#structfield.owner).
            #[inline]
            pub fn owner(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(3, "PropInfo", "owner")
            }

            /// Getter for the [`r` field](PropInfo#structfield.r).
            #[inline]
            pub fn r(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(4, "PropInfo", "r")?.unwrap_or(false))
            }

            /// Getter for the [`w` field](PropInfo#structfield.w).
            #[inline]
            pub fn w(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(5, "PropInfo", "w")?.unwrap_or(false))
            }

            /// Getter for the [`chown` field](PropInfo#structfield.chown).
            #[inline]
            pub fn chown(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(6, "PropInfo", "chown")?.unwrap_or(false))
            }
        }

        impl<'a> ::core::fmt::Debug for PropInfoRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropInfoRef");
                f.field("definer", &self.definer());
                f.field("location", &self.location());
                f.field("name", &self.name());
                f.field("owner", &self.owner());
                f.field("r", &self.r());
                f.field("w", &self.w());
                f.field("chown", &self.chown());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropInfoRef<'a>> for PropInfo {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropInfoRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    definer: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.definer()?,
                    )?),
                    location: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.location()?,
                    )?),
                    name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.name()?,
                    )?),
                    owner: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.owner()?,
                    )?),
                    r: ::core::convert::TryInto::try_into(value.r()?)?,
                    w: ::core::convert::TryInto::try_into(value.w()?)?,
                    chown: ::core::convert::TryInto::try_into(value.chown()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropInfoRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropInfoRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[PropInfoRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropInfo>> for PropInfo {
            type Value = ::planus::Offset<PropInfo>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropInfo>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropInfoRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropInfoRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbInfo` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `VerbInfo` in the file `../../../schema/schema/common.fbs:398`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbInfo {
            /// The field `location` in the table `VerbInfo`
            pub location: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `owner` in the table `VerbInfo`
            pub owner: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `names` in the table `VerbInfo`
            pub names: ::planus::alloc::vec::Vec<self::Symbol>,
            /// The field `r` in the table `VerbInfo`
            pub r: bool,
            /// The field `w` in the table `VerbInfo`
            pub w: bool,
            /// The field `x` in the table `VerbInfo`
            pub x: bool,
            /// The field `d` in the table `VerbInfo`
            pub d: bool,
            /// The field `arg_spec` in the table `VerbInfo`
            pub arg_spec: ::planus::alloc::vec::Vec<self::Symbol>,
        }

        impl VerbInfo {
            /// Creates a [VerbInfoBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbInfoBuilder<()> {
                VerbInfoBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_location: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_owner: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_names: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
                field_r: impl ::planus::WriteAsDefault<bool, bool>,
                field_w: impl ::planus::WriteAsDefault<bool, bool>,
                field_x: impl ::planus::WriteAsDefault<bool, bool>,
                field_d: impl ::planus::WriteAsDefault<bool, bool>,
                field_arg_spec: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::Symbol>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_location = field_location.prepare(builder);
                let prepared_owner = field_owner.prepare(builder);
                let prepared_names = field_names.prepare(builder);
                let prepared_r = field_r.prepare(builder, &false);
                let prepared_w = field_w.prepare(builder, &false);
                let prepared_x = field_x.prepare(builder, &false);
                let prepared_d = field_d.prepare(builder, &false);
                let prepared_arg_spec = field_arg_spec.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<20> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Symbol>]>>(2);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Symbol>]>>(7);
                if prepared_r.is_some() {
                    table_writer.write_entry::<bool>(3);
                }
                if prepared_w.is_some() {
                    table_writer.write_entry::<bool>(4);
                }
                if prepared_x.is_some() {
                    table_writer.write_entry::<bool>(5);
                }
                if prepared_d.is_some() {
                    table_writer.write_entry::<bool>(6);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_location);
                        object_writer.write::<_, _, 4>(&prepared_owner);
                        object_writer.write::<_, _, 4>(&prepared_names);
                        object_writer.write::<_, _, 4>(&prepared_arg_spec);
                        if let ::core::option::Option::Some(prepared_r) = prepared_r {
                            object_writer.write::<_, _, 1>(&prepared_r);
                        }
                        if let ::core::option::Option::Some(prepared_w) = prepared_w {
                            object_writer.write::<_, _, 1>(&prepared_w);
                        }
                        if let ::core::option::Option::Some(prepared_x) = prepared_x {
                            object_writer.write::<_, _, 1>(&prepared_x);
                        }
                        if let ::core::option::Option::Some(prepared_d) = prepared_d {
                            object_writer.write::<_, _, 1>(&prepared_d);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbInfo>> for VerbInfo {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbInfo> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbInfo>> for VerbInfo {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbInfo>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbInfo> for VerbInfo {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbInfo> {
                VerbInfo::create(
                    builder,
                    &self.location,
                    &self.owner,
                    &self.names,
                    self.r,
                    self.w,
                    self.x,
                    self.d,
                    &self.arg_spec,
                )
            }
        }

        /// Builder for serializing an instance of the [VerbInfo] type.
        ///
        /// Can be created using the [VerbInfo::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbInfoBuilder<State>(State);

        impl VerbInfoBuilder<()> {
            /// Setter for the [`location` field](VerbInfo#structfield.location).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn location<T0>(self, value: T0) -> VerbInfoBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                VerbInfoBuilder((value,))
            }
        }

        impl<T0> VerbInfoBuilder<(T0,)> {
            /// Setter for the [`owner` field](VerbInfo#structfield.owner).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn owner<T1>(self, value: T1) -> VerbInfoBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                VerbInfoBuilder((v0, value))
            }
        }

        impl<T0, T1> VerbInfoBuilder<(T0, T1)> {
            /// Setter for the [`names` field](VerbInfo#structfield.names).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn names<T2>(self, value: T2) -> VerbInfoBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            {
                let (v0, v1) = self.0;
                VerbInfoBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> VerbInfoBuilder<(T0, T1, T2)> {
            /// Setter for the [`r` field](VerbInfo#structfield.r).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn r<T3>(self, value: T3) -> VerbInfoBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2) = self.0;
                VerbInfoBuilder((v0, v1, v2, value))
            }

            /// Sets the [`r` field](VerbInfo#structfield.r) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn r_as_default(self) -> VerbInfoBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.r(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> VerbInfoBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`w` field](VerbInfo#structfield.w).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn w<T4>(self, value: T4) -> VerbInfoBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3) = self.0;
                VerbInfoBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`w` field](VerbInfo#structfield.w) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn w_as_default(self) -> VerbInfoBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.w(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> VerbInfoBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`x` field](VerbInfo#structfield.x).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn x<T5>(self, value: T5) -> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                VerbInfoBuilder((v0, v1, v2, v3, v4, value))
            }

            /// Sets the [`x` field](VerbInfo#structfield.x) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn x_as_default(
                self,
            ) -> VerbInfoBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                self.x(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Setter for the [`d` field](VerbInfo#structfield.d).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn d<T6>(self, value: T6) -> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            where
                T6: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3, v4, v5) = self.0;
                VerbInfoBuilder((v0, v1, v2, v3, v4, v5, value))
            }

            /// Sets the [`d` field](VerbInfo#structfield.d) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn d_as_default(
                self,
            ) -> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)> {
                self.d(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
            /// Setter for the [`arg_spec` field](VerbInfo#structfield.arg_spec).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn arg_spec<T7>(
                self,
                value: T7,
            ) -> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            where
                T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            {
                let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                VerbInfoBuilder((v0, v1, v2, v3, v4, v5, v6, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbInfo].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbInfo>
            where
                Self: ::planus::WriteAsOffset<VerbInfo>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
            T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
        > ::planus::WriteAs<::planus::Offset<VerbInfo>>
            for VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
        {
            type Prepared = ::planus::Offset<VerbInfo>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbInfo> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
            T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<VerbInfo>>
            for VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
        {
            type Prepared = ::planus::Offset<VerbInfo>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbInfo>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
            T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
        > ::planus::WriteAsOffset<VerbInfo> for VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbInfo> {
                let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                VerbInfo::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
            }
        }

        /// Reference to a deserialized [VerbInfo].
        #[derive(Copy, Clone)]
        pub struct VerbInfoRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbInfoRef<'a> {
            /// Getter for the [`location` field](VerbInfo#structfield.location).
            #[inline]
            pub fn location(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "VerbInfo", "location")
            }

            /// Getter for the [`owner` field](VerbInfo#structfield.owner).
            #[inline]
            pub fn owner(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "VerbInfo", "owner")
            }

            /// Getter for the [`names` field](VerbInfo#structfield.names).
            #[inline]
            pub fn names(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::SymbolRef<'a>>>>
            {
                self.0.access_required(2, "VerbInfo", "names")
            }

            /// Getter for the [`r` field](VerbInfo#structfield.r).
            #[inline]
            pub fn r(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(3, "VerbInfo", "r")?.unwrap_or(false))
            }

            /// Getter for the [`w` field](VerbInfo#structfield.w).
            #[inline]
            pub fn w(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(4, "VerbInfo", "w")?.unwrap_or(false))
            }

            /// Getter for the [`x` field](VerbInfo#structfield.x).
            #[inline]
            pub fn x(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(5, "VerbInfo", "x")?.unwrap_or(false))
            }

            /// Getter for the [`d` field](VerbInfo#structfield.d).
            #[inline]
            pub fn d(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(6, "VerbInfo", "d")?.unwrap_or(false))
            }

            /// Getter for the [`arg_spec` field](VerbInfo#structfield.arg_spec).
            #[inline]
            pub fn arg_spec(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::SymbolRef<'a>>>>
            {
                self.0.access_required(7, "VerbInfo", "arg_spec")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbInfoRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbInfoRef");
                f.field("location", &self.location());
                f.field("owner", &self.owner());
                f.field("names", &self.names());
                f.field("r", &self.r());
                f.field("w", &self.w());
                f.field("x", &self.x());
                f.field("d", &self.d());
                f.field("arg_spec", &self.arg_spec());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbInfoRef<'a>> for VerbInfo {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbInfoRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    location: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.location()?,
                    )?),
                    owner: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.owner()?,
                    )?),
                    names: value.names()?.to_vec_result()?,
                    r: ::core::convert::TryInto::try_into(value.r()?)?,
                    w: ::core::convert::TryInto::try_into(value.w()?)?,
                    x: ::core::convert::TryInto::try_into(value.x()?)?,
                    d: ::core::convert::TryInto::try_into(value.d()?)?,
                    arg_spec: value.arg_spec()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbInfoRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbInfoRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VerbInfoRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbInfo>> for VerbInfo {
            type Value = ::planus::Offset<VerbInfo>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbInfo>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbInfoRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbInfoRef]", "read_as_root", 0)
                })
            }
        }

        /// The enum `ArgSpec` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Enum `ArgSpec` in the file `../../../schema/schema/common.fbs:414`
        #[derive(
            Copy,
            Clone,
            Debug,
            PartialEq,
            Eq,
            PartialOrd,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        #[repr(u8)]
        pub enum ArgSpec {
            /// The variant `None` in the enum `ArgSpec`
            None = 0,

            /// The variant `Any` in the enum `ArgSpec`
            Any = 1,

            /// The variant `This` in the enum `ArgSpec`
            This = 2,
        }

        impl ArgSpec {
            /// Array containing all valid variants of ArgSpec
            pub const ENUM_VALUES: [Self; 3] = [Self::None, Self::Any, Self::This];
        }

        impl ::core::convert::TryFrom<u8> for ArgSpec {
            type Error = ::planus::errors::UnknownEnumTagKind;
            #[inline]
            fn try_from(
                value: u8,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind> {
                #[allow(clippy::match_single_binding)]
                match value {
                    0 => ::core::result::Result::Ok(ArgSpec::None),
                    1 => ::core::result::Result::Ok(ArgSpec::Any),
                    2 => ::core::result::Result::Ok(ArgSpec::This),

                    _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                        tag: value as i128,
                    }),
                }
            }
        }

        impl ::core::convert::From<ArgSpec> for u8 {
            #[inline]
            fn from(value: ArgSpec) -> Self {
                value as u8
            }
        }

        /// # Safety
        /// The Planus compiler correctly calculates `ALIGNMENT` and `SIZE`.
        unsafe impl ::planus::Primitive for ArgSpec {
            const ALIGNMENT: usize = 1;
            const SIZE: usize = 1;
        }

        impl ::planus::WriteAsPrimitive<ArgSpec> for ArgSpec {
            #[inline]
            fn write<const N: usize>(&self, cursor: ::planus::Cursor<'_, N>, buffer_position: u32) {
                (*self as u8).write(cursor, buffer_position);
            }
        }

        impl ::planus::WriteAs<ArgSpec> for ArgSpec {
            type Prepared = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> ArgSpec {
                *self
            }
        }

        impl ::planus::WriteAsDefault<ArgSpec, ArgSpec> for ArgSpec {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
                default: &ArgSpec,
            ) -> ::core::option::Option<ArgSpec> {
                if self == default {
                    ::core::option::Option::None
                } else {
                    ::core::option::Option::Some(*self)
                }
            }
        }

        impl ::planus::WriteAsOptional<ArgSpec> for ArgSpec {
            type Prepared = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> ::core::option::Option<ArgSpec> {
                ::core::option::Option::Some(*self)
            }
        }

        impl<'buf> ::planus::TableRead<'buf> for ArgSpec {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
            }
        }

        impl<'buf> ::planus::VectorReadInner<'buf> for ArgSpec {
            type Error = ::planus::errors::UnknownEnumTag;
            const STRIDE: usize = 1;
            #[inline]
            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag> {
                let value = unsafe { *buffer.buffer.get_unchecked(offset) };
                let value: ::core::result::Result<Self, _> =
                    ::core::convert::TryInto::try_into(value);
                value.map_err(|error_kind| {
                    error_kind.with_error_location(
                        "ArgSpec",
                        "VectorRead::from_buffer",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<ArgSpec> for ArgSpec {
            const STRIDE: usize = 1;

            type Value = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                *self
            }

            #[inline]
            unsafe fn write_values(
                values: &[Self],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - i as u32,
                    );
                }
            }
        }

        /// The table `PrepSpec` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `PrepSpec` in the file `../../../schema/schema/common.fbs:422`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PrepSpec {
            /// The field `value` in the table `PrepSpec`
            pub value: i16,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PrepSpec {
            fn default() -> Self {
                Self { value: 0 }
            }
        }

        impl PrepSpec {
            /// Creates a [PrepSpecBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PrepSpecBuilder<()> {
                PrepSpecBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value: impl ::planus::WriteAsDefault<i16, i16>,
            ) -> ::planus::Offset<Self> {
                let prepared_value = field_value.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_value.is_some() {
                    table_writer.write_entry::<i16>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            object_writer.write::<_, _, 2>(&prepared_value);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PrepSpec>> for PrepSpec {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PrepSpec> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PrepSpec>> for PrepSpec {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PrepSpec>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PrepSpec> for PrepSpec {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PrepSpec> {
                PrepSpec::create(builder, self.value)
            }
        }

        /// Builder for serializing an instance of the [PrepSpec] type.
        ///
        /// Can be created using the [PrepSpec::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PrepSpecBuilder<State>(State);

        impl PrepSpecBuilder<()> {
            /// Setter for the [`value` field](PrepSpec#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T0>(self, value: T0) -> PrepSpecBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<i16, i16>,
            {
                PrepSpecBuilder((value,))
            }

            /// Sets the [`value` field](PrepSpec#structfield.value) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value_as_default(self) -> PrepSpecBuilder<(::planus::DefaultValue,)> {
                self.value(::planus::DefaultValue)
            }
        }

        impl<T0> PrepSpecBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PrepSpec].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PrepSpec>
            where
                Self: ::planus::WriteAsOffset<PrepSpec>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i16, i16>> ::planus::WriteAs<::planus::Offset<PrepSpec>>
            for PrepSpecBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PrepSpec>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PrepSpec> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i16, i16>>
            ::planus::WriteAsOptional<::planus::Offset<PrepSpec>> for PrepSpecBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PrepSpec>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PrepSpec>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<i16, i16>> ::planus::WriteAsOffset<PrepSpec>
            for PrepSpecBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PrepSpec> {
                let (v0,) = &self.0;
                PrepSpec::create(builder, v0)
            }
        }

        /// Reference to a deserialized [PrepSpec].
        #[derive(Copy, Clone)]
        pub struct PrepSpecRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PrepSpecRef<'a> {
            /// Getter for the [`value` field](PrepSpec#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<i16> {
                ::core::result::Result::Ok(self.0.access(0, "PrepSpec", "value")?.unwrap_or(0))
            }
        }

        impl<'a> ::core::fmt::Debug for PrepSpecRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PrepSpecRef");
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PrepSpecRef<'a>> for PrepSpec {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PrepSpecRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value: ::core::convert::TryInto::try_into(value.value()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PrepSpecRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PrepSpecRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[PrepSpecRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PrepSpec>> for PrepSpec {
            type Value = ::planus::Offset<PrepSpec>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PrepSpec>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PrepSpecRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PrepSpecRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbArgsSpec` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `VerbArgsSpec` in the file `../../../schema/schema/common.fbs:428`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbArgsSpec {
            /// The field `dobj` in the table `VerbArgsSpec`
            pub dobj: self::ArgSpec,
            /// The field `prep` in the table `VerbArgsSpec`
            pub prep: i16,
            /// The field `iobj` in the table `VerbArgsSpec`
            pub iobj: self::ArgSpec,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VerbArgsSpec {
            fn default() -> Self {
                Self {
                    dobj: self::ArgSpec::None,
                    prep: 0,
                    iobj: self::ArgSpec::None,
                }
            }
        }

        impl VerbArgsSpec {
            /// Creates a [VerbArgsSpecBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbArgsSpecBuilder<()> {
                VerbArgsSpecBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_dobj: impl ::planus::WriteAsDefault<self::ArgSpec, self::ArgSpec>,
                field_prep: impl ::planus::WriteAsDefault<i16, i16>,
                field_iobj: impl ::planus::WriteAsDefault<self::ArgSpec, self::ArgSpec>,
            ) -> ::planus::Offset<Self> {
                let prepared_dobj = field_dobj.prepare(builder, &self::ArgSpec::None);
                let prepared_prep = field_prep.prepare(builder, &0);
                let prepared_iobj = field_iobj.prepare(builder, &self::ArgSpec::None);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                if prepared_prep.is_some() {
                    table_writer.write_entry::<i16>(1);
                }
                if prepared_dobj.is_some() {
                    table_writer.write_entry::<self::ArgSpec>(0);
                }
                if prepared_iobj.is_some() {
                    table_writer.write_entry::<self::ArgSpec>(2);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_prep) = prepared_prep {
                            object_writer.write::<_, _, 2>(&prepared_prep);
                        }
                        if let ::core::option::Option::Some(prepared_dobj) = prepared_dobj {
                            object_writer.write::<_, _, 1>(&prepared_dobj);
                        }
                        if let ::core::option::Option::Some(prepared_iobj) = prepared_iobj {
                            object_writer.write::<_, _, 1>(&prepared_iobj);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbArgsSpec>> for VerbArgsSpec {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbArgsSpec> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbArgsSpec>> for VerbArgsSpec {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbArgsSpec>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbArgsSpec> for VerbArgsSpec {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbArgsSpec> {
                VerbArgsSpec::create(builder, self.dobj, self.prep, self.iobj)
            }
        }

        /// Builder for serializing an instance of the [VerbArgsSpec] type.
        ///
        /// Can be created using the [VerbArgsSpec::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbArgsSpecBuilder<State>(State);

        impl VerbArgsSpecBuilder<()> {
            /// Setter for the [`dobj` field](VerbArgsSpec#structfield.dobj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn dobj<T0>(self, value: T0) -> VerbArgsSpecBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<self::ArgSpec, self::ArgSpec>,
            {
                VerbArgsSpecBuilder((value,))
            }

            /// Sets the [`dobj` field](VerbArgsSpec#structfield.dobj) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn dobj_as_default(self) -> VerbArgsSpecBuilder<(::planus::DefaultValue,)> {
                self.dobj(::planus::DefaultValue)
            }
        }

        impl<T0> VerbArgsSpecBuilder<(T0,)> {
            /// Setter for the [`prep` field](VerbArgsSpec#structfield.prep).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn prep<T1>(self, value: T1) -> VerbArgsSpecBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<i16, i16>,
            {
                let (v0,) = self.0;
                VerbArgsSpecBuilder((v0, value))
            }

            /// Sets the [`prep` field](VerbArgsSpec#structfield.prep) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn prep_as_default(self) -> VerbArgsSpecBuilder<(T0, ::planus::DefaultValue)> {
                self.prep(::planus::DefaultValue)
            }
        }

        impl<T0, T1> VerbArgsSpecBuilder<(T0, T1)> {
            /// Setter for the [`iobj` field](VerbArgsSpec#structfield.iobj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn iobj<T2>(self, value: T2) -> VerbArgsSpecBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<self::ArgSpec, self::ArgSpec>,
            {
                let (v0, v1) = self.0;
                VerbArgsSpecBuilder((v0, v1, value))
            }

            /// Sets the [`iobj` field](VerbArgsSpec#structfield.iobj) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn iobj_as_default(self) -> VerbArgsSpecBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.iobj(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> VerbArgsSpecBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbArgsSpec].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbArgsSpec>
            where
                Self: ::planus::WriteAsOffset<VerbArgsSpec>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::ArgSpec, self::ArgSpec>,
            T1: ::planus::WriteAsDefault<i16, i16>,
            T2: ::planus::WriteAsDefault<self::ArgSpec, self::ArgSpec>,
        > ::planus::WriteAs<::planus::Offset<VerbArgsSpec>> for VerbArgsSpecBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<VerbArgsSpec>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbArgsSpec> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::ArgSpec, self::ArgSpec>,
            T1: ::planus::WriteAsDefault<i16, i16>,
            T2: ::planus::WriteAsDefault<self::ArgSpec, self::ArgSpec>,
        > ::planus::WriteAsOptional<::planus::Offset<VerbArgsSpec>>
            for VerbArgsSpecBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<VerbArgsSpec>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbArgsSpec>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::ArgSpec, self::ArgSpec>,
            T1: ::planus::WriteAsDefault<i16, i16>,
            T2: ::planus::WriteAsDefault<self::ArgSpec, self::ArgSpec>,
        > ::planus::WriteAsOffset<VerbArgsSpec> for VerbArgsSpecBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbArgsSpec> {
                let (v0, v1, v2) = &self.0;
                VerbArgsSpec::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [VerbArgsSpec].
        #[derive(Copy, Clone)]
        pub struct VerbArgsSpecRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbArgsSpecRef<'a> {
            /// Getter for the [`dobj` field](VerbArgsSpec#structfield.dobj).
            #[inline]
            pub fn dobj(&self) -> ::planus::Result<self::ArgSpec> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "VerbArgsSpec", "dobj")?
                        .unwrap_or(self::ArgSpec::None),
                )
            }

            /// Getter for the [`prep` field](VerbArgsSpec#structfield.prep).
            #[inline]
            pub fn prep(&self) -> ::planus::Result<i16> {
                ::core::result::Result::Ok(self.0.access(1, "VerbArgsSpec", "prep")?.unwrap_or(0))
            }

            /// Getter for the [`iobj` field](VerbArgsSpec#structfield.iobj).
            #[inline]
            pub fn iobj(&self) -> ::planus::Result<self::ArgSpec> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "VerbArgsSpec", "iobj")?
                        .unwrap_or(self::ArgSpec::None),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for VerbArgsSpecRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbArgsSpecRef");
                f.field("dobj", &self.dobj());
                f.field("prep", &self.prep());
                f.field("iobj", &self.iobj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbArgsSpecRef<'a>> for VerbArgsSpec {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbArgsSpecRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    dobj: ::core::convert::TryInto::try_into(value.dobj()?)?,
                    prep: ::core::convert::TryInto::try_into(value.prep()?)?,
                    iobj: ::core::convert::TryInto::try_into(value.iobj()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbArgsSpecRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbArgsSpecRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbArgsSpecRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbArgsSpec>> for VerbArgsSpec {
            type Value = ::planus::Offset<VerbArgsSpec>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbArgsSpec>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbArgsSpecRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbArgsSpecRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbDef` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `VerbDef` in the file `../../../schema/schema/common.fbs:435`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbDef {
            /// The field `uuid` in the table `VerbDef`
            pub uuid: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `location` in the table `VerbDef`
            pub location: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `owner` in the table `VerbDef`
            pub owner: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `names` in the table `VerbDef`
            pub names: ::planus::alloc::vec::Vec<self::Symbol>,
            /// The field `flags` in the table `VerbDef`
            pub flags: u16,
            /// The field `args` in the table `VerbDef`
            pub args: ::planus::alloc::boxed::Box<self::VerbArgsSpec>,
        }

        impl VerbDef {
            /// Creates a [VerbDefBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbDefBuilder<()> {
                VerbDefBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_uuid: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_location: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_owner: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_names: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
                field_flags: impl ::planus::WriteAsDefault<u16, u16>,
                field_args: impl ::planus::WriteAs<::planus::Offset<self::VerbArgsSpec>>,
            ) -> ::planus::Offset<Self> {
                let prepared_uuid = field_uuid.prepare(builder);
                let prepared_location = field_location.prepare(builder);
                let prepared_owner = field_owner.prepare(builder);
                let prepared_names = field_names.prepare(builder);
                let prepared_flags = field_flags.prepare(builder, &0);
                let prepared_args = field_args.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<16> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(2);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Symbol>]>>(3);
                table_writer.write_entry::<::planus::Offset<self::VerbArgsSpec>>(5);
                if prepared_flags.is_some() {
                    table_writer.write_entry::<u16>(4);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_uuid);
                        object_writer.write::<_, _, 4>(&prepared_location);
                        object_writer.write::<_, _, 4>(&prepared_owner);
                        object_writer.write::<_, _, 4>(&prepared_names);
                        object_writer.write::<_, _, 4>(&prepared_args);
                        if let ::core::option::Option::Some(prepared_flags) = prepared_flags {
                            object_writer.write::<_, _, 2>(&prepared_flags);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbDef>> for VerbDef {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbDef> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbDef>> for VerbDef {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbDef>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbDef> for VerbDef {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbDef> {
                VerbDef::create(
                    builder,
                    &self.uuid,
                    &self.location,
                    &self.owner,
                    &self.names,
                    self.flags,
                    &self.args,
                )
            }
        }

        /// Builder for serializing an instance of the [VerbDef] type.
        ///
        /// Can be created using the [VerbDef::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbDefBuilder<State>(State);

        impl VerbDefBuilder<()> {
            /// Setter for the [`uuid` field](VerbDef#structfield.uuid).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn uuid<T0>(self, value: T0) -> VerbDefBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                VerbDefBuilder((value,))
            }
        }

        impl<T0> VerbDefBuilder<(T0,)> {
            /// Setter for the [`location` field](VerbDef#structfield.location).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn location<T1>(self, value: T1) -> VerbDefBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                VerbDefBuilder((v0, value))
            }
        }

        impl<T0, T1> VerbDefBuilder<(T0, T1)> {
            /// Setter for the [`owner` field](VerbDef#structfield.owner).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn owner<T2>(self, value: T2) -> VerbDefBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1) = self.0;
                VerbDefBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> VerbDefBuilder<(T0, T1, T2)> {
            /// Setter for the [`names` field](VerbDef#structfield.names).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn names<T3>(self, value: T3) -> VerbDefBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            {
                let (v0, v1, v2) = self.0;
                VerbDefBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> VerbDefBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`flags` field](VerbDef#structfield.flags).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn flags<T4>(self, value: T4) -> VerbDefBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1, v2, v3) = self.0;
                VerbDefBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`flags` field](VerbDef#structfield.flags) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn flags_as_default(
                self,
            ) -> VerbDefBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.flags(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> VerbDefBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`args` field](VerbDef#structfield.args).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn args<T5>(self, value: T5) -> VerbDefBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAs<::planus::Offset<self::VerbArgsSpec>>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                VerbDefBuilder((v0, v1, v2, v3, v4, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5> VerbDefBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbDef].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbDef>
            where
                Self: ::planus::WriteAsOffset<VerbDef>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T4: ::planus::WriteAsDefault<u16, u16>,
            T5: ::planus::WriteAs<::planus::Offset<self::VerbArgsSpec>>,
        > ::planus::WriteAs<::planus::Offset<VerbDef>>
            for VerbDefBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            type Prepared = ::planus::Offset<VerbDef>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbDef> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T4: ::planus::WriteAsDefault<u16, u16>,
            T5: ::planus::WriteAs<::planus::Offset<self::VerbArgsSpec>>,
        > ::planus::WriteAsOptional<::planus::Offset<VerbDef>>
            for VerbDefBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            type Prepared = ::planus::Offset<VerbDef>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbDef>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T4: ::planus::WriteAsDefault<u16, u16>,
            T5: ::planus::WriteAs<::planus::Offset<self::VerbArgsSpec>>,
        > ::planus::WriteAsOffset<VerbDef> for VerbDefBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbDef> {
                let (v0, v1, v2, v3, v4, v5) = &self.0;
                VerbDef::create(builder, v0, v1, v2, v3, v4, v5)
            }
        }

        /// Reference to a deserialized [VerbDef].
        #[derive(Copy, Clone)]
        pub struct VerbDefRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbDefRef<'a> {
            /// Getter for the [`uuid` field](VerbDef#structfield.uuid).
            #[inline]
            pub fn uuid(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(0, "VerbDef", "uuid")
            }

            /// Getter for the [`location` field](VerbDef#structfield.location).
            #[inline]
            pub fn location(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "VerbDef", "location")
            }

            /// Getter for the [`owner` field](VerbDef#structfield.owner).
            #[inline]
            pub fn owner(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(2, "VerbDef", "owner")
            }

            /// Getter for the [`names` field](VerbDef#structfield.names).
            #[inline]
            pub fn names(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::SymbolRef<'a>>>>
            {
                self.0.access_required(3, "VerbDef", "names")
            }

            /// Getter for the [`flags` field](VerbDef#structfield.flags).
            #[inline]
            pub fn flags(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(self.0.access(4, "VerbDef", "flags")?.unwrap_or(0))
            }

            /// Getter for the [`args` field](VerbDef#structfield.args).
            #[inline]
            pub fn args(&self) -> ::planus::Result<self::VerbArgsSpecRef<'a>> {
                self.0.access_required(5, "VerbDef", "args")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbDefRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbDefRef");
                f.field("uuid", &self.uuid());
                f.field("location", &self.location());
                f.field("owner", &self.owner());
                f.field("names", &self.names());
                f.field("flags", &self.flags());
                f.field("args", &self.args());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbDefRef<'a>> for VerbDef {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbDefRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    uuid: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.uuid()?,
                    )?),
                    location: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.location()?,
                    )?),
                    owner: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.owner()?,
                    )?),
                    names: value.names()?.to_vec_result()?,
                    flags: ::core::convert::TryInto::try_into(value.flags()?)?,
                    args: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.args()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbDefRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbDefRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VerbDefRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbDef>> for VerbDef {
            type Value = ::planus::Offset<VerbDef>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbDef>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbDefRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbDefRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PropDef` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `PropDef` in the file `../../../schema/schema/common.fbs:445`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropDef {
            /// The field `uuid` in the table `PropDef`
            pub uuid: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `definer` in the table `PropDef`
            pub definer: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `location` in the table `PropDef`
            pub location: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `name` in the table `PropDef`
            pub name: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        impl PropDef {
            /// Creates a [PropDefBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropDefBuilder<()> {
                PropDefBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_uuid: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_definer: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_location: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_name: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_uuid = field_uuid.prepare(builder);
                let prepared_definer = field_definer.prepare(builder);
                let prepared_location = field_location.prepare(builder);
                let prepared_name = field_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(2);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(3);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_uuid);
                        object_writer.write::<_, _, 4>(&prepared_definer);
                        object_writer.write::<_, _, 4>(&prepared_location);
                        object_writer.write::<_, _, 4>(&prepared_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropDef>> for PropDef {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropDef> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropDef>> for PropDef {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropDef>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropDef> for PropDef {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropDef> {
                PropDef::create(
                    builder,
                    &self.uuid,
                    &self.definer,
                    &self.location,
                    &self.name,
                )
            }
        }

        /// Builder for serializing an instance of the [PropDef] type.
        ///
        /// Can be created using the [PropDef::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropDefBuilder<State>(State);

        impl PropDefBuilder<()> {
            /// Setter for the [`uuid` field](PropDef#structfield.uuid).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn uuid<T0>(self, value: T0) -> PropDefBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                PropDefBuilder((value,))
            }
        }

        impl<T0> PropDefBuilder<(T0,)> {
            /// Setter for the [`definer` field](PropDef#structfield.definer).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn definer<T1>(self, value: T1) -> PropDefBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                PropDefBuilder((v0, value))
            }
        }

        impl<T0, T1> PropDefBuilder<(T0, T1)> {
            /// Setter for the [`location` field](PropDef#structfield.location).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn location<T2>(self, value: T2) -> PropDefBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1) = self.0;
                PropDefBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> PropDefBuilder<(T0, T1, T2)> {
            /// Setter for the [`name` field](PropDef#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T3>(self, value: T3) -> PropDefBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0, v1, v2) = self.0;
                PropDefBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> PropDefBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropDef].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropDef>
            where
                Self: ::planus::WriteAsOffset<PropDef>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<PropDef>> for PropDefBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<PropDef>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropDef> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<PropDef>>
            for PropDefBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<PropDef>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropDef>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<PropDef> for PropDefBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropDef> {
                let (v0, v1, v2, v3) = &self.0;
                PropDef::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [PropDef].
        #[derive(Copy, Clone)]
        pub struct PropDefRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropDefRef<'a> {
            /// Getter for the [`uuid` field](PropDef#structfield.uuid).
            #[inline]
            pub fn uuid(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(0, "PropDef", "uuid")
            }

            /// Getter for the [`definer` field](PropDef#structfield.definer).
            #[inline]
            pub fn definer(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "PropDef", "definer")
            }

            /// Getter for the [`location` field](PropDef#structfield.location).
            #[inline]
            pub fn location(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(2, "PropDef", "location")
            }

            /// Getter for the [`name` field](PropDef#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(3, "PropDef", "name")
            }
        }

        impl<'a> ::core::fmt::Debug for PropDefRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropDefRef");
                f.field("uuid", &self.uuid());
                f.field("definer", &self.definer());
                f.field("location", &self.location());
                f.field("name", &self.name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropDefRef<'a>> for PropDef {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropDefRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    uuid: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.uuid()?,
                    )?),
                    definer: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.definer()?,
                    )?),
                    location: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.location()?,
                    )?),
                    name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.name()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropDefRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropDefRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[PropDefRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropDef>> for PropDef {
            type Value = ::planus::Offset<PropDef>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropDef>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropDefRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropDefRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbDefs` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `VerbDefs` in the file `../../../schema/schema/common.fbs:453`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbDefs {
            /// The field `verbs` in the table `VerbDefs`
            pub verbs: ::planus::alloc::vec::Vec<self::VerbDef>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VerbDefs {
            fn default() -> Self {
                Self {
                    verbs: ::core::default::Default::default(),
                }
            }
        }

        impl VerbDefs {
            /// Creates a [VerbDefsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbDefsBuilder<()> {
                VerbDefsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_verbs: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VerbDef>]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_verbs = field_verbs.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::VerbDef>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_verbs);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbDefs>> for VerbDefs {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbDefs> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbDefs>> for VerbDefs {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbDefs>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbDefs> for VerbDefs {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbDefs> {
                VerbDefs::create(builder, &self.verbs)
            }
        }

        /// Builder for serializing an instance of the [VerbDefs] type.
        ///
        /// Can be created using the [VerbDefs::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbDefsBuilder<State>(State);

        impl VerbDefsBuilder<()> {
            /// Setter for the [`verbs` field](VerbDefs#structfield.verbs).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verbs<T0>(self, value: T0) -> VerbDefsBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VerbDef>]>>,
            {
                VerbDefsBuilder((value,))
            }
        }

        impl<T0> VerbDefsBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbDefs].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbDefs>
            where
                Self: ::planus::WriteAsOffset<VerbDefs>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VerbDef>]>>>
            ::planus::WriteAs<::planus::Offset<VerbDefs>> for VerbDefsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbDefs>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbDefs> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VerbDef>]>>>
            ::planus::WriteAsOptional<::planus::Offset<VerbDefs>> for VerbDefsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbDefs>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbDefs>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VerbDef>]>>>
            ::planus::WriteAsOffset<VerbDefs> for VerbDefsBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbDefs> {
                let (v0,) = &self.0;
                VerbDefs::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VerbDefs].
        #[derive(Copy, Clone)]
        pub struct VerbDefsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbDefsRef<'a> {
            /// Getter for the [`verbs` field](VerbDefs#structfield.verbs).
            #[inline]
            pub fn verbs(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VerbDefRef<'a>>>>
            {
                self.0.access_required(0, "VerbDefs", "verbs")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbDefsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbDefsRef");
                f.field("verbs", &self.verbs());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbDefsRef<'a>> for VerbDefs {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbDefsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    verbs: value.verbs()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbDefsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbDefsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VerbDefsRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbDefs>> for VerbDefs {
            type Value = ::planus::Offset<VerbDefs>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbDefs>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbDefsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbDefsRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PropDefs` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `PropDefs` in the file `../../../schema/schema/common.fbs:458`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropDefs {
            /// The field `props` in the table `PropDefs`
            pub props: ::planus::alloc::vec::Vec<self::PropDef>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PropDefs {
            fn default() -> Self {
                Self {
                    props: ::core::default::Default::default(),
                }
            }
        }

        impl PropDefs {
            /// Creates a [PropDefsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropDefsBuilder<()> {
                PropDefsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_props: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PropDef>]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_props = field_props.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::PropDef>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_props);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropDefs>> for PropDefs {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropDefs> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropDefs>> for PropDefs {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropDefs>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropDefs> for PropDefs {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropDefs> {
                PropDefs::create(builder, &self.props)
            }
        }

        /// Builder for serializing an instance of the [PropDefs] type.
        ///
        /// Can be created using the [PropDefs::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropDefsBuilder<State>(State);

        impl PropDefsBuilder<()> {
            /// Setter for the [`props` field](PropDefs#structfield.props).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn props<T0>(self, value: T0) -> PropDefsBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PropDef>]>>,
            {
                PropDefsBuilder((value,))
            }
        }

        impl<T0> PropDefsBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropDefs].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropDefs>
            where
                Self: ::planus::WriteAsOffset<PropDefs>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PropDef>]>>>
            ::planus::WriteAs<::planus::Offset<PropDefs>> for PropDefsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PropDefs>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropDefs> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PropDef>]>>>
            ::planus::WriteAsOptional<::planus::Offset<PropDefs>> for PropDefsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PropDefs>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropDefs>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PropDef>]>>>
            ::planus::WriteAsOffset<PropDefs> for PropDefsBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropDefs> {
                let (v0,) = &self.0;
                PropDefs::create(builder, v0)
            }
        }

        /// Reference to a deserialized [PropDefs].
        #[derive(Copy, Clone)]
        pub struct PropDefsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropDefsRef<'a> {
            /// Getter for the [`props` field](PropDefs#structfield.props).
            #[inline]
            pub fn props(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::PropDefRef<'a>>>>
            {
                self.0.access_required(0, "PropDefs", "props")
            }
        }

        impl<'a> ::core::fmt::Debug for PropDefsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropDefsRef");
                f.field("props", &self.props());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropDefsRef<'a>> for PropDefs {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropDefsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    props: value.props()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropDefsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropDefsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[PropDefsRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropDefs>> for PropDefs {
            type Value = ::planus::Offset<PropDefs>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropDefs>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropDefsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropDefsRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjAttrs` in the namespace `MoorCommon`
        ///
        /// Generated from these locations:
        /// * Table `ObjAttrs` in the file `../../../schema/schema/common.fbs:463`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjAttrs {
            /// The field `owner` in the table `ObjAttrs`
            pub owner: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `parent` in the table `ObjAttrs`
            pub parent: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `location` in the table `ObjAttrs`
            pub location: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `flags` in the table `ObjAttrs`
            pub flags: u16,
            /// The field `name` in the table `ObjAttrs`
            pub name: ::core::option::Option<::planus::alloc::string::String>,
        }

        impl ObjAttrs {
            /// Creates a [ObjAttrsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjAttrsBuilder<()> {
                ObjAttrsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_owner: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_parent: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_location: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_flags: impl ::planus::WriteAsDefault<u16, u16>,
                field_name: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_owner = field_owner.prepare(builder);
                let prepared_parent = field_parent.prepare(builder);
                let prepared_location = field_location.prepare(builder);
                let prepared_flags = field_flags.prepare(builder, &0);
                let prepared_name = field_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<14> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(2);
                if prepared_name.is_some() {
                    table_writer.write_entry::<::planus::Offset<str>>(4);
                }
                if prepared_flags.is_some() {
                    table_writer.write_entry::<u16>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_owner);
                        object_writer.write::<_, _, 4>(&prepared_parent);
                        object_writer.write::<_, _, 4>(&prepared_location);
                        if let ::core::option::Option::Some(prepared_name) = prepared_name {
                            object_writer.write::<_, _, 4>(&prepared_name);
                        }
                        if let ::core::option::Option::Some(prepared_flags) = prepared_flags {
                            object_writer.write::<_, _, 2>(&prepared_flags);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjAttrs>> for ObjAttrs {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjAttrs> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjAttrs>> for ObjAttrs {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjAttrs>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjAttrs> for ObjAttrs {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjAttrs> {
                ObjAttrs::create(
                    builder,
                    &self.owner,
                    &self.parent,
                    &self.location,
                    self.flags,
                    &self.name,
                )
            }
        }

        /// Builder for serializing an instance of the [ObjAttrs] type.
        ///
        /// Can be created using the [ObjAttrs::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjAttrsBuilder<State>(State);

        impl ObjAttrsBuilder<()> {
            /// Setter for the [`owner` field](ObjAttrs#structfield.owner).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn owner<T0>(self, value: T0) -> ObjAttrsBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                ObjAttrsBuilder((value,))
            }
        }

        impl<T0> ObjAttrsBuilder<(T0,)> {
            /// Setter for the [`parent` field](ObjAttrs#structfield.parent).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn parent<T1>(self, value: T1) -> ObjAttrsBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                ObjAttrsBuilder((v0, value))
            }
        }

        impl<T0, T1> ObjAttrsBuilder<(T0, T1)> {
            /// Setter for the [`location` field](ObjAttrs#structfield.location).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn location<T2>(self, value: T2) -> ObjAttrsBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1) = self.0;
                ObjAttrsBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> ObjAttrsBuilder<(T0, T1, T2)> {
            /// Setter for the [`flags` field](ObjAttrs#structfield.flags).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn flags<T3>(self, value: T3) -> ObjAttrsBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1, v2) = self.0;
                ObjAttrsBuilder((v0, v1, v2, value))
            }

            /// Sets the [`flags` field](ObjAttrs#structfield.flags) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn flags_as_default(self) -> ObjAttrsBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.flags(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> ObjAttrsBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`name` field](ObjAttrs#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T4>(self, value: T4) -> ObjAttrsBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            {
                let (v0, v1, v2, v3) = self.0;
                ObjAttrsBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`name` field](ObjAttrs#structfield.name) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name_as_null(self) -> ObjAttrsBuilder<(T0, T1, T2, T3, ())> {
                self.name(())
            }
        }

        impl<T0, T1, T2, T3, T4> ObjAttrsBuilder<(T0, T1, T2, T3, T4)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjAttrs].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjAttrs>
            where
                Self: ::planus::WriteAsOffset<ObjAttrs>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAsDefault<u16, u16>,
            T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
        > ::planus::WriteAs<::planus::Offset<ObjAttrs>> for ObjAttrsBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<ObjAttrs>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjAttrs> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAsDefault<u16, u16>,
            T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
        > ::planus::WriteAsOptional<::planus::Offset<ObjAttrs>>
            for ObjAttrsBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<ObjAttrs>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjAttrs>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAsDefault<u16, u16>,
            T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
        > ::planus::WriteAsOffset<ObjAttrs> for ObjAttrsBuilder<(T0, T1, T2, T3, T4)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjAttrs> {
                let (v0, v1, v2, v3, v4) = &self.0;
                ObjAttrs::create(builder, v0, v1, v2, v3, v4)
            }
        }

        /// Reference to a deserialized [ObjAttrs].
        #[derive(Copy, Clone)]
        pub struct ObjAttrsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjAttrsRef<'a> {
            /// Getter for the [`owner` field](ObjAttrs#structfield.owner).
            #[inline]
            pub fn owner(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "ObjAttrs", "owner")
            }

            /// Getter for the [`parent` field](ObjAttrs#structfield.parent).
            #[inline]
            pub fn parent(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "ObjAttrs", "parent")
            }

            /// Getter for the [`location` field](ObjAttrs#structfield.location).
            #[inline]
            pub fn location(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(2, "ObjAttrs", "location")
            }

            /// Getter for the [`flags` field](ObjAttrs#structfield.flags).
            #[inline]
            pub fn flags(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(self.0.access(3, "ObjAttrs", "flags")?.unwrap_or(0))
            }

            /// Getter for the [`name` field](ObjAttrs#structfield.name).
            #[inline]
            pub fn name(
                &self,
            ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>> {
                self.0.access(4, "ObjAttrs", "name")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjAttrsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjAttrsRef");
                f.field("owner", &self.owner());
                f.field("parent", &self.parent());
                f.field("location", &self.location());
                f.field("flags", &self.flags());
                if let ::core::option::Option::Some(field_name) = self.name().transpose() {
                    f.field("name", &field_name);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjAttrsRef<'a>> for ObjAttrs {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjAttrsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    owner: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.owner()?,
                    )?),
                    parent: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.parent()?,
                    )?),
                    location: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.location()?,
                    )?),
                    flags: ::core::convert::TryInto::try_into(value.flags()?)?,
                    name: value.name()?.map(::core::convert::Into::into),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjAttrsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjAttrsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[ObjAttrsRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjAttrs>> for ObjAttrs {
            type Value = ::planus::Offset<ObjAttrs>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjAttrs>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjAttrsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjAttrsRef]", "read_as_root", 0)
                })
            }
        }
    }
    /// The namespace `MoorVar`
    ///
    /// Generated from these locations:
    /// * File `../../../schema/schema/var.fbs`
    pub mod moor_var {
        /// The union `VarUnion` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Union `VarUnion` in the file `../../../schema/schema/var.fbs:27`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub enum VarUnion {
            /// The variant of type `VarNone` in the union `VarUnion`
            VarNone(::planus::alloc::boxed::Box<self::VarNone>),

            /// The variant of type `VarBool` in the union `VarUnion`
            VarBool(::planus::alloc::boxed::Box<self::VarBool>),

            /// The variant of type `VarInt` in the union `VarUnion`
            VarInt(::planus::alloc::boxed::Box<self::VarInt>),

            /// The variant of type `VarFloat` in the union `VarUnion`
            VarFloat(::planus::alloc::boxed::Box<self::VarFloat>),

            /// The variant of type `VarStr` in the union `VarUnion`
            VarStr(::planus::alloc::boxed::Box<self::VarStr>),

            /// The variant of type `VarObj` in the union `VarUnion`
            VarObj(::planus::alloc::boxed::Box<self::VarObj>),

            /// The variant of type `VarErr` in the union `VarUnion`
            VarErr(::planus::alloc::boxed::Box<self::VarErr>),

            /// The variant of type `VarList` in the union `VarUnion`
            VarList(::planus::alloc::boxed::Box<self::VarList>),

            /// The variant of type `VarMap` in the union `VarUnion`
            VarMap(::planus::alloc::boxed::Box<self::VarMap>),

            /// The variant of type `VarSym` in the union `VarUnion`
            VarSym(::planus::alloc::boxed::Box<self::VarSym>),

            /// The variant of type `VarBinary` in the union `VarUnion`
            VarBinary(::planus::alloc::boxed::Box<self::VarBinary>),

            /// The variant of type `VarFlyweight` in the union `VarUnion`
            VarFlyweight(::planus::alloc::boxed::Box<self::VarFlyweight>),

            /// The variant of type `VarLambda` in the union `VarUnion`
            VarLambda(::planus::alloc::boxed::Box<self::VarLambda>),
        }

        impl VarUnion {
            /// Creates a [VarUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarUnionBuilder<::planus::Uninitialized> {
                VarUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_var_none(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarNone>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_bool(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarBool>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_int(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarInt>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_float(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarFloat>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_str(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarStr>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_obj(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarObj>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_err(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarErr>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_list(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarList>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_map(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarMap>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_sym(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarSym>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_binary(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarBinary>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_flyweight(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarFlyweight>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_var_lambda(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VarLambda>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<VarUnion> for VarUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::VarNone(value) => Self::create_var_none(builder, value),
                    Self::VarBool(value) => Self::create_var_bool(builder, value),
                    Self::VarInt(value) => Self::create_var_int(builder, value),
                    Self::VarFloat(value) => Self::create_var_float(builder, value),
                    Self::VarStr(value) => Self::create_var_str(builder, value),
                    Self::VarObj(value) => Self::create_var_obj(builder, value),
                    Self::VarErr(value) => Self::create_var_err(builder, value),
                    Self::VarList(value) => Self::create_var_list(builder, value),
                    Self::VarMap(value) => Self::create_var_map(builder, value),
                    Self::VarSym(value) => Self::create_var_sym(builder, value),
                    Self::VarBinary(value) => Self::create_var_binary(builder, value),
                    Self::VarFlyweight(value) => Self::create_var_flyweight(builder, value),
                    Self::VarLambda(value) => Self::create_var_lambda(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<VarUnion> for VarUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [VarUnion] type.
        ///
        /// Can be created using the [VarUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarUnionBuilder<T>(T);

        impl VarUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`VarNone` variant](VarUnion#variant.VarNone).
            #[inline]
            pub fn var_none<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::VarNone>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarBool` variant](VarUnion#variant.VarBool).
            #[inline]
            pub fn var_bool<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::VarBool>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarInt` variant](VarUnion#variant.VarInt).
            #[inline]
            pub fn var_int<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::VarInt>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarFloat` variant](VarUnion#variant.VarFloat).
            #[inline]
            pub fn var_float<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::VarFloat>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarStr` variant](VarUnion#variant.VarStr).
            #[inline]
            pub fn var_str<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::VarStr>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarObj` variant](VarUnion#variant.VarObj).
            #[inline]
            pub fn var_obj<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::VarObj>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarErr` variant](VarUnion#variant.VarErr).
            #[inline]
            pub fn var_err<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<self::VarErr>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarList` variant](VarUnion#variant.VarList).
            #[inline]
            pub fn var_list<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<self::VarList>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarMap` variant](VarUnion#variant.VarMap).
            #[inline]
            pub fn var_map<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<self::VarMap>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarSym` variant](VarUnion#variant.VarSym).
            #[inline]
            pub fn var_sym<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<self::VarSym>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarBinary` variant](VarUnion#variant.VarBinary).
            #[inline]
            pub fn var_binary<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<self::VarBinary>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarFlyweight` variant](VarUnion#variant.VarFlyweight).
            #[inline]
            pub fn var_flyweight<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<self::VarFlyweight>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VarLambda` variant](VarUnion#variant.VarLambda).
            #[inline]
            pub fn var_lambda<T>(self, value: T) -> VarUnionBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<self::VarLambda>,
            {
                VarUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> VarUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [VarUnion].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion>
            where
                Self: ::planus::WriteAsUnion<VarUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::VarNone>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::VarNone>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::VarBool>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::VarBool>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::VarInt>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::VarInt>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::VarFloat>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::VarFloat>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::VarStr>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::VarStr>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::VarObj>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::VarObj>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::VarErr>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::VarErr>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::VarList>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::VarList>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::VarMap>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::VarMap>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::VarSym>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::VarSym>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::VarBinary>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(11, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::VarBinary>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::VarFlyweight>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(12, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::VarFlyweight>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::VarLambda>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<VarUnion> {
                ::planus::UnionOffset::new(13, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VarUnion> for VarUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::VarLambda>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VarUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [VarUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum VarUnionRef<'a> {
            VarNone(self::VarNoneRef<'a>),
            VarBool(self::VarBoolRef<'a>),
            VarInt(self::VarIntRef<'a>),
            VarFloat(self::VarFloatRef<'a>),
            VarStr(self::VarStrRef<'a>),
            VarObj(self::VarObjRef<'a>),
            VarErr(self::VarErrRef<'a>),
            VarList(self::VarListRef<'a>),
            VarMap(self::VarMapRef<'a>),
            VarSym(self::VarSymRef<'a>),
            VarBinary(self::VarBinaryRef<'a>),
            VarFlyweight(self::VarFlyweightRef<'a>),
            VarLambda(self::VarLambdaRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<VarUnionRef<'a>> for VarUnion {
            type Error = ::planus::Error;

            fn try_from(value: VarUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    VarUnionRef::VarNone(value) => Self::VarNone(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    VarUnionRef::VarBool(value) => Self::VarBool(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    VarUnionRef::VarInt(value) => Self::VarInt(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    VarUnionRef::VarFloat(value) => {
                        Self::VarFloat(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    VarUnionRef::VarStr(value) => Self::VarStr(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    VarUnionRef::VarObj(value) => Self::VarObj(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    VarUnionRef::VarErr(value) => Self::VarErr(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    VarUnionRef::VarList(value) => Self::VarList(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    VarUnionRef::VarMap(value) => Self::VarMap(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    VarUnionRef::VarSym(value) => Self::VarSym(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    VarUnionRef::VarBinary(value) => {
                        Self::VarBinary(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    VarUnionRef::VarFlyweight(value) => {
                        Self::VarFlyweight(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    VarUnionRef::VarLambda(value) => {
                        Self::VarLambda(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for VarUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::VarNone(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::VarBool(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::VarInt(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::VarFloat(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::VarStr(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    6 => ::core::result::Result::Ok(Self::VarObj(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    7 => ::core::result::Result::Ok(Self::VarErr(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    8 => ::core::result::Result::Ok(Self::VarList(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    9 => ::core::result::Result::Ok(Self::VarMap(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    10 => ::core::result::Result::Ok(Self::VarSym(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    11 => ::core::result::Result::Ok(Self::VarBinary(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    12 => ::core::result::Result::Ok(Self::VarFlyweight(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    13 => ::core::result::Result::Ok(Self::VarLambda(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for VarUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[VarUnionRef]";
        }

        /// The table `VarNone` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarNone` in the file `../../../schema/schema/var.fbs:45`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VarNone {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarNone {
            fn default() -> Self {
                Self {}
            }
        }

        impl VarNone {
            /// Creates a [VarNoneBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarNoneBuilder<()> {
                VarNoneBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarNone>> for VarNone {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarNone> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarNone>> for VarNone {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarNone>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarNone> for VarNone {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarNone> {
                VarNone::create(builder)
            }
        }

        /// Builder for serializing an instance of the [VarNone] type.
        ///
        /// Can be created using the [VarNone::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarNoneBuilder<State>(State);

        impl VarNoneBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarNone].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarNone>
            where
                Self: ::planus::WriteAsOffset<VarNone>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarNone>> for VarNoneBuilder<()> {
            type Prepared = ::planus::Offset<VarNone>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarNone> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarNone>> for VarNoneBuilder<()> {
            type Prepared = ::planus::Offset<VarNone>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarNone>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarNone> for VarNoneBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarNone> {
                VarNone::create(builder)
            }
        }

        /// Reference to a deserialized [VarNone].
        #[derive(Copy, Clone)]
        pub struct VarNoneRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarNoneRef<'a> {}

        impl<'a> ::core::fmt::Debug for VarNoneRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarNoneRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarNoneRef<'a>> for VarNone {
            type Error = ::planus::Error;

            fn try_from(_value: VarNoneRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarNoneRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarNoneRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarNoneRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarNone>> for VarNone {
            type Value = ::planus::Offset<VarNone>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarNone>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarNoneRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarNoneRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarBool` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarBool` in the file `../../../schema/schema/var.fbs:48`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VarBool {
            /// The field `value` in the table `VarBool`
            pub value: bool,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarBool {
            fn default() -> Self {
                Self { value: false }
            }
        }

        impl VarBool {
            /// Creates a [VarBoolBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarBoolBuilder<()> {
                VarBoolBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_value = field_value.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_value.is_some() {
                    table_writer.write_entry::<bool>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            object_writer.write::<_, _, 1>(&prepared_value);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarBool>> for VarBool {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBool> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarBool>> for VarBool {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarBool>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarBool> for VarBool {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBool> {
                VarBool::create(builder, self.value)
            }
        }

        /// Builder for serializing an instance of the [VarBool] type.
        ///
        /// Can be created using the [VarBool::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarBoolBuilder<State>(State);

        impl VarBoolBuilder<()> {
            /// Setter for the [`value` field](VarBool#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T0>(self, value: T0) -> VarBoolBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<bool, bool>,
            {
                VarBoolBuilder((value,))
            }

            /// Sets the [`value` field](VarBool#structfield.value) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value_as_default(self) -> VarBoolBuilder<(::planus::DefaultValue,)> {
                self.value(::planus::DefaultValue)
            }
        }

        impl<T0> VarBoolBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarBool].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBool>
            where
                Self: ::planus::WriteAsOffset<VarBool>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<bool, bool>> ::planus::WriteAs<::planus::Offset<VarBool>>
            for VarBoolBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarBool>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBool> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<bool, bool>>
            ::planus::WriteAsOptional<::planus::Offset<VarBool>> for VarBoolBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarBool>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarBool>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<bool, bool>> ::planus::WriteAsOffset<VarBool>
            for VarBoolBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBool> {
                let (v0,) = &self.0;
                VarBool::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarBool].
        #[derive(Copy, Clone)]
        pub struct VarBoolRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarBoolRef<'a> {
            /// Getter for the [`value` field](VarBool#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(0, "VarBool", "value")?.unwrap_or(false))
            }
        }

        impl<'a> ::core::fmt::Debug for VarBoolRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarBoolRef");
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarBoolRef<'a>> for VarBool {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarBoolRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value: ::core::convert::TryInto::try_into(value.value()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarBoolRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarBoolRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarBoolRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarBool>> for VarBool {
            type Value = ::planus::Offset<VarBool>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarBool>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarBoolRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarBoolRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarInt` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarInt` in the file `../../../schema/schema/var.fbs:52`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VarInt {
            /// The field `value` in the table `VarInt`
            pub value: i64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarInt {
            fn default() -> Self {
                Self { value: 0 }
            }
        }

        impl VarInt {
            /// Creates a [VarIntBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarIntBuilder<()> {
                VarIntBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value: impl ::planus::WriteAsDefault<i64, i64>,
            ) -> ::planus::Offset<Self> {
                let prepared_value = field_value.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_value.is_some() {
                    table_writer.write_entry::<i64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            object_writer.write::<_, _, 8>(&prepared_value);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarInt>> for VarInt {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarInt> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarInt>> for VarInt {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarInt>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarInt> for VarInt {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarInt> {
                VarInt::create(builder, self.value)
            }
        }

        /// Builder for serializing an instance of the [VarInt] type.
        ///
        /// Can be created using the [VarInt::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarIntBuilder<State>(State);

        impl VarIntBuilder<()> {
            /// Setter for the [`value` field](VarInt#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T0>(self, value: T0) -> VarIntBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<i64, i64>,
            {
                VarIntBuilder((value,))
            }

            /// Sets the [`value` field](VarInt#structfield.value) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value_as_default(self) -> VarIntBuilder<(::planus::DefaultValue,)> {
                self.value(::planus::DefaultValue)
            }
        }

        impl<T0> VarIntBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarInt].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarInt>
            where
                Self: ::planus::WriteAsOffset<VarInt>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i64, i64>> ::planus::WriteAs<::planus::Offset<VarInt>>
            for VarIntBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarInt>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarInt> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i64, i64>>
            ::planus::WriteAsOptional<::planus::Offset<VarInt>> for VarIntBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarInt>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarInt>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<i64, i64>> ::planus::WriteAsOffset<VarInt>
            for VarIntBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarInt> {
                let (v0,) = &self.0;
                VarInt::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarInt].
        #[derive(Copy, Clone)]
        pub struct VarIntRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarIntRef<'a> {
            /// Getter for the [`value` field](VarInt#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<i64> {
                ::core::result::Result::Ok(self.0.access(0, "VarInt", "value")?.unwrap_or(0))
            }
        }

        impl<'a> ::core::fmt::Debug for VarIntRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarIntRef");
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarIntRef<'a>> for VarInt {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarIntRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value: ::core::convert::TryInto::try_into(value.value()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarIntRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarIntRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarIntRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarInt>> for VarInt {
            type Value = ::planus::Offset<VarInt>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarInt>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarIntRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarIntRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarFloat` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarFloat` in the file `../../../schema/schema/var.fbs:56`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct VarFloat {
            /// The field `value` in the table `VarFloat`
            pub value: f64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarFloat {
            fn default() -> Self {
                Self { value: 0.0 }
            }
        }

        impl VarFloat {
            /// Creates a [VarFloatBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarFloatBuilder<()> {
                VarFloatBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value: impl ::planus::WriteAsDefault<f64, f64>,
            ) -> ::planus::Offset<Self> {
                let prepared_value = field_value.prepare(builder, &0.0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_value.is_some() {
                    table_writer.write_entry::<f64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            object_writer.write::<_, _, 8>(&prepared_value);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarFloat>> for VarFloat {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarFloat> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarFloat>> for VarFloat {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarFloat>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarFloat> for VarFloat {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarFloat> {
                VarFloat::create(builder, self.value)
            }
        }

        /// Builder for serializing an instance of the [VarFloat] type.
        ///
        /// Can be created using the [VarFloat::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarFloatBuilder<State>(State);

        impl VarFloatBuilder<()> {
            /// Setter for the [`value` field](VarFloat#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T0>(self, value: T0) -> VarFloatBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<f64, f64>,
            {
                VarFloatBuilder((value,))
            }

            /// Sets the [`value` field](VarFloat#structfield.value) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value_as_default(self) -> VarFloatBuilder<(::planus::DefaultValue,)> {
                self.value(::planus::DefaultValue)
            }
        }

        impl<T0> VarFloatBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarFloat].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarFloat>
            where
                Self: ::planus::WriteAsOffset<VarFloat>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<f64, f64>> ::planus::WriteAs<::planus::Offset<VarFloat>>
            for VarFloatBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarFloat>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarFloat> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<f64, f64>>
            ::planus::WriteAsOptional<::planus::Offset<VarFloat>> for VarFloatBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarFloat>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarFloat>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<f64, f64>> ::planus::WriteAsOffset<VarFloat>
            for VarFloatBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarFloat> {
                let (v0,) = &self.0;
                VarFloat::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarFloat].
        #[derive(Copy, Clone)]
        pub struct VarFloatRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarFloatRef<'a> {
            /// Getter for the [`value` field](VarFloat#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<f64> {
                ::core::result::Result::Ok(self.0.access(0, "VarFloat", "value")?.unwrap_or(0.0))
            }
        }

        impl<'a> ::core::fmt::Debug for VarFloatRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarFloatRef");
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarFloatRef<'a>> for VarFloat {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarFloatRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value: ::core::convert::TryInto::try_into(value.value()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarFloatRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarFloatRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarFloatRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarFloat>> for VarFloat {
            type Value = ::planus::Offset<VarFloat>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarFloat>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarFloatRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarFloatRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarStr` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarStr` in the file `../../../schema/schema/var.fbs:60`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VarStr {
            /// The field `value` in the table `VarStr`
            pub value: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarStr {
            fn default() -> Self {
                Self {
                    value: ::core::default::Default::default(),
                }
            }
        }

        impl VarStr {
            /// Creates a [VarStrBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarStrBuilder<()> {
                VarStrBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarStr>> for VarStr {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarStr> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarStr>> for VarStr {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarStr>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarStr> for VarStr {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarStr> {
                VarStr::create(builder, &self.value)
            }
        }

        /// Builder for serializing an instance of the [VarStr] type.
        ///
        /// Can be created using the [VarStr::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarStrBuilder<State>(State);

        impl VarStrBuilder<()> {
            /// Setter for the [`value` field](VarStr#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T0>(self, value: T0) -> VarStrBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                VarStrBuilder((value,))
            }
        }

        impl<T0> VarStrBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarStr].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarStr>
            where
                Self: ::planus::WriteAsOffset<VarStr>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<VarStr>> for VarStrBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarStr>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarStr> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<VarStr>> for VarStrBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarStr>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarStr>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<VarStr>
            for VarStrBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarStr> {
                let (v0,) = &self.0;
                VarStr::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarStr].
        #[derive(Copy, Clone)]
        pub struct VarStrRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarStrRef<'a> {
            /// Getter for the [`value` field](VarStr#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "VarStr", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for VarStrRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarStrRef");
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarStrRef<'a>> for VarStr {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarStrRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value: ::core::convert::Into::into(value.value()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarStrRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarStrRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarStrRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarStr>> for VarStr {
            type Value = ::planus::Offset<VarStr>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarStr>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarStrRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarStrRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarObj` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarObj` in the file `../../../schema/schema/var.fbs:64`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VarObj {
            /// The field `obj` in the table `VarObj`
            pub obj: ::planus::alloc::boxed::Box<super::moor_common::Obj>,
        }

        impl VarObj {
            /// Creates a [VarObjBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarObjBuilder<()> {
                VarObjBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<super::moor_common::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<super::moor_common::Obj>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarObj>> for VarObj {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarObj> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarObj>> for VarObj {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarObj>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarObj> for VarObj {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarObj> {
                VarObj::create(builder, &self.obj)
            }
        }

        /// Builder for serializing an instance of the [VarObj] type.
        ///
        /// Can be created using the [VarObj::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarObjBuilder<State>(State);

        impl VarObjBuilder<()> {
            /// Setter for the [`obj` field](VarObj#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> VarObjBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Obj>>,
            {
                VarObjBuilder((value,))
            }
        }

        impl<T0> VarObjBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarObj].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarObj>
            where
                Self: ::planus::WriteAsOffset<VarObj>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Obj>>>
            ::planus::WriteAs<::planus::Offset<VarObj>> for VarObjBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarObj>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarObj> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Obj>>>
            ::planus::WriteAsOptional<::planus::Offset<VarObj>> for VarObjBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarObj>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarObj>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Obj>>>
            ::planus::WriteAsOffset<VarObj> for VarObjBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarObj> {
                let (v0,) = &self.0;
                VarObj::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarObj].
        #[derive(Copy, Clone)]
        pub struct VarObjRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarObjRef<'a> {
            /// Getter for the [`obj` field](VarObj#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<super::moor_common::ObjRef<'a>> {
                self.0.access_required(0, "VarObj", "obj")
            }
        }

        impl<'a> ::core::fmt::Debug for VarObjRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarObjRef");
                f.field("obj", &self.obj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarObjRef<'a>> for VarObj {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarObjRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarObjRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarObjRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarObjRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarObj>> for VarObj {
            type Value = ::planus::Offset<VarObj>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarObj>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarObjRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarObjRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarErr` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarErr` in the file `../../../schema/schema/var.fbs:68`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct VarErr {
            /// The field `error` in the table `VarErr`
            pub error: ::planus::alloc::boxed::Box<super::moor_common::Error>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarErr {
            fn default() -> Self {
                Self {
                    error: ::core::default::Default::default(),
                }
            }
        }

        impl VarErr {
            /// Creates a [VarErrBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarErrBuilder<()> {
                VarErrBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<super::moor_common::Error>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<super::moor_common::Error>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarErr>> for VarErr {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarErr> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarErr>> for VarErr {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarErr>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarErr> for VarErr {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarErr> {
                VarErr::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [VarErr] type.
        ///
        /// Can be created using the [VarErr::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarErrBuilder<State>(State);

        impl VarErrBuilder<()> {
            /// Setter for the [`error` field](VarErr#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> VarErrBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Error>>,
            {
                VarErrBuilder((value,))
            }
        }

        impl<T0> VarErrBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarErr].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarErr>
            where
                Self: ::planus::WriteAsOffset<VarErr>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Error>>>
            ::planus::WriteAs<::planus::Offset<VarErr>> for VarErrBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarErr>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarErr> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Error>>>
            ::planus::WriteAsOptional<::planus::Offset<VarErr>> for VarErrBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarErr>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarErr>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Error>>>
            ::planus::WriteAsOffset<VarErr> for VarErrBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarErr> {
                let (v0,) = &self.0;
                VarErr::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarErr].
        #[derive(Copy, Clone)]
        pub struct VarErrRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarErrRef<'a> {
            /// Getter for the [`error` field](VarErr#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<super::moor_common::ErrorRef<'a>> {
                self.0.access_required(0, "VarErr", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for VarErrRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarErrRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarErrRef<'a>> for VarErr {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarErrRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarErrRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarErrRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarErrRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarErr>> for VarErr {
            type Value = ::planus::Offset<VarErr>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarErr>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarErrRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarErrRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarSym` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarSym` in the file `../../../schema/schema/var.fbs:72`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VarSym {
            /// The field `symbol` in the table `VarSym`
            pub symbol: ::planus::alloc::boxed::Box<super::moor_common::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarSym {
            fn default() -> Self {
                Self {
                    symbol: ::core::default::Default::default(),
                }
            }
        }

        impl VarSym {
            /// Creates a [VarSymBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarSymBuilder<()> {
                VarSymBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_symbol: impl ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_symbol = field_symbol.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<super::moor_common::Symbol>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_symbol);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarSym>> for VarSym {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarSym> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarSym>> for VarSym {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarSym>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarSym> for VarSym {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarSym> {
                VarSym::create(builder, &self.symbol)
            }
        }

        /// Builder for serializing an instance of the [VarSym] type.
        ///
        /// Can be created using the [VarSym::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarSymBuilder<State>(State);

        impl VarSymBuilder<()> {
            /// Setter for the [`symbol` field](VarSym#structfield.symbol).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn symbol<T0>(self, value: T0) -> VarSymBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            {
                VarSymBuilder((value,))
            }
        }

        impl<T0> VarSymBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarSym].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarSym>
            where
                Self: ::planus::WriteAsOffset<VarSym>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>>
            ::planus::WriteAs<::planus::Offset<VarSym>> for VarSymBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarSym>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarSym> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>>
            ::planus::WriteAsOptional<::planus::Offset<VarSym>> for VarSymBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarSym>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarSym>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>>
            ::planus::WriteAsOffset<VarSym> for VarSymBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarSym> {
                let (v0,) = &self.0;
                VarSym::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarSym].
        #[derive(Copy, Clone)]
        pub struct VarSymRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarSymRef<'a> {
            /// Getter for the [`symbol` field](VarSym#structfield.symbol).
            #[inline]
            pub fn symbol(&self) -> ::planus::Result<super::moor_common::SymbolRef<'a>> {
                self.0.access_required(0, "VarSym", "symbol")
            }
        }

        impl<'a> ::core::fmt::Debug for VarSymRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarSymRef");
                f.field("symbol", &self.symbol());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarSymRef<'a>> for VarSym {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarSymRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    symbol: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.symbol()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarSymRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarSymRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarSymRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarSym>> for VarSym {
            type Value = ::planus::Offset<VarSym>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarSym>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarSymRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarSymRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarBinary` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarBinary` in the file `../../../schema/schema/var.fbs:76`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VarBinary {
            /// The field `data` in the table `VarBinary`
            pub data: ::planus::alloc::vec::Vec<u8>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarBinary {
            fn default() -> Self {
                Self {
                    data: ::core::default::Default::default(),
                }
            }
        }

        impl VarBinary {
            /// Creates a [VarBinaryBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarBinaryBuilder<()> {
                VarBinaryBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_data = field_data.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[u8]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_data);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarBinary>> for VarBinary {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBinary> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarBinary>> for VarBinary {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarBinary>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarBinary> for VarBinary {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBinary> {
                VarBinary::create(builder, &self.data)
            }
        }

        /// Builder for serializing an instance of the [VarBinary] type.
        ///
        /// Can be created using the [VarBinary::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarBinaryBuilder<State>(State);

        impl VarBinaryBuilder<()> {
            /// Setter for the [`data` field](VarBinary#structfield.data).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn data<T0>(self, value: T0) -> VarBinaryBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
            {
                VarBinaryBuilder((value,))
            }
        }

        impl<T0> VarBinaryBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarBinary].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBinary>
            where
                Self: ::planus::WriteAsOffset<VarBinary>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAs<::planus::Offset<VarBinary>> for VarBinaryBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarBinary>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBinary> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAsOptional<::planus::Offset<VarBinary>> for VarBinaryBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarBinary>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarBinary>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>> ::planus::WriteAsOffset<VarBinary>
            for VarBinaryBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBinary> {
                let (v0,) = &self.0;
                VarBinary::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarBinary].
        #[derive(Copy, Clone)]
        pub struct VarBinaryRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarBinaryRef<'a> {
            /// Getter for the [`data` field](VarBinary#structfield.data).
            #[inline]
            pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                self.0.access_required(0, "VarBinary", "data")
            }
        }

        impl<'a> ::core::fmt::Debug for VarBinaryRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarBinaryRef");
                f.field("data", &self.data());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarBinaryRef<'a>> for VarBinary {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarBinaryRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    data: value.data()?.to_vec(),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarBinaryRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarBinaryRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VarBinaryRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarBinary>> for VarBinary {
            type Value = ::planus::Offset<VarBinary>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarBinary>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarBinaryRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarBinaryRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarList` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarList` in the file `../../../schema/schema/var.fbs:80`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct VarList {
            /// The field `elements` in the table `VarList`
            pub elements: ::planus::alloc::vec::Vec<self::Var>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarList {
            fn default() -> Self {
                Self {
                    elements: ::core::default::Default::default(),
                }
            }
        }

        impl VarList {
            /// Creates a [VarListBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarListBuilder<()> {
                VarListBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_elements: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Var>]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_elements = field_elements.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Var>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_elements);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarList>> for VarList {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarList> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarList>> for VarList {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarList>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarList> for VarList {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarList> {
                VarList::create(builder, &self.elements)
            }
        }

        /// Builder for serializing an instance of the [VarList] type.
        ///
        /// Can be created using the [VarList::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarListBuilder<State>(State);

        impl VarListBuilder<()> {
            /// Setter for the [`elements` field](VarList#structfield.elements).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn elements<T0>(self, value: T0) -> VarListBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Var>]>>,
            {
                VarListBuilder((value,))
            }
        }

        impl<T0> VarListBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarList].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarList>
            where
                Self: ::planus::WriteAsOffset<VarList>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Var>]>>>
            ::planus::WriteAs<::planus::Offset<VarList>> for VarListBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarList>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarList> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Var>]>>>
            ::planus::WriteAsOptional<::planus::Offset<VarList>> for VarListBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarList>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarList>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Var>]>>>
            ::planus::WriteAsOffset<VarList> for VarListBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarList> {
                let (v0,) = &self.0;
                VarList::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarList].
        #[derive(Copy, Clone)]
        pub struct VarListRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarListRef<'a> {
            /// Getter for the [`elements` field](VarList#structfield.elements).
            #[inline]
            pub fn elements(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VarRef<'a>>>>
            {
                self.0.access_required(0, "VarList", "elements")
            }
        }

        impl<'a> ::core::fmt::Debug for VarListRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarListRef");
                f.field("elements", &self.elements());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarListRef<'a>> for VarList {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarListRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    elements: value.elements()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarListRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarListRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarListRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarList>> for VarList {
            type Value = ::planus::Offset<VarList>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarList>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarListRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarListRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarMapPair` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarMapPair` in the file `../../../schema/schema/var.fbs:84`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct VarMapPair {
            /// The field `key` in the table `VarMapPair`
            pub key: ::planus::alloc::boxed::Box<self::Var>,
            /// The field `value` in the table `VarMapPair`
            pub value: ::planus::alloc::boxed::Box<self::Var>,
        }

        impl VarMapPair {
            /// Creates a [VarMapPairBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarMapPairBuilder<()> {
                VarMapPairBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_key: impl ::planus::WriteAs<::planus::Offset<self::Var>>,
                field_value: impl ::planus::WriteAs<::planus::Offset<self::Var>>,
            ) -> ::planus::Offset<Self> {
                let prepared_key = field_key.prepare(builder);
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Var>>(0);
                table_writer.write_entry::<::planus::Offset<self::Var>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_key);
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarMapPair>> for VarMapPair {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarMapPair> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarMapPair>> for VarMapPair {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarMapPair>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarMapPair> for VarMapPair {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarMapPair> {
                VarMapPair::create(builder, &self.key, &self.value)
            }
        }

        /// Builder for serializing an instance of the [VarMapPair] type.
        ///
        /// Can be created using the [VarMapPair::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarMapPairBuilder<State>(State);

        impl VarMapPairBuilder<()> {
            /// Setter for the [`key` field](VarMapPair#structfield.key).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn key<T0>(self, value: T0) -> VarMapPairBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Var>>,
            {
                VarMapPairBuilder((value,))
            }
        }

        impl<T0> VarMapPairBuilder<(T0,)> {
            /// Setter for the [`value` field](VarMapPair#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T1>(self, value: T1) -> VarMapPairBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Var>>,
            {
                let (v0,) = self.0;
                VarMapPairBuilder((v0, value))
            }
        }

        impl<T0, T1> VarMapPairBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarMapPair].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarMapPair>
            where
                Self: ::planus::WriteAsOffset<VarMapPair>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Var>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Var>>,
        > ::planus::WriteAs<::planus::Offset<VarMapPair>> for VarMapPairBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VarMapPair>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarMapPair> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Var>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Var>>,
        > ::planus::WriteAsOptional<::planus::Offset<VarMapPair>> for VarMapPairBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VarMapPair>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarMapPair>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Var>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Var>>,
        > ::planus::WriteAsOffset<VarMapPair> for VarMapPairBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarMapPair> {
                let (v0, v1) = &self.0;
                VarMapPair::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [VarMapPair].
        #[derive(Copy, Clone)]
        pub struct VarMapPairRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarMapPairRef<'a> {
            /// Getter for the [`key` field](VarMapPair#structfield.key).
            #[inline]
            pub fn key(&self) -> ::planus::Result<self::VarRef<'a>> {
                self.0.access_required(0, "VarMapPair", "key")
            }

            /// Getter for the [`value` field](VarMapPair#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<self::VarRef<'a>> {
                self.0.access_required(1, "VarMapPair", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for VarMapPairRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarMapPairRef");
                f.field("key", &self.key());
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarMapPairRef<'a>> for VarMapPair {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarMapPairRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    key: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.key()?,
                    )?),
                    value: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.value()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarMapPairRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarMapPairRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VarMapPairRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarMapPair>> for VarMapPair {
            type Value = ::planus::Offset<VarMapPair>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarMapPair>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarMapPairRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarMapPairRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarMap` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarMap` in the file `../../../schema/schema/var.fbs:89`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct VarMap {
            /// The field `pairs` in the table `VarMap`
            pub pairs: ::planus::alloc::vec::Vec<self::VarMapPair>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarMap {
            fn default() -> Self {
                Self {
                    pairs: ::core::default::Default::default(),
                }
            }
        }

        impl VarMap {
            /// Creates a [VarMapBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarMapBuilder<()> {
                VarMapBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_pairs: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::VarMapPair>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_pairs = field_pairs.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::VarMapPair>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_pairs);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarMap>> for VarMap {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarMap> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarMap>> for VarMap {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarMap>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarMap> for VarMap {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarMap> {
                VarMap::create(builder, &self.pairs)
            }
        }

        /// Builder for serializing an instance of the [VarMap] type.
        ///
        /// Can be created using the [VarMap::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarMapBuilder<State>(State);

        impl VarMapBuilder<()> {
            /// Setter for the [`pairs` field](VarMap#structfield.pairs).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn pairs<T0>(self, value: T0) -> VarMapBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarMapPair>]>>,
            {
                VarMapBuilder((value,))
            }
        }

        impl<T0> VarMapBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarMap].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarMap>
            where
                Self: ::planus::WriteAsOffset<VarMap>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarMapPair>]>>>
            ::planus::WriteAs<::planus::Offset<VarMap>> for VarMapBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarMap>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarMap> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarMapPair>]>>>
            ::planus::WriteAsOptional<::planus::Offset<VarMap>> for VarMapBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarMap>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarMap>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarMapPair>]>>>
            ::planus::WriteAsOffset<VarMap> for VarMapBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarMap> {
                let (v0,) = &self.0;
                VarMap::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarMap].
        #[derive(Copy, Clone)]
        pub struct VarMapRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarMapRef<'a> {
            /// Getter for the [`pairs` field](VarMap#structfield.pairs).
            #[inline]
            pub fn pairs(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VarMapPairRef<'a>>>>
            {
                self.0.access_required(0, "VarMap", "pairs")
            }
        }

        impl<'a> ::core::fmt::Debug for VarMapRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarMapRef");
                f.field("pairs", &self.pairs());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarMapRef<'a>> for VarMap {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarMapRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    pairs: value.pairs()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarMapRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarMapRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarMapRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarMap>> for VarMap {
            type Value = ::planus::Offset<VarMap>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarMap>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarMapRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarMapRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `FlyweightSlot` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `FlyweightSlot` in the file `../../../schema/schema/var.fbs:93`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct FlyweightSlot {
            /// The field `name` in the table `FlyweightSlot`
            pub name: ::planus::alloc::boxed::Box<super::moor_common::Symbol>,
            /// The field `value` in the table `FlyweightSlot`
            pub value: ::planus::alloc::boxed::Box<self::Var>,
        }

        impl FlyweightSlot {
            /// Creates a [FlyweightSlotBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> FlyweightSlotBuilder<()> {
                FlyweightSlotBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_name: impl ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
                field_value: impl ::planus::WriteAs<::planus::Offset<self::Var>>,
            ) -> ::planus::Offset<Self> {
                let prepared_name = field_name.prepare(builder);
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<super::moor_common::Symbol>>(0);
                table_writer.write_entry::<::planus::Offset<self::Var>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_name);
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<FlyweightSlot>> for FlyweightSlot {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FlyweightSlot> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<FlyweightSlot>> for FlyweightSlot {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<FlyweightSlot>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<FlyweightSlot> for FlyweightSlot {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FlyweightSlot> {
                FlyweightSlot::create(builder, &self.name, &self.value)
            }
        }

        /// Builder for serializing an instance of the [FlyweightSlot] type.
        ///
        /// Can be created using the [FlyweightSlot::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct FlyweightSlotBuilder<State>(State);

        impl FlyweightSlotBuilder<()> {
            /// Setter for the [`name` field](FlyweightSlot#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T0>(self, value: T0) -> FlyweightSlotBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            {
                FlyweightSlotBuilder((value,))
            }
        }

        impl<T0> FlyweightSlotBuilder<(T0,)> {
            /// Setter for the [`value` field](FlyweightSlot#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T1>(self, value: T1) -> FlyweightSlotBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Var>>,
            {
                let (v0,) = self.0;
                FlyweightSlotBuilder((v0, value))
            }
        }

        impl<T0, T1> FlyweightSlotBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [FlyweightSlot].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<FlyweightSlot>
            where
                Self: ::planus::WriteAsOffset<FlyweightSlot>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Var>>,
        > ::planus::WriteAs<::planus::Offset<FlyweightSlot>> for FlyweightSlotBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<FlyweightSlot>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FlyweightSlot> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Var>>,
        > ::planus::WriteAsOptional<::planus::Offset<FlyweightSlot>>
            for FlyweightSlotBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<FlyweightSlot>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<FlyweightSlot>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Var>>,
        > ::planus::WriteAsOffset<FlyweightSlot> for FlyweightSlotBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FlyweightSlot> {
                let (v0, v1) = &self.0;
                FlyweightSlot::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [FlyweightSlot].
        #[derive(Copy, Clone)]
        pub struct FlyweightSlotRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> FlyweightSlotRef<'a> {
            /// Getter for the [`name` field](FlyweightSlot#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<super::moor_common::SymbolRef<'a>> {
                self.0.access_required(0, "FlyweightSlot", "name")
            }

            /// Getter for the [`value` field](FlyweightSlot#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<self::VarRef<'a>> {
                self.0.access_required(1, "FlyweightSlot", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for FlyweightSlotRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("FlyweightSlotRef");
                f.field("name", &self.name());
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<FlyweightSlotRef<'a>> for FlyweightSlot {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: FlyweightSlotRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.name()?,
                    )?),
                    value: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.value()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for FlyweightSlotRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for FlyweightSlotRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[FlyweightSlotRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<FlyweightSlot>> for FlyweightSlot {
            type Value = ::planus::Offset<FlyweightSlot>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<FlyweightSlot>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for FlyweightSlotRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[FlyweightSlotRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarFlyweight` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarFlyweight` in the file `../../../schema/schema/var.fbs:98`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct VarFlyweight {
            /// The field `delegate` in the table `VarFlyweight`
            pub delegate: ::planus::alloc::boxed::Box<super::moor_common::Obj>,
            /// The field `slots` in the table `VarFlyweight`
            pub slots: ::planus::alloc::vec::Vec<self::FlyweightSlot>,
            /// The field `contents` in the table `VarFlyweight`
            pub contents: ::planus::alloc::boxed::Box<self::VarList>,
        }

        impl VarFlyweight {
            /// Creates a [VarFlyweightBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarFlyweightBuilder<()> {
                VarFlyweightBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_delegate: impl ::planus::WriteAs<::planus::Offset<super::moor_common::Obj>>,
                field_slots: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::FlyweightSlot>]>,
                >,
                field_contents: impl ::planus::WriteAs<::planus::Offset<self::VarList>>,
            ) -> ::planus::Offset<Self> {
                let prepared_delegate = field_delegate.prepare(builder);
                let prepared_slots = field_slots.prepare(builder);
                let prepared_contents = field_contents.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<super::moor_common::Obj>>(0);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::FlyweightSlot>]>>(1);
                table_writer.write_entry::<::planus::Offset<self::VarList>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_delegate);
                        object_writer.write::<_, _, 4>(&prepared_slots);
                        object_writer.write::<_, _, 4>(&prepared_contents);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarFlyweight>> for VarFlyweight {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarFlyweight> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarFlyweight>> for VarFlyweight {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarFlyweight>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarFlyweight> for VarFlyweight {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarFlyweight> {
                VarFlyweight::create(builder, &self.delegate, &self.slots, &self.contents)
            }
        }

        /// Builder for serializing an instance of the [VarFlyweight] type.
        ///
        /// Can be created using the [VarFlyweight::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarFlyweightBuilder<State>(State);

        impl VarFlyweightBuilder<()> {
            /// Setter for the [`delegate` field](VarFlyweight#structfield.delegate).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn delegate<T0>(self, value: T0) -> VarFlyweightBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Obj>>,
            {
                VarFlyweightBuilder((value,))
            }
        }

        impl<T0> VarFlyweightBuilder<(T0,)> {
            /// Setter for the [`slots` field](VarFlyweight#structfield.slots).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn slots<T1>(self, value: T1) -> VarFlyweightBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::FlyweightSlot>]>>,
            {
                let (v0,) = self.0;
                VarFlyweightBuilder((v0, value))
            }
        }

        impl<T0, T1> VarFlyweightBuilder<(T0, T1)> {
            /// Setter for the [`contents` field](VarFlyweight#structfield.contents).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn contents<T2>(self, value: T2) -> VarFlyweightBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::VarList>>,
            {
                let (v0, v1) = self.0;
                VarFlyweightBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> VarFlyweightBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarFlyweight].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarFlyweight>
            where
                Self: ::planus::WriteAsOffset<VarFlyweight>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::FlyweightSlot>]>>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarList>>,
        > ::planus::WriteAs<::planus::Offset<VarFlyweight>> for VarFlyweightBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<VarFlyweight>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarFlyweight> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::FlyweightSlot>]>>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarList>>,
        > ::planus::WriteAsOptional<::planus::Offset<VarFlyweight>>
            for VarFlyweightBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<VarFlyweight>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarFlyweight>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::FlyweightSlot>]>>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarList>>,
        > ::planus::WriteAsOffset<VarFlyweight> for VarFlyweightBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarFlyweight> {
                let (v0, v1, v2) = &self.0;
                VarFlyweight::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [VarFlyweight].
        #[derive(Copy, Clone)]
        pub struct VarFlyweightRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarFlyweightRef<'a> {
            /// Getter for the [`delegate` field](VarFlyweight#structfield.delegate).
            #[inline]
            pub fn delegate(&self) -> ::planus::Result<super::moor_common::ObjRef<'a>> {
                self.0.access_required(0, "VarFlyweight", "delegate")
            }

            /// Getter for the [`slots` field](VarFlyweight#structfield.slots).
            #[inline]
            pub fn slots(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::FlyweightSlotRef<'a>>>>
            {
                self.0.access_required(1, "VarFlyweight", "slots")
            }

            /// Getter for the [`contents` field](VarFlyweight#structfield.contents).
            #[inline]
            pub fn contents(&self) -> ::planus::Result<self::VarListRef<'a>> {
                self.0.access_required(2, "VarFlyweight", "contents")
            }
        }

        impl<'a> ::core::fmt::Debug for VarFlyweightRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarFlyweightRef");
                f.field("delegate", &self.delegate());
                f.field("slots", &self.slots());
                f.field("contents", &self.contents());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarFlyweightRef<'a>> for VarFlyweight {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarFlyweightRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    delegate: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.delegate()?,
                    )?),
                    slots: value.slots()?.to_vec_result()?,
                    contents: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.contents()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarFlyweightRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarFlyweightRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VarFlyweightRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarFlyweight>> for VarFlyweight {
            type Value = ::planus::Offset<VarFlyweight>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarFlyweight>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarFlyweightRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarFlyweightRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarLambda` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `VarLambda` in the file `../../../schema/schema/var.fbs:104`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct VarLambda {
            /// The field `params` in the table `VarLambda`
            pub params: ::planus::alloc::boxed::Box<super::moor_program::StoredScatterArgs>,
            /// The field `body` in the table `VarLambda`
            pub body: ::planus::alloc::boxed::Box<super::moor_program::StoredProgram>,
            /// The field `captured_env` in the table `VarLambda`
            pub captured_env: ::planus::alloc::vec::Vec<self::VarList>,
            /// The field `self_var` in the table `VarLambda`
            pub self_var: ::core::option::Option<
                ::planus::alloc::boxed::Box<super::moor_program::StoredName>,
            >,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarLambda {
            fn default() -> Self {
                Self {
                    params: ::core::default::Default::default(),
                    body: ::core::default::Default::default(),
                    captured_env: ::core::default::Default::default(),
                    self_var: ::core::default::Default::default(),
                }
            }
        }

        impl VarLambda {
            /// Creates a [VarLambdaBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarLambdaBuilder<()> {
                VarLambdaBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_params: impl ::planus::WriteAs<
                    ::planus::Offset<super::moor_program::StoredScatterArgs>,
                >,
                field_body: impl ::planus::WriteAs<::planus::Offset<super::moor_program::StoredProgram>>,
                field_captured_env: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::VarList>]>,
                >,
                field_self_var: impl ::planus::WriteAsOptional<
                    ::planus::Offset<super::moor_program::StoredName>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_params = field_params.prepare(builder);
                let prepared_body = field_body.prepare(builder);
                let prepared_captured_env = field_captured_env.prepare(builder);
                let prepared_self_var = field_self_var.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer
                    .write_entry::<::planus::Offset<super::moor_program::StoredScatterArgs>>(0);
                table_writer.write_entry::<::planus::Offset<super::moor_program::StoredProgram>>(1);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::VarList>]>>(2);
                if prepared_self_var.is_some() {
                    table_writer
                        .write_entry::<::planus::Offset<super::moor_program::StoredName>>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_params);
                        object_writer.write::<_, _, 4>(&prepared_body);
                        object_writer.write::<_, _, 4>(&prepared_captured_env);
                        if let ::core::option::Option::Some(prepared_self_var) = prepared_self_var {
                            object_writer.write::<_, _, 4>(&prepared_self_var);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarLambda>> for VarLambda {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarLambda> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarLambda>> for VarLambda {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarLambda>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarLambda> for VarLambda {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarLambda> {
                VarLambda::create(
                    builder,
                    &self.params,
                    &self.body,
                    &self.captured_env,
                    &self.self_var,
                )
            }
        }

        /// Builder for serializing an instance of the [VarLambda] type.
        ///
        /// Can be created using the [VarLambda::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarLambdaBuilder<State>(State);

        impl VarLambdaBuilder<()> {
            /// Setter for the [`params` field](VarLambda#structfield.params).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn params<T0>(self, value: T0) -> VarLambdaBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<super::moor_program::StoredScatterArgs>>,
            {
                VarLambdaBuilder((value,))
            }
        }

        impl<T0> VarLambdaBuilder<(T0,)> {
            /// Setter for the [`body` field](VarLambda#structfield.body).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn body<T1>(self, value: T1) -> VarLambdaBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<super::moor_program::StoredProgram>>,
            {
                let (v0,) = self.0;
                VarLambdaBuilder((v0, value))
            }
        }

        impl<T0, T1> VarLambdaBuilder<(T0, T1)> {
            /// Setter for the [`captured_env` field](VarLambda#structfield.captured_env).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn captured_env<T2>(self, value: T2) -> VarLambdaBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarList>]>>,
            {
                let (v0, v1) = self.0;
                VarLambdaBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> VarLambdaBuilder<(T0, T1, T2)> {
            /// Setter for the [`self_var` field](VarLambda#structfield.self_var).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn self_var<T3>(self, value: T3) -> VarLambdaBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsOptional<::planus::Offset<super::moor_program::StoredName>>,
            {
                let (v0, v1, v2) = self.0;
                VarLambdaBuilder((v0, v1, v2, value))
            }

            /// Sets the [`self_var` field](VarLambda#structfield.self_var) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn self_var_as_null(self) -> VarLambdaBuilder<(T0, T1, T2, ())> {
                self.self_var(())
            }
        }

        impl<T0, T1, T2, T3> VarLambdaBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarLambda].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarLambda>
            where
                Self: ::planus::WriteAsOffset<VarLambda>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_program::StoredScatterArgs>>,
            T1: ::planus::WriteAs<::planus::Offset<super::moor_program::StoredProgram>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarList>]>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<super::moor_program::StoredName>>,
        > ::planus::WriteAs<::planus::Offset<VarLambda>> for VarLambdaBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<VarLambda>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarLambda> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_program::StoredScatterArgs>>,
            T1: ::planus::WriteAs<::planus::Offset<super::moor_program::StoredProgram>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarList>]>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<super::moor_program::StoredName>>,
        > ::planus::WriteAsOptional<::planus::Offset<VarLambda>>
            for VarLambdaBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<VarLambda>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarLambda>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<super::moor_program::StoredScatterArgs>>,
            T1: ::planus::WriteAs<::planus::Offset<super::moor_program::StoredProgram>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarList>]>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<super::moor_program::StoredName>>,
        > ::planus::WriteAsOffset<VarLambda> for VarLambdaBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarLambda> {
                let (v0, v1, v2, v3) = &self.0;
                VarLambda::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [VarLambda].
        #[derive(Copy, Clone)]
        pub struct VarLambdaRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarLambdaRef<'a> {
            /// Getter for the [`params` field](VarLambda#structfield.params).
            #[inline]
            pub fn params(
                &self,
            ) -> ::planus::Result<super::moor_program::StoredScatterArgsRef<'a>> {
                self.0.access_required(0, "VarLambda", "params")
            }

            /// Getter for the [`body` field](VarLambda#structfield.body).
            #[inline]
            pub fn body(&self) -> ::planus::Result<super::moor_program::StoredProgramRef<'a>> {
                self.0.access_required(1, "VarLambda", "body")
            }

            /// Getter for the [`captured_env` field](VarLambda#structfield.captured_env).
            #[inline]
            pub fn captured_env(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VarListRef<'a>>>>
            {
                self.0.access_required(2, "VarLambda", "captured_env")
            }

            /// Getter for the [`self_var` field](VarLambda#structfield.self_var).
            #[inline]
            pub fn self_var(
                &self,
            ) -> ::planus::Result<::core::option::Option<super::moor_program::StoredNameRef<'a>>>
            {
                self.0.access(3, "VarLambda", "self_var")
            }
        }

        impl<'a> ::core::fmt::Debug for VarLambdaRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarLambdaRef");
                f.field("params", &self.params());
                f.field("body", &self.body());
                f.field("captured_env", &self.captured_env());
                if let ::core::option::Option::Some(field_self_var) = self.self_var().transpose() {
                    f.field("self_var", &field_self_var);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarLambdaRef<'a>> for VarLambda {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarLambdaRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    params: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.params()?,
                    )?),
                    body: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.body()?,
                    )?),
                    captured_env: value.captured_env()?.to_vec_result()?,
                    self_var: if let ::core::option::Option::Some(self_var) = value.self_var()? {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(self_var)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarLambdaRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarLambdaRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VarLambdaRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarLambda>> for VarLambda {
            type Value = ::planus::Offset<VarLambda>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarLambda>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarLambdaRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarLambdaRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Var` in the namespace `MoorVar`
        ///
        /// Generated from these locations:
        /// * Table `Var` in the file `../../../schema/schema/var.fbs:111`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct Var {
            /// The field `variant` in the table `Var`
            pub variant: self::VarUnion,
        }

        impl Var {
            /// Creates a [VarBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarBuilder<()> {
                VarBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_variant: impl ::planus::WriteAsUnion<self::VarUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_variant = field_variant.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::VarUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_variant.offset());
                        object_writer.write::<_, _, 1>(&prepared_variant.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Var>> for Var {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Var> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Var>> for Var {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Var>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Var> for Var {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Var> {
                Var::create(builder, &self.variant)
            }
        }

        /// Builder for serializing an instance of the [Var] type.
        ///
        /// Can be created using the [Var::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarBuilder<State>(State);

        impl VarBuilder<()> {
            /// Setter for the [`variant` field](Var#structfield.variant).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn variant<T0>(self, value: T0) -> VarBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::VarUnion>,
            {
                VarBuilder((value,))
            }
        }

        impl<T0> VarBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Var].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Var>
            where
                Self: ::planus::WriteAsOffset<Var>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::VarUnion>> ::planus::WriteAs<::planus::Offset<Var>>
            for VarBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Var>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Var> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::VarUnion>>
            ::planus::WriteAsOptional<::planus::Offset<Var>> for VarBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Var>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Var>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::VarUnion>> ::planus::WriteAsOffset<Var>
            for VarBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Var> {
                let (v0,) = &self.0;
                Var::create(builder, v0)
            }
        }

        /// Reference to a deserialized [Var].
        #[derive(Copy, Clone)]
        pub struct VarRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarRef<'a> {
            /// Getter for the [`variant` field](Var#structfield.variant).
            #[inline]
            pub fn variant(&self) -> ::planus::Result<self::VarUnionRef<'a>> {
                self.0.access_union_required(0, "Var", "variant")
            }
        }

        impl<'a> ::core::fmt::Debug for VarRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarRef");
                f.field("variant", &self.variant());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarRef<'a>> for Var {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    variant: ::core::convert::TryInto::try_into(value.variant()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Var>> for Var {
            type Value = ::planus::Offset<Var>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Var>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| error_kind.with_error_location("[VarRef]", "read_as_root", 0))
            }
        }
    }
    /// The namespace `MoorProgram`
    ///
    /// Generated from these locations:
    /// * File `../../../schema/schema/moor_program.fbs`
    pub mod moor_program {
        /// The table `StoredName` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredName` in the file `../../../schema/schema/moor_program.fbs:35`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredName {
            /// The field `offset` in the table `StoredName`
            pub offset: u16,
            /// The field `scope_depth` in the table `StoredName`
            pub scope_depth: u8,
            /// The field `scope_id` in the table `StoredName`
            pub scope_id: u16,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredName {
            fn default() -> Self {
                Self {
                    offset: 0,
                    scope_depth: 0,
                    scope_id: 0,
                }
            }
        }

        impl StoredName {
            /// Creates a [StoredNameBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredNameBuilder<()> {
                StoredNameBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_offset: impl ::planus::WriteAsDefault<u16, u16>,
                field_scope_depth: impl ::planus::WriteAsDefault<u8, u8>,
                field_scope_id: impl ::planus::WriteAsDefault<u16, u16>,
            ) -> ::planus::Offset<Self> {
                let prepared_offset = field_offset.prepare(builder, &0);
                let prepared_scope_depth = field_scope_depth.prepare(builder, &0);
                let prepared_scope_id = field_scope_id.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                if prepared_offset.is_some() {
                    table_writer.write_entry::<u16>(0);
                }
                if prepared_scope_id.is_some() {
                    table_writer.write_entry::<u16>(2);
                }
                if prepared_scope_depth.is_some() {
                    table_writer.write_entry::<u8>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_offset) = prepared_offset {
                            object_writer.write::<_, _, 2>(&prepared_offset);
                        }
                        if let ::core::option::Option::Some(prepared_scope_id) = prepared_scope_id {
                            object_writer.write::<_, _, 2>(&prepared_scope_id);
                        }
                        if let ::core::option::Option::Some(prepared_scope_depth) =
                            prepared_scope_depth
                        {
                            object_writer.write::<_, _, 1>(&prepared_scope_depth);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredName>> for StoredName {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredName> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredName>> for StoredName {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredName>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredName> for StoredName {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredName> {
                StoredName::create(builder, self.offset, self.scope_depth, self.scope_id)
            }
        }

        /// Builder for serializing an instance of the [StoredName] type.
        ///
        /// Can be created using the [StoredName::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredNameBuilder<State>(State);

        impl StoredNameBuilder<()> {
            /// Setter for the [`offset` field](StoredName#structfield.offset).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn offset<T0>(self, value: T0) -> StoredNameBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u16, u16>,
            {
                StoredNameBuilder((value,))
            }

            /// Sets the [`offset` field](StoredName#structfield.offset) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn offset_as_default(self) -> StoredNameBuilder<(::planus::DefaultValue,)> {
                self.offset(::planus::DefaultValue)
            }
        }

        impl<T0> StoredNameBuilder<(T0,)> {
            /// Setter for the [`scope_depth` field](StoredName#structfield.scope_depth).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scope_depth<T1>(self, value: T1) -> StoredNameBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u8, u8>,
            {
                let (v0,) = self.0;
                StoredNameBuilder((v0, value))
            }

            /// Sets the [`scope_depth` field](StoredName#structfield.scope_depth) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scope_depth_as_default(self) -> StoredNameBuilder<(T0, ::planus::DefaultValue)> {
                self.scope_depth(::planus::DefaultValue)
            }
        }

        impl<T0, T1> StoredNameBuilder<(T0, T1)> {
            /// Setter for the [`scope_id` field](StoredName#structfield.scope_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scope_id<T2>(self, value: T2) -> StoredNameBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1) = self.0;
                StoredNameBuilder((v0, v1, value))
            }

            /// Sets the [`scope_id` field](StoredName#structfield.scope_id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scope_id_as_default(
                self,
            ) -> StoredNameBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.scope_id(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> StoredNameBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredName].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredName>
            where
                Self: ::planus::WriteAsOffset<StoredName>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAsDefault<u8, u8>,
            T2: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAs<::planus::Offset<StoredName>> for StoredNameBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredName>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredName> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAsDefault<u8, u8>,
            T2: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredName>>
            for StoredNameBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredName>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredName>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAsDefault<u8, u8>,
            T2: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOffset<StoredName> for StoredNameBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredName> {
                let (v0, v1, v2) = &self.0;
                StoredName::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [StoredName].
        #[derive(Copy, Clone)]
        pub struct StoredNameRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredNameRef<'a> {
            /// Getter for the [`offset` field](StoredName#structfield.offset).
            #[inline]
            pub fn offset(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(self.0.access(0, "StoredName", "offset")?.unwrap_or(0))
            }

            /// Getter for the [`scope_depth` field](StoredName#structfield.scope_depth).
            #[inline]
            pub fn scope_depth(&self) -> ::planus::Result<u8> {
                ::core::result::Result::Ok(
                    self.0.access(1, "StoredName", "scope_depth")?.unwrap_or(0),
                )
            }

            /// Getter for the [`scope_id` field](StoredName#structfield.scope_id).
            #[inline]
            pub fn scope_id(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(self.0.access(2, "StoredName", "scope_id")?.unwrap_or(0))
            }
        }

        impl<'a> ::core::fmt::Debug for StoredNameRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredNameRef");
                f.field("offset", &self.offset());
                f.field("scope_depth", &self.scope_depth());
                f.field("scope_id", &self.scope_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredNameRef<'a>> for StoredName {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredNameRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    offset: ::core::convert::TryInto::try_into(value.offset()?)?,
                    scope_depth: ::core::convert::TryInto::try_into(value.scope_depth()?)?,
                    scope_id: ::core::convert::TryInto::try_into(value.scope_id()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredNameRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredNameRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredNameRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredName>> for StoredName {
            type Value = ::planus::Offset<StoredName>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredName>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredNameRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredNameRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredJumpLabel` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredJumpLabel` in the file `../../../schema/schema/moor_program.fbs:41`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredJumpLabel {
            /// The field `id` in the table `StoredJumpLabel`
            pub id: u16,
            /// The field `position` in the table `StoredJumpLabel`
            pub position: u16,
            /// The field `name` in the table `StoredJumpLabel`
            pub name: ::core::option::Option<::planus::alloc::boxed::Box<self::StoredName>>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredJumpLabel {
            fn default() -> Self {
                Self {
                    id: 0,
                    position: 0,
                    name: ::core::default::Default::default(),
                }
            }
        }

        impl StoredJumpLabel {
            /// Creates a [StoredJumpLabelBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredJumpLabelBuilder<()> {
                StoredJumpLabelBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_id: impl ::planus::WriteAsDefault<u16, u16>,
                field_position: impl ::planus::WriteAsDefault<u16, u16>,
                field_name: impl ::planus::WriteAsOptional<::planus::Offset<self::StoredName>>,
            ) -> ::planus::Offset<Self> {
                let prepared_id = field_id.prepare(builder, &0);
                let prepared_position = field_position.prepare(builder, &0);
                let prepared_name = field_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                if prepared_name.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::StoredName>>(2);
                }
                if prepared_id.is_some() {
                    table_writer.write_entry::<u16>(0);
                }
                if prepared_position.is_some() {
                    table_writer.write_entry::<u16>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_name) = prepared_name {
                            object_writer.write::<_, _, 4>(&prepared_name);
                        }
                        if let ::core::option::Option::Some(prepared_id) = prepared_id {
                            object_writer.write::<_, _, 2>(&prepared_id);
                        }
                        if let ::core::option::Option::Some(prepared_position) = prepared_position {
                            object_writer.write::<_, _, 2>(&prepared_position);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredJumpLabel>> for StoredJumpLabel {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredJumpLabel> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredJumpLabel>> for StoredJumpLabel {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredJumpLabel>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredJumpLabel> for StoredJumpLabel {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredJumpLabel> {
                StoredJumpLabel::create(builder, self.id, self.position, &self.name)
            }
        }

        /// Builder for serializing an instance of the [StoredJumpLabel] type.
        ///
        /// Can be created using the [StoredJumpLabel::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredJumpLabelBuilder<State>(State);

        impl StoredJumpLabelBuilder<()> {
            /// Setter for the [`id` field](StoredJumpLabel#structfield.id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id<T0>(self, value: T0) -> StoredJumpLabelBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u16, u16>,
            {
                StoredJumpLabelBuilder((value,))
            }

            /// Sets the [`id` field](StoredJumpLabel#structfield.id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id_as_default(self) -> StoredJumpLabelBuilder<(::planus::DefaultValue,)> {
                self.id(::planus::DefaultValue)
            }
        }

        impl<T0> StoredJumpLabelBuilder<(T0,)> {
            /// Setter for the [`position` field](StoredJumpLabel#structfield.position).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn position<T1>(self, value: T1) -> StoredJumpLabelBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0,) = self.0;
                StoredJumpLabelBuilder((v0, value))
            }

            /// Sets the [`position` field](StoredJumpLabel#structfield.position) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn position_as_default(
                self,
            ) -> StoredJumpLabelBuilder<(T0, ::planus::DefaultValue)> {
                self.position(::planus::DefaultValue)
            }
        }

        impl<T0, T1> StoredJumpLabelBuilder<(T0, T1)> {
            /// Setter for the [`name` field](StoredJumpLabel#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T2>(self, value: T2) -> StoredJumpLabelBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsOptional<::planus::Offset<self::StoredName>>,
            {
                let (v0, v1) = self.0;
                StoredJumpLabelBuilder((v0, v1, value))
            }

            /// Sets the [`name` field](StoredJumpLabel#structfield.name) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name_as_null(self) -> StoredJumpLabelBuilder<(T0, T1, ())> {
                self.name(())
            }
        }

        impl<T0, T1, T2> StoredJumpLabelBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredJumpLabel].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredJumpLabel>
            where
                Self: ::planus::WriteAsOffset<StoredJumpLabel>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::StoredName>>,
        > ::planus::WriteAs<::planus::Offset<StoredJumpLabel>>
            for StoredJumpLabelBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredJumpLabel>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredJumpLabel> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::StoredName>>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredJumpLabel>>
            for StoredJumpLabelBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredJumpLabel>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredJumpLabel>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::StoredName>>,
        > ::planus::WriteAsOffset<StoredJumpLabel> for StoredJumpLabelBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredJumpLabel> {
                let (v0, v1, v2) = &self.0;
                StoredJumpLabel::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [StoredJumpLabel].
        #[derive(Copy, Clone)]
        pub struct StoredJumpLabelRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredJumpLabelRef<'a> {
            /// Getter for the [`id` field](StoredJumpLabel#structfield.id).
            #[inline]
            pub fn id(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(self.0.access(0, "StoredJumpLabel", "id")?.unwrap_or(0))
            }

            /// Getter for the [`position` field](StoredJumpLabel#structfield.position).
            #[inline]
            pub fn position(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "StoredJumpLabel", "position")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`name` field](StoredJumpLabel#structfield.name).
            #[inline]
            pub fn name(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::StoredNameRef<'a>>> {
                self.0.access(2, "StoredJumpLabel", "name")
            }
        }

        impl<'a> ::core::fmt::Debug for StoredJumpLabelRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredJumpLabelRef");
                f.field("id", &self.id());
                f.field("position", &self.position());
                if let ::core::option::Option::Some(field_name) = self.name().transpose() {
                    f.field("name", &field_name);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredJumpLabelRef<'a>> for StoredJumpLabel {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredJumpLabelRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    id: ::core::convert::TryInto::try_into(value.id()?)?,
                    position: ::core::convert::TryInto::try_into(value.position()?)?,
                    name: if let ::core::option::Option::Some(name) = value.name()? {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(name)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredJumpLabelRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredJumpLabelRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredJumpLabelRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredJumpLabel>> for StoredJumpLabel {
            type Value = ::planus::Offset<StoredJumpLabel>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredJumpLabel>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredJumpLabelRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredJumpLabelRef]", "read_as_root", 0)
                })
            }
        }

        /// The enum `StoredDeclType` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Enum `StoredDeclType` in the file `../../../schema/schema/moor_program.fbs:48`
        #[derive(
            Copy,
            Clone,
            Debug,
            PartialEq,
            Eq,
            PartialOrd,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        #[repr(u8)]
        pub enum StoredDeclType {
            /// The variant `Global` in the enum `StoredDeclType`
            Global = 0,

            /// The variant `Let` in the enum `StoredDeclType`
            Let = 1,

            /// The variant `Assign` in the enum `StoredDeclType`
            Assign = 2,

            /// The variant `For` in the enum `StoredDeclType`
            For = 3,

            /// The variant `Unknown` in the enum `StoredDeclType`
            Unknown = 4,

            /// The variant `Register` in the enum `StoredDeclType`
            Register = 5,

            /// The variant `Except` in the enum `StoredDeclType`
            Except = 6,

            /// The variant `WhileLabel` in the enum `StoredDeclType`
            WhileLabel = 7,

            /// The variant `ForkLabel` in the enum `StoredDeclType`
            ForkLabel = 8,
        }

        impl StoredDeclType {
            /// Array containing all valid variants of StoredDeclType
            pub const ENUM_VALUES: [Self; 9] = [
                Self::Global,
                Self::Let,
                Self::Assign,
                Self::For,
                Self::Unknown,
                Self::Register,
                Self::Except,
                Self::WhileLabel,
                Self::ForkLabel,
            ];
        }

        impl ::core::convert::TryFrom<u8> for StoredDeclType {
            type Error = ::planus::errors::UnknownEnumTagKind;
            #[inline]
            fn try_from(
                value: u8,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind> {
                #[allow(clippy::match_single_binding)]
                match value {
                    0 => ::core::result::Result::Ok(StoredDeclType::Global),
                    1 => ::core::result::Result::Ok(StoredDeclType::Let),
                    2 => ::core::result::Result::Ok(StoredDeclType::Assign),
                    3 => ::core::result::Result::Ok(StoredDeclType::For),
                    4 => ::core::result::Result::Ok(StoredDeclType::Unknown),
                    5 => ::core::result::Result::Ok(StoredDeclType::Register),
                    6 => ::core::result::Result::Ok(StoredDeclType::Except),
                    7 => ::core::result::Result::Ok(StoredDeclType::WhileLabel),
                    8 => ::core::result::Result::Ok(StoredDeclType::ForkLabel),

                    _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                        tag: value as i128,
                    }),
                }
            }
        }

        impl ::core::convert::From<StoredDeclType> for u8 {
            #[inline]
            fn from(value: StoredDeclType) -> Self {
                value as u8
            }
        }

        /// # Safety
        /// The Planus compiler correctly calculates `ALIGNMENT` and `SIZE`.
        unsafe impl ::planus::Primitive for StoredDeclType {
            const ALIGNMENT: usize = 1;
            const SIZE: usize = 1;
        }

        impl ::planus::WriteAsPrimitive<StoredDeclType> for StoredDeclType {
            #[inline]
            fn write<const N: usize>(&self, cursor: ::planus::Cursor<'_, N>, buffer_position: u32) {
                (*self as u8).write(cursor, buffer_position);
            }
        }

        impl ::planus::WriteAs<StoredDeclType> for StoredDeclType {
            type Prepared = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> StoredDeclType {
                *self
            }
        }

        impl ::planus::WriteAsDefault<StoredDeclType, StoredDeclType> for StoredDeclType {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
                default: &StoredDeclType,
            ) -> ::core::option::Option<StoredDeclType> {
                if self == default {
                    ::core::option::Option::None
                } else {
                    ::core::option::Option::Some(*self)
                }
            }
        }

        impl ::planus::WriteAsOptional<StoredDeclType> for StoredDeclType {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<StoredDeclType> {
                ::core::option::Option::Some(*self)
            }
        }

        impl<'buf> ::planus::TableRead<'buf> for StoredDeclType {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
            }
        }

        impl<'buf> ::planus::VectorReadInner<'buf> for StoredDeclType {
            type Error = ::planus::errors::UnknownEnumTag;
            const STRIDE: usize = 1;
            #[inline]
            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag> {
                let value = unsafe { *buffer.buffer.get_unchecked(offset) };
                let value: ::core::result::Result<Self, _> =
                    ::core::convert::TryInto::try_into(value);
                value.map_err(|error_kind| {
                    error_kind.with_error_location(
                        "StoredDeclType",
                        "VectorRead::from_buffer",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<StoredDeclType> for StoredDeclType {
            const STRIDE: usize = 1;

            type Value = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                *self
            }

            #[inline]
            unsafe fn write_values(
                values: &[Self],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - i as u32,
                    );
                }
            }
        }

        /// The union `StoredVarNameUnion` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Union `StoredVarNameUnion` in the file `../../../schema/schema/moor_program.fbs:61`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum StoredVarNameUnion {
            /// The variant of type `StoredNamedVar` in the union `StoredVarNameUnion`
            StoredNamedVar(::planus::alloc::boxed::Box<self::StoredNamedVar>),

            /// The variant of type `StoredRegisterVar` in the union `StoredVarNameUnion`
            StoredRegisterVar(::planus::alloc::boxed::Box<self::StoredRegisterVar>),
        }

        impl StoredVarNameUnion {
            /// Creates a [StoredVarNameUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredVarNameUnionBuilder<::planus::Uninitialized> {
                StoredVarNameUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_stored_named_var(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::StoredNamedVar>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_stored_register_var(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::StoredRegisterVar>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<StoredVarNameUnion> for StoredVarNameUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::StoredNamedVar(value) => Self::create_stored_named_var(builder, value),
                    Self::StoredRegisterVar(value) => {
                        Self::create_stored_register_var(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<StoredVarNameUnion> for StoredVarNameUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [StoredVarNameUnion] type.
        ///
        /// Can be created using the [StoredVarNameUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredVarNameUnionBuilder<T>(T);

        impl StoredVarNameUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`StoredNamedVar` variant](StoredVarNameUnion#variant.StoredNamedVar).
            #[inline]
            pub fn stored_named_var<T>(
                self,
                value: T,
            ) -> StoredVarNameUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::StoredNamedVar>,
            {
                StoredVarNameUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`StoredRegisterVar` variant](StoredVarNameUnion#variant.StoredRegisterVar).
            #[inline]
            pub fn stored_register_var<T>(
                self,
                value: T,
            ) -> StoredVarNameUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::StoredRegisterVar>,
            {
                StoredVarNameUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> StoredVarNameUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [StoredVarNameUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<StoredVarNameUnion>
            where
                Self: ::planus::WriteAsUnion<StoredVarNameUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<StoredVarNameUnion>
            for StoredVarNameUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::StoredNamedVar>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<StoredVarNameUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<StoredVarNameUnion>
            for StoredVarNameUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::StoredNamedVar>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<StoredVarNameUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<StoredVarNameUnion>
            for StoredVarNameUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::StoredRegisterVar>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<StoredVarNameUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<StoredVarNameUnion>
            for StoredVarNameUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::StoredRegisterVar>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<StoredVarNameUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [StoredVarNameUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum StoredVarNameUnionRef<'a> {
            StoredNamedVar(self::StoredNamedVarRef<'a>),
            StoredRegisterVar(self::StoredRegisterVarRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<StoredVarNameUnionRef<'a>> for StoredVarNameUnion {
            type Error = ::planus::Error;

            fn try_from(value: StoredVarNameUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    StoredVarNameUnionRef::StoredNamedVar(value) => {
                        Self::StoredNamedVar(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    StoredVarNameUnionRef::StoredRegisterVar(value) => {
                        Self::StoredRegisterVar(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for StoredVarNameUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::StoredNamedVar(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::StoredRegisterVar(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for StoredVarNameUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[StoredVarNameUnionRef]";
        }

        /// The table `StoredNamedVar` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredNamedVar` in the file `../../../schema/schema/moor_program.fbs:66`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredNamedVar {
            /// The field `symbol` in the table `StoredNamedVar`
            pub symbol: ::planus::alloc::boxed::Box<super::moor_common::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredNamedVar {
            fn default() -> Self {
                Self {
                    symbol: ::core::default::Default::default(),
                }
            }
        }

        impl StoredNamedVar {
            /// Creates a [StoredNamedVarBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredNamedVarBuilder<()> {
                StoredNamedVarBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_symbol: impl ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_symbol = field_symbol.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<super::moor_common::Symbol>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_symbol);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredNamedVar>> for StoredNamedVar {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredNamedVar> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredNamedVar>> for StoredNamedVar {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredNamedVar>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredNamedVar> for StoredNamedVar {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredNamedVar> {
                StoredNamedVar::create(builder, &self.symbol)
            }
        }

        /// Builder for serializing an instance of the [StoredNamedVar] type.
        ///
        /// Can be created using the [StoredNamedVar::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredNamedVarBuilder<State>(State);

        impl StoredNamedVarBuilder<()> {
            /// Setter for the [`symbol` field](StoredNamedVar#structfield.symbol).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn symbol<T0>(self, value: T0) -> StoredNamedVarBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>,
            {
                StoredNamedVarBuilder((value,))
            }
        }

        impl<T0> StoredNamedVarBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredNamedVar].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredNamedVar>
            where
                Self: ::planus::WriteAsOffset<StoredNamedVar>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>>
            ::planus::WriteAs<::planus::Offset<StoredNamedVar>> for StoredNamedVarBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<StoredNamedVar>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredNamedVar> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>>
            ::planus::WriteAsOptional<::planus::Offset<StoredNamedVar>>
            for StoredNamedVarBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<StoredNamedVar>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredNamedVar>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<super::moor_common::Symbol>>>
            ::planus::WriteAsOffset<StoredNamedVar> for StoredNamedVarBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredNamedVar> {
                let (v0,) = &self.0;
                StoredNamedVar::create(builder, v0)
            }
        }

        /// Reference to a deserialized [StoredNamedVar].
        #[derive(Copy, Clone)]
        pub struct StoredNamedVarRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredNamedVarRef<'a> {
            /// Getter for the [`symbol` field](StoredNamedVar#structfield.symbol).
            #[inline]
            pub fn symbol(&self) -> ::planus::Result<super::moor_common::SymbolRef<'a>> {
                self.0.access_required(0, "StoredNamedVar", "symbol")
            }
        }

        impl<'a> ::core::fmt::Debug for StoredNamedVarRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredNamedVarRef");
                f.field("symbol", &self.symbol());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredNamedVarRef<'a>> for StoredNamedVar {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredNamedVarRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    symbol: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.symbol()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredNamedVarRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredNamedVarRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredNamedVarRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredNamedVar>> for StoredNamedVar {
            type Value = ::planus::Offset<StoredNamedVar>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredNamedVar>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredNamedVarRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredNamedVarRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredRegisterVar` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredRegisterVar` in the file `../../../schema/schema/moor_program.fbs:70`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredRegisterVar {
            /// The field `register_num` in the table `StoredRegisterVar`
            pub register_num: u16,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredRegisterVar {
            fn default() -> Self {
                Self { register_num: 0 }
            }
        }

        impl StoredRegisterVar {
            /// Creates a [StoredRegisterVarBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredRegisterVarBuilder<()> {
                StoredRegisterVarBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_register_num: impl ::planus::WriteAsDefault<u16, u16>,
            ) -> ::planus::Offset<Self> {
                let prepared_register_num = field_register_num.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_register_num.is_some() {
                    table_writer.write_entry::<u16>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_register_num) =
                            prepared_register_num
                        {
                            object_writer.write::<_, _, 2>(&prepared_register_num);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredRegisterVar>> for StoredRegisterVar {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredRegisterVar> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredRegisterVar>> for StoredRegisterVar {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredRegisterVar>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredRegisterVar> for StoredRegisterVar {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredRegisterVar> {
                StoredRegisterVar::create(builder, self.register_num)
            }
        }

        /// Builder for serializing an instance of the [StoredRegisterVar] type.
        ///
        /// Can be created using the [StoredRegisterVar::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredRegisterVarBuilder<State>(State);

        impl StoredRegisterVarBuilder<()> {
            /// Setter for the [`register_num` field](StoredRegisterVar#structfield.register_num).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn register_num<T0>(self, value: T0) -> StoredRegisterVarBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u16, u16>,
            {
                StoredRegisterVarBuilder((value,))
            }

            /// Sets the [`register_num` field](StoredRegisterVar#structfield.register_num) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn register_num_as_default(
                self,
            ) -> StoredRegisterVarBuilder<(::planus::DefaultValue,)> {
                self.register_num(::planus::DefaultValue)
            }
        }

        impl<T0> StoredRegisterVarBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredRegisterVar].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredRegisterVar>
            where
                Self: ::planus::WriteAsOffset<StoredRegisterVar>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u16, u16>>
            ::planus::WriteAs<::planus::Offset<StoredRegisterVar>>
            for StoredRegisterVarBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<StoredRegisterVar>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredRegisterVar> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u16, u16>>
            ::planus::WriteAsOptional<::planus::Offset<StoredRegisterVar>>
            for StoredRegisterVarBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<StoredRegisterVar>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredRegisterVar>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u16, u16>> ::planus::WriteAsOffset<StoredRegisterVar>
            for StoredRegisterVarBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredRegisterVar> {
                let (v0,) = &self.0;
                StoredRegisterVar::create(builder, v0)
            }
        }

        /// Reference to a deserialized [StoredRegisterVar].
        #[derive(Copy, Clone)]
        pub struct StoredRegisterVarRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredRegisterVarRef<'a> {
            /// Getter for the [`register_num` field](StoredRegisterVar#structfield.register_num).
            #[inline]
            pub fn register_num(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "StoredRegisterVar", "register_num")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for StoredRegisterVarRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredRegisterVarRef");
                f.field("register_num", &self.register_num());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredRegisterVarRef<'a>> for StoredRegisterVar {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredRegisterVarRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    register_num: ::core::convert::TryInto::try_into(value.register_num()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredRegisterVarRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredRegisterVarRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredRegisterVarRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredRegisterVar>> for StoredRegisterVar {
            type Value = ::planus::Offset<StoredRegisterVar>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredRegisterVar>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredRegisterVarRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredRegisterVarRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredVariable` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredVariable` in the file `../../../schema/schema/moor_program.fbs:75`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredVariable {
            /// The field `id` in the table `StoredVariable`
            pub id: u16,
            /// The field `scope_id` in the table `StoredVariable`
            pub scope_id: u16,
            /// The field `var_name` in the table `StoredVariable`
            pub var_name: self::StoredVarNameUnion,
        }

        impl StoredVariable {
            /// Creates a [StoredVariableBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredVariableBuilder<()> {
                StoredVariableBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_id: impl ::planus::WriteAsDefault<u16, u16>,
                field_scope_id: impl ::planus::WriteAsDefault<u16, u16>,
                field_var_name: impl ::planus::WriteAsUnion<self::StoredVarNameUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_id = field_id.prepare(builder, &0);
                let prepared_scope_id = field_scope_id.prepare(builder, &0);
                let prepared_var_name = field_var_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::StoredVarNameUnion>>(3);
                if prepared_id.is_some() {
                    table_writer.write_entry::<u16>(0);
                }
                if prepared_scope_id.is_some() {
                    table_writer.write_entry::<u16>(1);
                }
                table_writer.write_entry::<u8>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_var_name.offset());
                        if let ::core::option::Option::Some(prepared_id) = prepared_id {
                            object_writer.write::<_, _, 2>(&prepared_id);
                        }
                        if let ::core::option::Option::Some(prepared_scope_id) = prepared_scope_id {
                            object_writer.write::<_, _, 2>(&prepared_scope_id);
                        }
                        object_writer.write::<_, _, 1>(&prepared_var_name.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredVariable>> for StoredVariable {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredVariable> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredVariable>> for StoredVariable {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredVariable>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredVariable> for StoredVariable {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredVariable> {
                StoredVariable::create(builder, self.id, self.scope_id, &self.var_name)
            }
        }

        /// Builder for serializing an instance of the [StoredVariable] type.
        ///
        /// Can be created using the [StoredVariable::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredVariableBuilder<State>(State);

        impl StoredVariableBuilder<()> {
            /// Setter for the [`id` field](StoredVariable#structfield.id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id<T0>(self, value: T0) -> StoredVariableBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u16, u16>,
            {
                StoredVariableBuilder((value,))
            }

            /// Sets the [`id` field](StoredVariable#structfield.id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id_as_default(self) -> StoredVariableBuilder<(::planus::DefaultValue,)> {
                self.id(::planus::DefaultValue)
            }
        }

        impl<T0> StoredVariableBuilder<(T0,)> {
            /// Setter for the [`scope_id` field](StoredVariable#structfield.scope_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scope_id<T1>(self, value: T1) -> StoredVariableBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0,) = self.0;
                StoredVariableBuilder((v0, value))
            }

            /// Sets the [`scope_id` field](StoredVariable#structfield.scope_id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scope_id_as_default(
                self,
            ) -> StoredVariableBuilder<(T0, ::planus::DefaultValue)> {
                self.scope_id(::planus::DefaultValue)
            }
        }

        impl<T0, T1> StoredVariableBuilder<(T0, T1)> {
            /// Setter for the [`var_name` field](StoredVariable#structfield.var_name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn var_name<T2>(self, value: T2) -> StoredVariableBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsUnion<self::StoredVarNameUnion>,
            {
                let (v0, v1) = self.0;
                StoredVariableBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> StoredVariableBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredVariable].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredVariable>
            where
                Self: ::planus::WriteAsOffset<StoredVariable>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsUnion<self::StoredVarNameUnion>,
        > ::planus::WriteAs<::planus::Offset<StoredVariable>>
            for StoredVariableBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredVariable>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredVariable> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsUnion<self::StoredVarNameUnion>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredVariable>>
            for StoredVariableBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredVariable>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredVariable>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsUnion<self::StoredVarNameUnion>,
        > ::planus::WriteAsOffset<StoredVariable> for StoredVariableBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredVariable> {
                let (v0, v1, v2) = &self.0;
                StoredVariable::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [StoredVariable].
        #[derive(Copy, Clone)]
        pub struct StoredVariableRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredVariableRef<'a> {
            /// Getter for the [`id` field](StoredVariable#structfield.id).
            #[inline]
            pub fn id(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(self.0.access(0, "StoredVariable", "id")?.unwrap_or(0))
            }

            /// Getter for the [`scope_id` field](StoredVariable#structfield.scope_id).
            #[inline]
            pub fn scope_id(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0.access(1, "StoredVariable", "scope_id")?.unwrap_or(0),
                )
            }

            /// Getter for the [`var_name` field](StoredVariable#structfield.var_name).
            #[inline]
            pub fn var_name(&self) -> ::planus::Result<self::StoredVarNameUnionRef<'a>> {
                self.0
                    .access_union_required(2, "StoredVariable", "var_name")
            }
        }

        impl<'a> ::core::fmt::Debug for StoredVariableRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredVariableRef");
                f.field("id", &self.id());
                f.field("scope_id", &self.scope_id());
                f.field("var_name", &self.var_name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredVariableRef<'a>> for StoredVariable {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredVariableRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    id: ::core::convert::TryInto::try_into(value.id()?)?,
                    scope_id: ::core::convert::TryInto::try_into(value.scope_id()?)?,
                    var_name: ::core::convert::TryInto::try_into(value.var_name()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredVariableRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredVariableRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredVariableRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredVariable>> for StoredVariable {
            type Value = ::planus::Offset<StoredVariable>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredVariable>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredVariableRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredVariableRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredDecl` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredDecl` in the file `../../../schema/schema/moor_program.fbs:82`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredDecl {
            /// The field `decl_type` in the table `StoredDecl`
            pub decl_type: self::StoredDeclType,
            /// The field `identifier` in the table `StoredDecl`
            pub identifier: ::planus::alloc::boxed::Box<self::StoredVariable>,
            /// The field `depth` in the table `StoredDecl`
            pub depth: u64,
            /// The field `constant` in the table `StoredDecl`
            pub constant: bool,
            /// The field `scope_id` in the table `StoredDecl`
            pub scope_id: u16,
        }

        impl StoredDecl {
            /// Creates a [StoredDeclBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredDeclBuilder<()> {
                StoredDeclBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_decl_type: impl ::planus::WriteAsDefault<
                    self::StoredDeclType,
                    self::StoredDeclType,
                >,
                field_identifier: impl ::planus::WriteAs<::planus::Offset<self::StoredVariable>>,
                field_depth: impl ::planus::WriteAsDefault<u64, u64>,
                field_constant: impl ::planus::WriteAsDefault<bool, bool>,
                field_scope_id: impl ::planus::WriteAsDefault<u16, u16>,
            ) -> ::planus::Offset<Self> {
                let prepared_decl_type =
                    field_decl_type.prepare(builder, &self::StoredDeclType::Global);
                let prepared_identifier = field_identifier.prepare(builder);
                let prepared_depth = field_depth.prepare(builder, &0);
                let prepared_constant = field_constant.prepare(builder, &false);
                let prepared_scope_id = field_scope_id.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<14> =
                    ::core::default::Default::default();
                if prepared_depth.is_some() {
                    table_writer.write_entry::<u64>(2);
                }
                table_writer.write_entry::<::planus::Offset<self::StoredVariable>>(1);
                if prepared_scope_id.is_some() {
                    table_writer.write_entry::<u16>(4);
                }
                if prepared_decl_type.is_some() {
                    table_writer.write_entry::<self::StoredDeclType>(0);
                }
                if prepared_constant.is_some() {
                    table_writer.write_entry::<bool>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_depth) = prepared_depth {
                            object_writer.write::<_, _, 8>(&prepared_depth);
                        }
                        object_writer.write::<_, _, 4>(&prepared_identifier);
                        if let ::core::option::Option::Some(prepared_scope_id) = prepared_scope_id {
                            object_writer.write::<_, _, 2>(&prepared_scope_id);
                        }
                        if let ::core::option::Option::Some(prepared_decl_type) = prepared_decl_type
                        {
                            object_writer.write::<_, _, 1>(&prepared_decl_type);
                        }
                        if let ::core::option::Option::Some(prepared_constant) = prepared_constant {
                            object_writer.write::<_, _, 1>(&prepared_constant);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredDecl>> for StoredDecl {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredDecl> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredDecl>> for StoredDecl {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredDecl>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredDecl> for StoredDecl {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredDecl> {
                StoredDecl::create(
                    builder,
                    self.decl_type,
                    &self.identifier,
                    self.depth,
                    self.constant,
                    self.scope_id,
                )
            }
        }

        /// Builder for serializing an instance of the [StoredDecl] type.
        ///
        /// Can be created using the [StoredDecl::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredDeclBuilder<State>(State);

        impl StoredDeclBuilder<()> {
            /// Setter for the [`decl_type` field](StoredDecl#structfield.decl_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn decl_type<T0>(self, value: T0) -> StoredDeclBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<self::StoredDeclType, self::StoredDeclType>,
            {
                StoredDeclBuilder((value,))
            }

            /// Sets the [`decl_type` field](StoredDecl#structfield.decl_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn decl_type_as_default(self) -> StoredDeclBuilder<(::planus::DefaultValue,)> {
                self.decl_type(::planus::DefaultValue)
            }
        }

        impl<T0> StoredDeclBuilder<(T0,)> {
            /// Setter for the [`identifier` field](StoredDecl#structfield.identifier).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn identifier<T1>(self, value: T1) -> StoredDeclBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::StoredVariable>>,
            {
                let (v0,) = self.0;
                StoredDeclBuilder((v0, value))
            }
        }

        impl<T0, T1> StoredDeclBuilder<(T0, T1)> {
            /// Setter for the [`depth` field](StoredDecl#structfield.depth).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn depth<T2>(self, value: T2) -> StoredDeclBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1) = self.0;
                StoredDeclBuilder((v0, v1, value))
            }

            /// Sets the [`depth` field](StoredDecl#structfield.depth) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn depth_as_default(self) -> StoredDeclBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.depth(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> StoredDeclBuilder<(T0, T1, T2)> {
            /// Setter for the [`constant` field](StoredDecl#structfield.constant).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn constant<T3>(self, value: T3) -> StoredDeclBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2) = self.0;
                StoredDeclBuilder((v0, v1, v2, value))
            }

            /// Sets the [`constant` field](StoredDecl#structfield.constant) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn constant_as_default(
                self,
            ) -> StoredDeclBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.constant(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> StoredDeclBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`scope_id` field](StoredDecl#structfield.scope_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scope_id<T4>(self, value: T4) -> StoredDeclBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1, v2, v3) = self.0;
                StoredDeclBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`scope_id` field](StoredDecl#structfield.scope_id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scope_id_as_default(
                self,
            ) -> StoredDeclBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.scope_id(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> StoredDeclBuilder<(T0, T1, T2, T3, T4)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredDecl].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredDecl>
            where
                Self: ::planus::WriteAsOffset<StoredDecl>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::StoredDeclType, self::StoredDeclType>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredVariable>>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<bool, bool>,
            T4: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAs<::planus::Offset<StoredDecl>>
            for StoredDeclBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<StoredDecl>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredDecl> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::StoredDeclType, self::StoredDeclType>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredVariable>>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<bool, bool>,
            T4: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredDecl>>
            for StoredDeclBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<StoredDecl>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredDecl>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::StoredDeclType, self::StoredDeclType>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredVariable>>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<bool, bool>,
            T4: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOffset<StoredDecl> for StoredDeclBuilder<(T0, T1, T2, T3, T4)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredDecl> {
                let (v0, v1, v2, v3, v4) = &self.0;
                StoredDecl::create(builder, v0, v1, v2, v3, v4)
            }
        }

        /// Reference to a deserialized [StoredDecl].
        #[derive(Copy, Clone)]
        pub struct StoredDeclRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredDeclRef<'a> {
            /// Getter for the [`decl_type` field](StoredDecl#structfield.decl_type).
            #[inline]
            pub fn decl_type(&self) -> ::planus::Result<self::StoredDeclType> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "StoredDecl", "decl_type")?
                        .unwrap_or(self::StoredDeclType::Global),
                )
            }

            /// Getter for the [`identifier` field](StoredDecl#structfield.identifier).
            #[inline]
            pub fn identifier(&self) -> ::planus::Result<self::StoredVariableRef<'a>> {
                self.0.access_required(1, "StoredDecl", "identifier")
            }

            /// Getter for the [`depth` field](StoredDecl#structfield.depth).
            #[inline]
            pub fn depth(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(2, "StoredDecl", "depth")?.unwrap_or(0))
            }

            /// Getter for the [`constant` field](StoredDecl#structfield.constant).
            #[inline]
            pub fn constant(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0.access(3, "StoredDecl", "constant")?.unwrap_or(false),
                )
            }

            /// Getter for the [`scope_id` field](StoredDecl#structfield.scope_id).
            #[inline]
            pub fn scope_id(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(self.0.access(4, "StoredDecl", "scope_id")?.unwrap_or(0))
            }
        }

        impl<'a> ::core::fmt::Debug for StoredDeclRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredDeclRef");
                f.field("decl_type", &self.decl_type());
                f.field("identifier", &self.identifier());
                f.field("depth", &self.depth());
                f.field("constant", &self.constant());
                f.field("scope_id", &self.scope_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredDeclRef<'a>> for StoredDecl {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredDeclRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    decl_type: ::core::convert::TryInto::try_into(value.decl_type()?)?,
                    identifier: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.identifier()?)?,
                    ),
                    depth: ::core::convert::TryInto::try_into(value.depth()?)?,
                    constant: ::core::convert::TryInto::try_into(value.constant()?)?,
                    scope_id: ::core::convert::TryInto::try_into(value.scope_id()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredDeclRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredDeclRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredDeclRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredDecl>> for StoredDecl {
            type Value = ::planus::Offset<StoredDecl>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredDecl>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredDeclRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredDeclRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredNameDeclPair` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredNameDeclPair` in the file `../../../schema/schema/moor_program.fbs:91`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredNameDeclPair {
            /// The field `name` in the table `StoredNameDeclPair`
            pub name: ::planus::alloc::boxed::Box<self::StoredName>,
            /// The field `decl` in the table `StoredNameDeclPair`
            pub decl: ::planus::alloc::boxed::Box<self::StoredDecl>,
        }

        impl StoredNameDeclPair {
            /// Creates a [StoredNameDeclPairBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredNameDeclPairBuilder<()> {
                StoredNameDeclPairBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_name: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
                field_decl: impl ::planus::WriteAs<::planus::Offset<self::StoredDecl>>,
            ) -> ::planus::Offset<Self> {
                let prepared_name = field_name.prepare(builder);
                let prepared_decl = field_decl.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(0);
                table_writer.write_entry::<::planus::Offset<self::StoredDecl>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_name);
                        object_writer.write::<_, _, 4>(&prepared_decl);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredNameDeclPair>> for StoredNameDeclPair {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredNameDeclPair> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredNameDeclPair>> for StoredNameDeclPair {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredNameDeclPair>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredNameDeclPair> for StoredNameDeclPair {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredNameDeclPair> {
                StoredNameDeclPair::create(builder, &self.name, &self.decl)
            }
        }

        /// Builder for serializing an instance of the [StoredNameDeclPair] type.
        ///
        /// Can be created using the [StoredNameDeclPair::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredNameDeclPairBuilder<State>(State);

        impl StoredNameDeclPairBuilder<()> {
            /// Setter for the [`name` field](StoredNameDeclPair#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T0>(self, value: T0) -> StoredNameDeclPairBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                StoredNameDeclPairBuilder((value,))
            }
        }

        impl<T0> StoredNameDeclPairBuilder<(T0,)> {
            /// Setter for the [`decl` field](StoredNameDeclPair#structfield.decl).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn decl<T1>(self, value: T1) -> StoredNameDeclPairBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::StoredDecl>>,
            {
                let (v0,) = self.0;
                StoredNameDeclPairBuilder((v0, value))
            }
        }

        impl<T0, T1> StoredNameDeclPairBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredNameDeclPair].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredNameDeclPair>
            where
                Self: ::planus::WriteAsOffset<StoredNameDeclPair>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredDecl>>,
        > ::planus::WriteAs<::planus::Offset<StoredNameDeclPair>>
            for StoredNameDeclPairBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<StoredNameDeclPair>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredNameDeclPair> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredDecl>>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredNameDeclPair>>
            for StoredNameDeclPairBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<StoredNameDeclPair>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredNameDeclPair>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredDecl>>,
        > ::planus::WriteAsOffset<StoredNameDeclPair> for StoredNameDeclPairBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredNameDeclPair> {
                let (v0, v1) = &self.0;
                StoredNameDeclPair::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [StoredNameDeclPair].
        #[derive(Copy, Clone)]
        pub struct StoredNameDeclPairRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredNameDeclPairRef<'a> {
            /// Getter for the [`name` field](StoredNameDeclPair#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0.access_required(0, "StoredNameDeclPair", "name")
            }

            /// Getter for the [`decl` field](StoredNameDeclPair#structfield.decl).
            #[inline]
            pub fn decl(&self) -> ::planus::Result<self::StoredDeclRef<'a>> {
                self.0.access_required(1, "StoredNameDeclPair", "decl")
            }
        }

        impl<'a> ::core::fmt::Debug for StoredNameDeclPairRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredNameDeclPairRef");
                f.field("name", &self.name());
                f.field("decl", &self.decl());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredNameDeclPairRef<'a>> for StoredNameDeclPair {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredNameDeclPairRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.name()?,
                    )?),
                    decl: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.decl()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredNameDeclPairRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredNameDeclPairRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredNameDeclPairRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredNameDeclPair>> for StoredNameDeclPair {
            type Value = ::planus::Offset<StoredNameDeclPair>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredNameDeclPair>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredNameDeclPairRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredNameDeclPairRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredNames` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredNames` in the file `../../../schema/schema/moor_program.fbs:96`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredNames {
            /// The field `global_width` in the table `StoredNames`
            pub global_width: u64,
            /// The field `decls` in the table `StoredNames`
            pub decls: ::planus::alloc::vec::Vec<self::StoredNameDeclPair>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredNames {
            fn default() -> Self {
                Self {
                    global_width: 0,
                    decls: ::core::default::Default::default(),
                }
            }
        }

        impl StoredNames {
            /// Creates a [StoredNamesBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredNamesBuilder<()> {
                StoredNamesBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_global_width: impl ::planus::WriteAsDefault<u64, u64>,
                field_decls: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::StoredNameDeclPair>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_global_width = field_global_width.prepare(builder, &0);
                let prepared_decls = field_decls.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_global_width.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::StoredNameDeclPair>]>>(
                        1,
                    );

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_global_width) =
                            prepared_global_width
                        {
                            object_writer.write::<_, _, 8>(&prepared_global_width);
                        }
                        object_writer.write::<_, _, 4>(&prepared_decls);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredNames>> for StoredNames {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredNames> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredNames>> for StoredNames {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredNames>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredNames> for StoredNames {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredNames> {
                StoredNames::create(builder, self.global_width, &self.decls)
            }
        }

        /// Builder for serializing an instance of the [StoredNames] type.
        ///
        /// Can be created using the [StoredNames::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredNamesBuilder<State>(State);

        impl StoredNamesBuilder<()> {
            /// Setter for the [`global_width` field](StoredNames#structfield.global_width).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn global_width<T0>(self, value: T0) -> StoredNamesBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                StoredNamesBuilder((value,))
            }

            /// Sets the [`global_width` field](StoredNames#structfield.global_width) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn global_width_as_default(self) -> StoredNamesBuilder<(::planus::DefaultValue,)> {
                self.global_width(::planus::DefaultValue)
            }
        }

        impl<T0> StoredNamesBuilder<(T0,)> {
            /// Setter for the [`decls` field](StoredNames#structfield.decls).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn decls<T1>(self, value: T1) -> StoredNamesBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::StoredNameDeclPair>]>,
                    >,
            {
                let (v0,) = self.0;
                StoredNamesBuilder((v0, value))
            }
        }

        impl<T0, T1> StoredNamesBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredNames].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredNames>
            where
                Self: ::planus::WriteAsOffset<StoredNames>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredNameDeclPair>]>>,
        > ::planus::WriteAs<::planus::Offset<StoredNames>> for StoredNamesBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<StoredNames>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredNames> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredNameDeclPair>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredNames>>
            for StoredNamesBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<StoredNames>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredNames>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredNameDeclPair>]>>,
        > ::planus::WriteAsOffset<StoredNames> for StoredNamesBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredNames> {
                let (v0, v1) = &self.0;
                StoredNames::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [StoredNames].
        #[derive(Copy, Clone)]
        pub struct StoredNamesRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredNamesRef<'a> {
            /// Getter for the [`global_width` field](StoredNames#structfield.global_width).
            #[inline]
            pub fn global_width(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "StoredNames", "global_width")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`decls` field](StoredNames#structfield.decls).
            #[inline]
            pub fn decls(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::StoredNameDeclPairRef<'a>>>,
            > {
                self.0.access_required(1, "StoredNames", "decls")
            }
        }

        impl<'a> ::core::fmt::Debug for StoredNamesRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredNamesRef");
                f.field("global_width", &self.global_width());
                f.field("decls", &self.decls());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredNamesRef<'a>> for StoredNames {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredNamesRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    global_width: ::core::convert::TryInto::try_into(value.global_width()?)?,
                    decls: value.decls()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredNamesRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredNamesRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredNamesRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredNames>> for StoredNames {
            type Value = ::planus::Offset<StoredNames>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredNames>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredNamesRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredNamesRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `StoredScatterLabelUnion` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Union `StoredScatterLabelUnion` in the file `../../../schema/schema/moor_program.fbs:105`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum StoredScatterLabelUnion {
            /// The variant of type `StoredScatterRequired` in the union `StoredScatterLabelUnion`
            StoredScatterRequired(::planus::alloc::boxed::Box<self::StoredScatterRequired>),

            /// The variant of type `StoredScatterOptional` in the union `StoredScatterLabelUnion`
            StoredScatterOptional(::planus::alloc::boxed::Box<self::StoredScatterOptional>),

            /// The variant of type `StoredScatterRest` in the union `StoredScatterLabelUnion`
            StoredScatterRest(::planus::alloc::boxed::Box<self::StoredScatterRest>),
        }

        impl StoredScatterLabelUnion {
            /// Creates a [StoredScatterLabelUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredScatterLabelUnionBuilder<::planus::Uninitialized> {
                StoredScatterLabelUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_stored_scatter_required(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::StoredScatterRequired>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_stored_scatter_optional(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::StoredScatterOptional>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_stored_scatter_rest(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::StoredScatterRest>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<StoredScatterLabelUnion> for StoredScatterLabelUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::StoredScatterRequired(value) => {
                        Self::create_stored_scatter_required(builder, value)
                    }
                    Self::StoredScatterOptional(value) => {
                        Self::create_stored_scatter_optional(builder, value)
                    }
                    Self::StoredScatterRest(value) => {
                        Self::create_stored_scatter_rest(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<StoredScatterLabelUnion> for StoredScatterLabelUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [StoredScatterLabelUnion] type.
        ///
        /// Can be created using the [StoredScatterLabelUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredScatterLabelUnionBuilder<T>(T);

        impl StoredScatterLabelUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`StoredScatterRequired` variant](StoredScatterLabelUnion#variant.StoredScatterRequired).
            #[inline]
            pub fn stored_scatter_required<T>(
                self,
                value: T,
            ) -> StoredScatterLabelUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::StoredScatterRequired>,
            {
                StoredScatterLabelUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`StoredScatterOptional` variant](StoredScatterLabelUnion#variant.StoredScatterOptional).
            #[inline]
            pub fn stored_scatter_optional<T>(
                self,
                value: T,
            ) -> StoredScatterLabelUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::StoredScatterOptional>,
            {
                StoredScatterLabelUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`StoredScatterRest` variant](StoredScatterLabelUnion#variant.StoredScatterRest).
            #[inline]
            pub fn stored_scatter_rest<T>(
                self,
                value: T,
            ) -> StoredScatterLabelUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::StoredScatterRest>,
            {
                StoredScatterLabelUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> StoredScatterLabelUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [StoredScatterLabelUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<StoredScatterLabelUnion>
            where
                Self: ::planus::WriteAsUnion<StoredScatterLabelUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<StoredScatterLabelUnion>
            for StoredScatterLabelUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::StoredScatterRequired>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<StoredScatterLabelUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<StoredScatterLabelUnion>
            for StoredScatterLabelUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::StoredScatterRequired>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<StoredScatterLabelUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<StoredScatterLabelUnion>
            for StoredScatterLabelUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::StoredScatterOptional>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<StoredScatterLabelUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<StoredScatterLabelUnion>
            for StoredScatterLabelUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::StoredScatterOptional>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<StoredScatterLabelUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<StoredScatterLabelUnion>
            for StoredScatterLabelUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::StoredScatterRest>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<StoredScatterLabelUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<StoredScatterLabelUnion>
            for StoredScatterLabelUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::StoredScatterRest>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<StoredScatterLabelUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [StoredScatterLabelUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum StoredScatterLabelUnionRef<'a> {
            StoredScatterRequired(self::StoredScatterRequiredRef<'a>),
            StoredScatterOptional(self::StoredScatterOptionalRef<'a>),
            StoredScatterRest(self::StoredScatterRestRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<StoredScatterLabelUnionRef<'a>> for StoredScatterLabelUnion {
            type Error = ::planus::Error;

            fn try_from(value: StoredScatterLabelUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    StoredScatterLabelUnionRef::StoredScatterRequired(value) => {
                        Self::StoredScatterRequired(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    StoredScatterLabelUnionRef::StoredScatterOptional(value) => {
                        Self::StoredScatterOptional(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    StoredScatterLabelUnionRef::StoredScatterRest(value) => {
                        Self::StoredScatterRest(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for StoredScatterLabelUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::StoredScatterRequired(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::StoredScatterOptional(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::StoredScatterRest(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for StoredScatterLabelUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[StoredScatterLabelUnionRef]";
        }

        /// The table `StoredScatterRequired` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredScatterRequired` in the file `../../../schema/schema/moor_program.fbs:111`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredScatterRequired {
            /// The field `name` in the table `StoredScatterRequired`
            pub name: ::planus::alloc::boxed::Box<self::StoredName>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredScatterRequired {
            fn default() -> Self {
                Self {
                    name: ::core::default::Default::default(),
                }
            }
        }

        impl StoredScatterRequired {
            /// Creates a [StoredScatterRequiredBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredScatterRequiredBuilder<()> {
                StoredScatterRequiredBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_name: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            ) -> ::planus::Offset<Self> {
                let prepared_name = field_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredScatterRequired>> for StoredScatterRequired {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterRequired> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredScatterRequired>> for StoredScatterRequired {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredScatterRequired>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredScatterRequired> for StoredScatterRequired {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterRequired> {
                StoredScatterRequired::create(builder, &self.name)
            }
        }

        /// Builder for serializing an instance of the [StoredScatterRequired] type.
        ///
        /// Can be created using the [StoredScatterRequired::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredScatterRequiredBuilder<State>(State);

        impl StoredScatterRequiredBuilder<()> {
            /// Setter for the [`name` field](StoredScatterRequired#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T0>(self, value: T0) -> StoredScatterRequiredBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                StoredScatterRequiredBuilder((value,))
            }
        }

        impl<T0> StoredScatterRequiredBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredScatterRequired].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterRequired>
            where
                Self: ::planus::WriteAsOffset<StoredScatterRequired>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>>
            ::planus::WriteAs<::planus::Offset<StoredScatterRequired>>
            for StoredScatterRequiredBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<StoredScatterRequired>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterRequired> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>>
            ::planus::WriteAsOptional<::planus::Offset<StoredScatterRequired>>
            for StoredScatterRequiredBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<StoredScatterRequired>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredScatterRequired>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>>
            ::planus::WriteAsOffset<StoredScatterRequired> for StoredScatterRequiredBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterRequired> {
                let (v0,) = &self.0;
                StoredScatterRequired::create(builder, v0)
            }
        }

        /// Reference to a deserialized [StoredScatterRequired].
        #[derive(Copy, Clone)]
        pub struct StoredScatterRequiredRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredScatterRequiredRef<'a> {
            /// Getter for the [`name` field](StoredScatterRequired#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0.access_required(0, "StoredScatterRequired", "name")
            }
        }

        impl<'a> ::core::fmt::Debug for StoredScatterRequiredRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredScatterRequiredRef");
                f.field("name", &self.name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredScatterRequiredRef<'a>> for StoredScatterRequired {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredScatterRequiredRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.name()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredScatterRequiredRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredScatterRequiredRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredScatterRequiredRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredScatterRequired>>
            for StoredScatterRequired
        {
            type Value = ::planus::Offset<StoredScatterRequired>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredScatterRequired>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredScatterRequiredRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredScatterRequiredRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredScatterOptional` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredScatterOptional` in the file `../../../schema/schema/moor_program.fbs:115`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredScatterOptional {
            /// The field `name` in the table `StoredScatterOptional`
            pub name: ::planus::alloc::boxed::Box<self::StoredName>,
            /// The field `default_label` in the table `StoredScatterOptional`
            pub default_label: u16,
            /// The field `has_default` in the table `StoredScatterOptional`
            pub has_default: bool,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredScatterOptional {
            fn default() -> Self {
                Self {
                    name: ::core::default::Default::default(),
                    default_label: 0,
                    has_default: false,
                }
            }
        }

        impl StoredScatterOptional {
            /// Creates a [StoredScatterOptionalBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredScatterOptionalBuilder<()> {
                StoredScatterOptionalBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_name: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
                field_default_label: impl ::planus::WriteAsDefault<u16, u16>,
                field_has_default: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_name = field_name.prepare(builder);
                let prepared_default_label = field_default_label.prepare(builder, &0);
                let prepared_has_default = field_has_default.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(0);
                if prepared_default_label.is_some() {
                    table_writer.write_entry::<u16>(1);
                }
                if prepared_has_default.is_some() {
                    table_writer.write_entry::<bool>(2);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_name);
                        if let ::core::option::Option::Some(prepared_default_label) =
                            prepared_default_label
                        {
                            object_writer.write::<_, _, 2>(&prepared_default_label);
                        }
                        if let ::core::option::Option::Some(prepared_has_default) =
                            prepared_has_default
                        {
                            object_writer.write::<_, _, 1>(&prepared_has_default);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredScatterOptional>> for StoredScatterOptional {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterOptional> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredScatterOptional>> for StoredScatterOptional {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredScatterOptional>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredScatterOptional> for StoredScatterOptional {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterOptional> {
                StoredScatterOptional::create(
                    builder,
                    &self.name,
                    self.default_label,
                    self.has_default,
                )
            }
        }

        /// Builder for serializing an instance of the [StoredScatterOptional] type.
        ///
        /// Can be created using the [StoredScatterOptional::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredScatterOptionalBuilder<State>(State);

        impl StoredScatterOptionalBuilder<()> {
            /// Setter for the [`name` field](StoredScatterOptional#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T0>(self, value: T0) -> StoredScatterOptionalBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                StoredScatterOptionalBuilder((value,))
            }
        }

        impl<T0> StoredScatterOptionalBuilder<(T0,)> {
            /// Setter for the [`default_label` field](StoredScatterOptional#structfield.default_label).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn default_label<T1>(self, value: T1) -> StoredScatterOptionalBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0,) = self.0;
                StoredScatterOptionalBuilder((v0, value))
            }

            /// Sets the [`default_label` field](StoredScatterOptional#structfield.default_label) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn default_label_as_default(
                self,
            ) -> StoredScatterOptionalBuilder<(T0, ::planus::DefaultValue)> {
                self.default_label(::planus::DefaultValue)
            }
        }

        impl<T0, T1> StoredScatterOptionalBuilder<(T0, T1)> {
            /// Setter for the [`has_default` field](StoredScatterOptional#structfield.has_default).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn has_default<T2>(self, value: T2) -> StoredScatterOptionalBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1) = self.0;
                StoredScatterOptionalBuilder((v0, v1, value))
            }

            /// Sets the [`has_default` field](StoredScatterOptional#structfield.has_default) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn has_default_as_default(
                self,
            ) -> StoredScatterOptionalBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.has_default(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> StoredScatterOptionalBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredScatterOptional].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterOptional>
            where
                Self: ::planus::WriteAsOffset<StoredScatterOptional>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAs<::planus::Offset<StoredScatterOptional>>
            for StoredScatterOptionalBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredScatterOptional>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterOptional> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredScatterOptional>>
            for StoredScatterOptionalBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredScatterOptional>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredScatterOptional>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOffset<StoredScatterOptional>
            for StoredScatterOptionalBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterOptional> {
                let (v0, v1, v2) = &self.0;
                StoredScatterOptional::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [StoredScatterOptional].
        #[derive(Copy, Clone)]
        pub struct StoredScatterOptionalRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredScatterOptionalRef<'a> {
            /// Getter for the [`name` field](StoredScatterOptional#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0.access_required(0, "StoredScatterOptional", "name")
            }

            /// Getter for the [`default_label` field](StoredScatterOptional#structfield.default_label).
            #[inline]
            pub fn default_label(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "StoredScatterOptional", "default_label")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`has_default` field](StoredScatterOptional#structfield.has_default).
            #[inline]
            pub fn has_default(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "StoredScatterOptional", "has_default")?
                        .unwrap_or(false),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for StoredScatterOptionalRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredScatterOptionalRef");
                f.field("name", &self.name());
                f.field("default_label", &self.default_label());
                f.field("has_default", &self.has_default());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredScatterOptionalRef<'a>> for StoredScatterOptional {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredScatterOptionalRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.name()?,
                    )?),
                    default_label: ::core::convert::TryInto::try_into(value.default_label()?)?,
                    has_default: ::core::convert::TryInto::try_into(value.has_default()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredScatterOptionalRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredScatterOptionalRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredScatterOptionalRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredScatterOptional>>
            for StoredScatterOptional
        {
            type Value = ::planus::Offset<StoredScatterOptional>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredScatterOptional>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredScatterOptionalRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredScatterOptionalRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredScatterRest` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredScatterRest` in the file `../../../schema/schema/moor_program.fbs:121`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredScatterRest {
            /// The field `name` in the table `StoredScatterRest`
            pub name: ::planus::alloc::boxed::Box<self::StoredName>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredScatterRest {
            fn default() -> Self {
                Self {
                    name: ::core::default::Default::default(),
                }
            }
        }

        impl StoredScatterRest {
            /// Creates a [StoredScatterRestBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredScatterRestBuilder<()> {
                StoredScatterRestBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_name: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            ) -> ::planus::Offset<Self> {
                let prepared_name = field_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredScatterRest>> for StoredScatterRest {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterRest> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredScatterRest>> for StoredScatterRest {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredScatterRest>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredScatterRest> for StoredScatterRest {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterRest> {
                StoredScatterRest::create(builder, &self.name)
            }
        }

        /// Builder for serializing an instance of the [StoredScatterRest] type.
        ///
        /// Can be created using the [StoredScatterRest::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredScatterRestBuilder<State>(State);

        impl StoredScatterRestBuilder<()> {
            /// Setter for the [`name` field](StoredScatterRest#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T0>(self, value: T0) -> StoredScatterRestBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                StoredScatterRestBuilder((value,))
            }
        }

        impl<T0> StoredScatterRestBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredScatterRest].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterRest>
            where
                Self: ::planus::WriteAsOffset<StoredScatterRest>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>>
            ::planus::WriteAs<::planus::Offset<StoredScatterRest>>
            for StoredScatterRestBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<StoredScatterRest>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterRest> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>>
            ::planus::WriteAsOptional<::planus::Offset<StoredScatterRest>>
            for StoredScatterRestBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<StoredScatterRest>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredScatterRest>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>>
            ::planus::WriteAsOffset<StoredScatterRest> for StoredScatterRestBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterRest> {
                let (v0,) = &self.0;
                StoredScatterRest::create(builder, v0)
            }
        }

        /// Reference to a deserialized [StoredScatterRest].
        #[derive(Copy, Clone)]
        pub struct StoredScatterRestRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredScatterRestRef<'a> {
            /// Getter for the [`name` field](StoredScatterRest#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0.access_required(0, "StoredScatterRest", "name")
            }
        }

        impl<'a> ::core::fmt::Debug for StoredScatterRestRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredScatterRestRef");
                f.field("name", &self.name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredScatterRestRef<'a>> for StoredScatterRest {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredScatterRestRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.name()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredScatterRestRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredScatterRestRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredScatterRestRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredScatterRest>> for StoredScatterRest {
            type Value = ::planus::Offset<StoredScatterRest>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredScatterRest>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredScatterRestRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredScatterRestRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredScatterLabel` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredScatterLabel` in the file `../../../schema/schema/moor_program.fbs:125`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredScatterLabel {
            /// The field `label` in the table `StoredScatterLabel`
            pub label: self::StoredScatterLabelUnion,
        }

        impl StoredScatterLabel {
            /// Creates a [StoredScatterLabelBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredScatterLabelBuilder<()> {
                StoredScatterLabelBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_label: impl ::planus::WriteAsUnion<self::StoredScatterLabelUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_label = field_label.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::StoredScatterLabelUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_label.offset());
                        object_writer.write::<_, _, 1>(&prepared_label.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredScatterLabel>> for StoredScatterLabel {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterLabel> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredScatterLabel>> for StoredScatterLabel {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredScatterLabel>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredScatterLabel> for StoredScatterLabel {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterLabel> {
                StoredScatterLabel::create(builder, &self.label)
            }
        }

        /// Builder for serializing an instance of the [StoredScatterLabel] type.
        ///
        /// Can be created using the [StoredScatterLabel::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredScatterLabelBuilder<State>(State);

        impl StoredScatterLabelBuilder<()> {
            /// Setter for the [`label` field](StoredScatterLabel#structfield.label).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn label<T0>(self, value: T0) -> StoredScatterLabelBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::StoredScatterLabelUnion>,
            {
                StoredScatterLabelBuilder((value,))
            }
        }

        impl<T0> StoredScatterLabelBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredScatterLabel].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterLabel>
            where
                Self: ::planus::WriteAsOffset<StoredScatterLabel>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::StoredScatterLabelUnion>>
            ::planus::WriteAs<::planus::Offset<StoredScatterLabel>>
            for StoredScatterLabelBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<StoredScatterLabel>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterLabel> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::StoredScatterLabelUnion>>
            ::planus::WriteAsOptional<::planus::Offset<StoredScatterLabel>>
            for StoredScatterLabelBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<StoredScatterLabel>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredScatterLabel>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::StoredScatterLabelUnion>>
            ::planus::WriteAsOffset<StoredScatterLabel> for StoredScatterLabelBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterLabel> {
                let (v0,) = &self.0;
                StoredScatterLabel::create(builder, v0)
            }
        }

        /// Reference to a deserialized [StoredScatterLabel].
        #[derive(Copy, Clone)]
        pub struct StoredScatterLabelRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredScatterLabelRef<'a> {
            /// Getter for the [`label` field](StoredScatterLabel#structfield.label).
            #[inline]
            pub fn label(&self) -> ::planus::Result<self::StoredScatterLabelUnionRef<'a>> {
                self.0
                    .access_union_required(0, "StoredScatterLabel", "label")
            }
        }

        impl<'a> ::core::fmt::Debug for StoredScatterLabelRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredScatterLabelRef");
                f.field("label", &self.label());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredScatterLabelRef<'a>> for StoredScatterLabel {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredScatterLabelRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    label: ::core::convert::TryInto::try_into(value.label()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredScatterLabelRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredScatterLabelRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredScatterLabelRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredScatterLabel>> for StoredScatterLabel {
            type Value = ::planus::Offset<StoredScatterLabel>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredScatterLabel>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredScatterLabelRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredScatterLabelRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredScatterArgs` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredScatterArgs` in the file `../../../schema/schema/moor_program.fbs:129`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredScatterArgs {
            /// The field `labels` in the table `StoredScatterArgs`
            pub labels: ::planus::alloc::vec::Vec<self::StoredScatterLabel>,
            /// The field `done` in the table `StoredScatterArgs`
            pub done: u16,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredScatterArgs {
            fn default() -> Self {
                Self {
                    labels: ::core::default::Default::default(),
                    done: 0,
                }
            }
        }

        impl StoredScatterArgs {
            /// Creates a [StoredScatterArgsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredScatterArgsBuilder<()> {
                StoredScatterArgsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_labels: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::StoredScatterLabel>]>,
                >,
                field_done: impl ::planus::WriteAsDefault<u16, u16>,
            ) -> ::planus::Offset<Self> {
                let prepared_labels = field_labels.prepare(builder);
                let prepared_done = field_done.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::StoredScatterLabel>]>>(
                        0,
                    );
                if prepared_done.is_some() {
                    table_writer.write_entry::<u16>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_labels);
                        if let ::core::option::Option::Some(prepared_done) = prepared_done {
                            object_writer.write::<_, _, 2>(&prepared_done);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredScatterArgs>> for StoredScatterArgs {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterArgs> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredScatterArgs>> for StoredScatterArgs {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredScatterArgs>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredScatterArgs> for StoredScatterArgs {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterArgs> {
                StoredScatterArgs::create(builder, &self.labels, self.done)
            }
        }

        /// Builder for serializing an instance of the [StoredScatterArgs] type.
        ///
        /// Can be created using the [StoredScatterArgs::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredScatterArgsBuilder<State>(State);

        impl StoredScatterArgsBuilder<()> {
            /// Setter for the [`labels` field](StoredScatterArgs#structfield.labels).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn labels<T0>(self, value: T0) -> StoredScatterArgsBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::StoredScatterLabel>]>,
                    >,
            {
                StoredScatterArgsBuilder((value,))
            }
        }

        impl<T0> StoredScatterArgsBuilder<(T0,)> {
            /// Setter for the [`done` field](StoredScatterArgs#structfield.done).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn done<T1>(self, value: T1) -> StoredScatterArgsBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0,) = self.0;
                StoredScatterArgsBuilder((v0, value))
            }

            /// Sets the [`done` field](StoredScatterArgs#structfield.done) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn done_as_default(self) -> StoredScatterArgsBuilder<(T0, ::planus::DefaultValue)> {
                self.done(::planus::DefaultValue)
            }
        }

        impl<T0, T1> StoredScatterArgsBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredScatterArgs].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterArgs>
            where
                Self: ::planus::WriteAsOffset<StoredScatterArgs>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredScatterLabel>]>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAs<::planus::Offset<StoredScatterArgs>>
            for StoredScatterArgsBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<StoredScatterArgs>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterArgs> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredScatterLabel>]>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredScatterArgs>>
            for StoredScatterArgsBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<StoredScatterArgs>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredScatterArgs>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredScatterLabel>]>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOffset<StoredScatterArgs> for StoredScatterArgsBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredScatterArgs> {
                let (v0, v1) = &self.0;
                StoredScatterArgs::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [StoredScatterArgs].
        #[derive(Copy, Clone)]
        pub struct StoredScatterArgsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredScatterArgsRef<'a> {
            /// Getter for the [`labels` field](StoredScatterArgs#structfield.labels).
            #[inline]
            pub fn labels(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::StoredScatterLabelRef<'a>>>,
            > {
                self.0.access_required(0, "StoredScatterArgs", "labels")
            }

            /// Getter for the [`done` field](StoredScatterArgs#structfield.done).
            #[inline]
            pub fn done(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0.access(1, "StoredScatterArgs", "done")?.unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for StoredScatterArgsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredScatterArgsRef");
                f.field("labels", &self.labels());
                f.field("done", &self.done());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredScatterArgsRef<'a>> for StoredScatterArgs {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredScatterArgsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    labels: value.labels()?.to_vec_result()?,
                    done: ::core::convert::TryInto::try_into(value.done()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredScatterArgsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredScatterArgsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredScatterArgsRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredScatterArgs>> for StoredScatterArgs {
            type Value = ::planus::Offset<StoredScatterArgs>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredScatterArgs>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredScatterArgsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredScatterArgsRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredForSequenceOperand` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredForSequenceOperand` in the file `../../../schema/schema/moor_program.fbs:134`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredForSequenceOperand {
            /// The field `value_bind` in the table `StoredForSequenceOperand`
            pub value_bind: ::planus::alloc::boxed::Box<self::StoredName>,
            /// The field `key_bind` in the table `StoredForSequenceOperand`
            pub key_bind: ::core::option::Option<::planus::alloc::boxed::Box<self::StoredName>>,
            /// The field `end_label` in the table `StoredForSequenceOperand`
            pub end_label: u16,
            /// The field `environment_width` in the table `StoredForSequenceOperand`
            pub environment_width: u16,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredForSequenceOperand {
            fn default() -> Self {
                Self {
                    value_bind: ::core::default::Default::default(),
                    key_bind: ::core::default::Default::default(),
                    end_label: 0,
                    environment_width: 0,
                }
            }
        }

        impl StoredForSequenceOperand {
            /// Creates a [StoredForSequenceOperandBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredForSequenceOperandBuilder<()> {
                StoredForSequenceOperandBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value_bind: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
                field_key_bind: impl ::planus::WriteAsOptional<::planus::Offset<self::StoredName>>,
                field_end_label: impl ::planus::WriteAsDefault<u16, u16>,
                field_environment_width: impl ::planus::WriteAsDefault<u16, u16>,
            ) -> ::planus::Offset<Self> {
                let prepared_value_bind = field_value_bind.prepare(builder);
                let prepared_key_bind = field_key_bind.prepare(builder);
                let prepared_end_label = field_end_label.prepare(builder, &0);
                let prepared_environment_width = field_environment_width.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(0);
                if prepared_key_bind.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::StoredName>>(1);
                }
                if prepared_end_label.is_some() {
                    table_writer.write_entry::<u16>(2);
                }
                if prepared_environment_width.is_some() {
                    table_writer.write_entry::<u16>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_value_bind);
                        if let ::core::option::Option::Some(prepared_key_bind) = prepared_key_bind {
                            object_writer.write::<_, _, 4>(&prepared_key_bind);
                        }
                        if let ::core::option::Option::Some(prepared_end_label) = prepared_end_label
                        {
                            object_writer.write::<_, _, 2>(&prepared_end_label);
                        }
                        if let ::core::option::Option::Some(prepared_environment_width) =
                            prepared_environment_width
                        {
                            object_writer.write::<_, _, 2>(&prepared_environment_width);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredForSequenceOperand>> for StoredForSequenceOperand {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredForSequenceOperand> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredForSequenceOperand>>
            for StoredForSequenceOperand
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredForSequenceOperand>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredForSequenceOperand> for StoredForSequenceOperand {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredForSequenceOperand> {
                StoredForSequenceOperand::create(
                    builder,
                    &self.value_bind,
                    &self.key_bind,
                    self.end_label,
                    self.environment_width,
                )
            }
        }

        /// Builder for serializing an instance of the [StoredForSequenceOperand] type.
        ///
        /// Can be created using the [StoredForSequenceOperand::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredForSequenceOperandBuilder<State>(State);

        impl StoredForSequenceOperandBuilder<()> {
            /// Setter for the [`value_bind` field](StoredForSequenceOperand#structfield.value_bind).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value_bind<T0>(self, value: T0) -> StoredForSequenceOperandBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                StoredForSequenceOperandBuilder((value,))
            }
        }

        impl<T0> StoredForSequenceOperandBuilder<(T0,)> {
            /// Setter for the [`key_bind` field](StoredForSequenceOperand#structfield.key_bind).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn key_bind<T1>(self, value: T1) -> StoredForSequenceOperandBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsOptional<::planus::Offset<self::StoredName>>,
            {
                let (v0,) = self.0;
                StoredForSequenceOperandBuilder((v0, value))
            }

            /// Sets the [`key_bind` field](StoredForSequenceOperand#structfield.key_bind) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn key_bind_as_null(self) -> StoredForSequenceOperandBuilder<(T0, ())> {
                self.key_bind(())
            }
        }

        impl<T0, T1> StoredForSequenceOperandBuilder<(T0, T1)> {
            /// Setter for the [`end_label` field](StoredForSequenceOperand#structfield.end_label).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_label<T2>(self, value: T2) -> StoredForSequenceOperandBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1) = self.0;
                StoredForSequenceOperandBuilder((v0, v1, value))
            }

            /// Sets the [`end_label` field](StoredForSequenceOperand#structfield.end_label) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_label_as_default(
                self,
            ) -> StoredForSequenceOperandBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.end_label(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> StoredForSequenceOperandBuilder<(T0, T1, T2)> {
            /// Setter for the [`environment_width` field](StoredForSequenceOperand#structfield.environment_width).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn environment_width<T3>(
                self,
                value: T3,
            ) -> StoredForSequenceOperandBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1, v2) = self.0;
                StoredForSequenceOperandBuilder((v0, v1, v2, value))
            }

            /// Sets the [`environment_width` field](StoredForSequenceOperand#structfield.environment_width) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn environment_width_as_default(
                self,
            ) -> StoredForSequenceOperandBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.environment_width(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> StoredForSequenceOperandBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredForSequenceOperand].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredForSequenceOperand>
            where
                Self: ::planus::WriteAsOffset<StoredForSequenceOperand>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::StoredName>>,
            T2: ::planus::WriteAsDefault<u16, u16>,
            T3: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAs<::planus::Offset<StoredForSequenceOperand>>
            for StoredForSequenceOperandBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<StoredForSequenceOperand>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredForSequenceOperand> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::StoredName>>,
            T2: ::planus::WriteAsDefault<u16, u16>,
            T3: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredForSequenceOperand>>
            for StoredForSequenceOperandBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<StoredForSequenceOperand>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredForSequenceOperand>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::StoredName>>,
            T2: ::planus::WriteAsDefault<u16, u16>,
            T3: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOffset<StoredForSequenceOperand>
            for StoredForSequenceOperandBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredForSequenceOperand> {
                let (v0, v1, v2, v3) = &self.0;
                StoredForSequenceOperand::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [StoredForSequenceOperand].
        #[derive(Copy, Clone)]
        pub struct StoredForSequenceOperandRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredForSequenceOperandRef<'a> {
            /// Getter for the [`value_bind` field](StoredForSequenceOperand#structfield.value_bind).
            #[inline]
            pub fn value_bind(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0
                    .access_required(0, "StoredForSequenceOperand", "value_bind")
            }

            /// Getter for the [`key_bind` field](StoredForSequenceOperand#structfield.key_bind).
            #[inline]
            pub fn key_bind(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::StoredNameRef<'a>>> {
                self.0.access(1, "StoredForSequenceOperand", "key_bind")
            }

            /// Getter for the [`end_label` field](StoredForSequenceOperand#structfield.end_label).
            #[inline]
            pub fn end_label(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "StoredForSequenceOperand", "end_label")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`environment_width` field](StoredForSequenceOperand#structfield.environment_width).
            #[inline]
            pub fn environment_width(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "StoredForSequenceOperand", "environment_width")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for StoredForSequenceOperandRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredForSequenceOperandRef");
                f.field("value_bind", &self.value_bind());
                if let ::core::option::Option::Some(field_key_bind) = self.key_bind().transpose() {
                    f.field("key_bind", &field_key_bind);
                }
                f.field("end_label", &self.end_label());
                f.field("environment_width", &self.environment_width());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredForSequenceOperandRef<'a>> for StoredForSequenceOperand {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredForSequenceOperandRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value_bind: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.value_bind()?)?,
                    ),
                    key_bind: if let ::core::option::Option::Some(key_bind) = value.key_bind()? {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(key_bind)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                    end_label: ::core::convert::TryInto::try_into(value.end_label()?)?,
                    environment_width: ::core::convert::TryInto::try_into(
                        value.environment_width()?,
                    )?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredForSequenceOperandRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredForSequenceOperandRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredForSequenceOperandRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredForSequenceOperand>>
            for StoredForSequenceOperand
        {
            type Value = ::planus::Offset<StoredForSequenceOperand>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredForSequenceOperand>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredForSequenceOperandRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredForSequenceOperandRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `StoredForRangeOperand` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredForRangeOperand` in the file `../../../schema/schema/moor_program.fbs:141`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredForRangeOperand {
            /// The field `loop_variable` in the table `StoredForRangeOperand`
            pub loop_variable: ::planus::alloc::boxed::Box<self::StoredName>,
            /// The field `end_label` in the table `StoredForRangeOperand`
            pub end_label: u16,
            /// The field `environment_width` in the table `StoredForRangeOperand`
            pub environment_width: u16,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredForRangeOperand {
            fn default() -> Self {
                Self {
                    loop_variable: ::core::default::Default::default(),
                    end_label: 0,
                    environment_width: 0,
                }
            }
        }

        impl StoredForRangeOperand {
            /// Creates a [StoredForRangeOperandBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredForRangeOperandBuilder<()> {
                StoredForRangeOperandBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_loop_variable: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
                field_end_label: impl ::planus::WriteAsDefault<u16, u16>,
                field_environment_width: impl ::planus::WriteAsDefault<u16, u16>,
            ) -> ::planus::Offset<Self> {
                let prepared_loop_variable = field_loop_variable.prepare(builder);
                let prepared_end_label = field_end_label.prepare(builder, &0);
                let prepared_environment_width = field_environment_width.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(0);
                if prepared_end_label.is_some() {
                    table_writer.write_entry::<u16>(1);
                }
                if prepared_environment_width.is_some() {
                    table_writer.write_entry::<u16>(2);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_loop_variable);
                        if let ::core::option::Option::Some(prepared_end_label) = prepared_end_label
                        {
                            object_writer.write::<_, _, 2>(&prepared_end_label);
                        }
                        if let ::core::option::Option::Some(prepared_environment_width) =
                            prepared_environment_width
                        {
                            object_writer.write::<_, _, 2>(&prepared_environment_width);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredForRangeOperand>> for StoredForRangeOperand {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredForRangeOperand> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredForRangeOperand>> for StoredForRangeOperand {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredForRangeOperand>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredForRangeOperand> for StoredForRangeOperand {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredForRangeOperand> {
                StoredForRangeOperand::create(
                    builder,
                    &self.loop_variable,
                    self.end_label,
                    self.environment_width,
                )
            }
        }

        /// Builder for serializing an instance of the [StoredForRangeOperand] type.
        ///
        /// Can be created using the [StoredForRangeOperand::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredForRangeOperandBuilder<State>(State);

        impl StoredForRangeOperandBuilder<()> {
            /// Setter for the [`loop_variable` field](StoredForRangeOperand#structfield.loop_variable).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn loop_variable<T0>(self, value: T0) -> StoredForRangeOperandBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                StoredForRangeOperandBuilder((value,))
            }
        }

        impl<T0> StoredForRangeOperandBuilder<(T0,)> {
            /// Setter for the [`end_label` field](StoredForRangeOperand#structfield.end_label).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_label<T1>(self, value: T1) -> StoredForRangeOperandBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0,) = self.0;
                StoredForRangeOperandBuilder((v0, value))
            }

            /// Sets the [`end_label` field](StoredForRangeOperand#structfield.end_label) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_label_as_default(
                self,
            ) -> StoredForRangeOperandBuilder<(T0, ::planus::DefaultValue)> {
                self.end_label(::planus::DefaultValue)
            }
        }

        impl<T0, T1> StoredForRangeOperandBuilder<(T0, T1)> {
            /// Setter for the [`environment_width` field](StoredForRangeOperand#structfield.environment_width).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn environment_width<T2>(
                self,
                value: T2,
            ) -> StoredForRangeOperandBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1) = self.0;
                StoredForRangeOperandBuilder((v0, v1, value))
            }

            /// Sets the [`environment_width` field](StoredForRangeOperand#structfield.environment_width) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn environment_width_as_default(
                self,
            ) -> StoredForRangeOperandBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.environment_width(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> StoredForRangeOperandBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredForRangeOperand].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredForRangeOperand>
            where
                Self: ::planus::WriteAsOffset<StoredForRangeOperand>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAs<::planus::Offset<StoredForRangeOperand>>
            for StoredForRangeOperandBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredForRangeOperand>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredForRangeOperand> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredForRangeOperand>>
            for StoredForRangeOperandBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredForRangeOperand>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredForRangeOperand>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOffset<StoredForRangeOperand>
            for StoredForRangeOperandBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredForRangeOperand> {
                let (v0, v1, v2) = &self.0;
                StoredForRangeOperand::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [StoredForRangeOperand].
        #[derive(Copy, Clone)]
        pub struct StoredForRangeOperandRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredForRangeOperandRef<'a> {
            /// Getter for the [`loop_variable` field](StoredForRangeOperand#structfield.loop_variable).
            #[inline]
            pub fn loop_variable(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0
                    .access_required(0, "StoredForRangeOperand", "loop_variable")
            }

            /// Getter for the [`end_label` field](StoredForRangeOperand#structfield.end_label).
            #[inline]
            pub fn end_label(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "StoredForRangeOperand", "end_label")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`environment_width` field](StoredForRangeOperand#structfield.environment_width).
            #[inline]
            pub fn environment_width(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "StoredForRangeOperand", "environment_width")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for StoredForRangeOperandRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredForRangeOperandRef");
                f.field("loop_variable", &self.loop_variable());
                f.field("end_label", &self.end_label());
                f.field("environment_width", &self.environment_width());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredForRangeOperandRef<'a>> for StoredForRangeOperand {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredForRangeOperandRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    loop_variable: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.loop_variable()?)?,
                    ),
                    end_label: ::core::convert::TryInto::try_into(value.end_label()?)?,
                    environment_width: ::core::convert::TryInto::try_into(
                        value.environment_width()?,
                    )?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredForRangeOperandRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredForRangeOperandRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredForRangeOperandRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredForRangeOperand>>
            for StoredForRangeOperand
        {
            type Value = ::planus::Offset<StoredForRangeOperand>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredForRangeOperand>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredForRangeOperandRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredForRangeOperandRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredRangeComprehend` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredRangeComprehend` in the file `../../../schema/schema/moor_program.fbs:147`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredRangeComprehend {
            /// The field `position` in the table `StoredRangeComprehend`
            pub position: ::planus::alloc::boxed::Box<self::StoredName>,
            /// The field `end_of_range_register` in the table `StoredRangeComprehend`
            pub end_of_range_register: ::planus::alloc::boxed::Box<self::StoredName>,
            /// The field `end_label` in the table `StoredRangeComprehend`
            pub end_label: u16,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredRangeComprehend {
            fn default() -> Self {
                Self {
                    position: ::core::default::Default::default(),
                    end_of_range_register: ::core::default::Default::default(),
                    end_label: 0,
                }
            }
        }

        impl StoredRangeComprehend {
            /// Creates a [StoredRangeComprehendBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredRangeComprehendBuilder<()> {
                StoredRangeComprehendBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_position: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
                field_end_of_range_register: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
                field_end_label: impl ::planus::WriteAsDefault<u16, u16>,
            ) -> ::planus::Offset<Self> {
                let prepared_position = field_position.prepare(builder);
                let prepared_end_of_range_register = field_end_of_range_register.prepare(builder);
                let prepared_end_label = field_end_label.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(0);
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(1);
                if prepared_end_label.is_some() {
                    table_writer.write_entry::<u16>(2);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_position);
                        object_writer.write::<_, _, 4>(&prepared_end_of_range_register);
                        if let ::core::option::Option::Some(prepared_end_label) = prepared_end_label
                        {
                            object_writer.write::<_, _, 2>(&prepared_end_label);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredRangeComprehend>> for StoredRangeComprehend {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredRangeComprehend> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredRangeComprehend>> for StoredRangeComprehend {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredRangeComprehend>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredRangeComprehend> for StoredRangeComprehend {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredRangeComprehend> {
                StoredRangeComprehend::create(
                    builder,
                    &self.position,
                    &self.end_of_range_register,
                    self.end_label,
                )
            }
        }

        /// Builder for serializing an instance of the [StoredRangeComprehend] type.
        ///
        /// Can be created using the [StoredRangeComprehend::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredRangeComprehendBuilder<State>(State);

        impl StoredRangeComprehendBuilder<()> {
            /// Setter for the [`position` field](StoredRangeComprehend#structfield.position).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn position<T0>(self, value: T0) -> StoredRangeComprehendBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                StoredRangeComprehendBuilder((value,))
            }
        }

        impl<T0> StoredRangeComprehendBuilder<(T0,)> {
            /// Setter for the [`end_of_range_register` field](StoredRangeComprehend#structfield.end_of_range_register).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_of_range_register<T1>(
                self,
                value: T1,
            ) -> StoredRangeComprehendBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                let (v0,) = self.0;
                StoredRangeComprehendBuilder((v0, value))
            }
        }

        impl<T0, T1> StoredRangeComprehendBuilder<(T0, T1)> {
            /// Setter for the [`end_label` field](StoredRangeComprehend#structfield.end_label).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_label<T2>(self, value: T2) -> StoredRangeComprehendBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1) = self.0;
                StoredRangeComprehendBuilder((v0, v1, value))
            }

            /// Sets the [`end_label` field](StoredRangeComprehend#structfield.end_label) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_label_as_default(
                self,
            ) -> StoredRangeComprehendBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.end_label(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> StoredRangeComprehendBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredRangeComprehend].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredRangeComprehend>
            where
                Self: ::planus::WriteAsOffset<StoredRangeComprehend>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T2: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAs<::planus::Offset<StoredRangeComprehend>>
            for StoredRangeComprehendBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredRangeComprehend>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredRangeComprehend> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T2: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredRangeComprehend>>
            for StoredRangeComprehendBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<StoredRangeComprehend>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredRangeComprehend>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T2: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOffset<StoredRangeComprehend>
            for StoredRangeComprehendBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredRangeComprehend> {
                let (v0, v1, v2) = &self.0;
                StoredRangeComprehend::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [StoredRangeComprehend].
        #[derive(Copy, Clone)]
        pub struct StoredRangeComprehendRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredRangeComprehendRef<'a> {
            /// Getter for the [`position` field](StoredRangeComprehend#structfield.position).
            #[inline]
            pub fn position(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0
                    .access_required(0, "StoredRangeComprehend", "position")
            }

            /// Getter for the [`end_of_range_register` field](StoredRangeComprehend#structfield.end_of_range_register).
            #[inline]
            pub fn end_of_range_register(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0
                    .access_required(1, "StoredRangeComprehend", "end_of_range_register")
            }

            /// Getter for the [`end_label` field](StoredRangeComprehend#structfield.end_label).
            #[inline]
            pub fn end_label(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "StoredRangeComprehend", "end_label")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for StoredRangeComprehendRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredRangeComprehendRef");
                f.field("position", &self.position());
                f.field("end_of_range_register", &self.end_of_range_register());
                f.field("end_label", &self.end_label());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredRangeComprehendRef<'a>> for StoredRangeComprehend {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredRangeComprehendRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    position: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.position()?,
                    )?),
                    end_of_range_register: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.end_of_range_register()?)?,
                    ),
                    end_label: ::core::convert::TryInto::try_into(value.end_label()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredRangeComprehendRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredRangeComprehendRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredRangeComprehendRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredRangeComprehend>>
            for StoredRangeComprehend
        {
            type Value = ::planus::Offset<StoredRangeComprehend>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredRangeComprehend>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredRangeComprehendRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredRangeComprehendRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredListComprehend` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredListComprehend` in the file `../../../schema/schema/moor_program.fbs:153`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StoredListComprehend {
            /// The field `position_register` in the table `StoredListComprehend`
            pub position_register: ::planus::alloc::boxed::Box<self::StoredName>,
            /// The field `list_register` in the table `StoredListComprehend`
            pub list_register: ::planus::alloc::boxed::Box<self::StoredName>,
            /// The field `item_variable` in the table `StoredListComprehend`
            pub item_variable: ::planus::alloc::boxed::Box<self::StoredName>,
            /// The field `end_label` in the table `StoredListComprehend`
            pub end_label: u16,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredListComprehend {
            fn default() -> Self {
                Self {
                    position_register: ::core::default::Default::default(),
                    list_register: ::core::default::Default::default(),
                    item_variable: ::core::default::Default::default(),
                    end_label: 0,
                }
            }
        }

        impl StoredListComprehend {
            /// Creates a [StoredListComprehendBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredListComprehendBuilder<()> {
                StoredListComprehendBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_position_register: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
                field_list_register: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
                field_item_variable: impl ::planus::WriteAs<::planus::Offset<self::StoredName>>,
                field_end_label: impl ::planus::WriteAsDefault<u16, u16>,
            ) -> ::planus::Offset<Self> {
                let prepared_position_register = field_position_register.prepare(builder);
                let prepared_list_register = field_list_register.prepare(builder);
                let prepared_item_variable = field_item_variable.prepare(builder);
                let prepared_end_label = field_end_label.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(0);
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(1);
                table_writer.write_entry::<::planus::Offset<self::StoredName>>(2);
                if prepared_end_label.is_some() {
                    table_writer.write_entry::<u16>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_position_register);
                        object_writer.write::<_, _, 4>(&prepared_list_register);
                        object_writer.write::<_, _, 4>(&prepared_item_variable);
                        if let ::core::option::Option::Some(prepared_end_label) = prepared_end_label
                        {
                            object_writer.write::<_, _, 2>(&prepared_end_label);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredListComprehend>> for StoredListComprehend {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredListComprehend> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredListComprehend>> for StoredListComprehend {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredListComprehend>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredListComprehend> for StoredListComprehend {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredListComprehend> {
                StoredListComprehend::create(
                    builder,
                    &self.position_register,
                    &self.list_register,
                    &self.item_variable,
                    self.end_label,
                )
            }
        }

        /// Builder for serializing an instance of the [StoredListComprehend] type.
        ///
        /// Can be created using the [StoredListComprehend::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredListComprehendBuilder<State>(State);

        impl StoredListComprehendBuilder<()> {
            /// Setter for the [`position_register` field](StoredListComprehend#structfield.position_register).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn position_register<T0>(self, value: T0) -> StoredListComprehendBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                StoredListComprehendBuilder((value,))
            }
        }

        impl<T0> StoredListComprehendBuilder<(T0,)> {
            /// Setter for the [`list_register` field](StoredListComprehend#structfield.list_register).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn list_register<T1>(self, value: T1) -> StoredListComprehendBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                let (v0,) = self.0;
                StoredListComprehendBuilder((v0, value))
            }
        }

        impl<T0, T1> StoredListComprehendBuilder<(T0, T1)> {
            /// Setter for the [`item_variable` field](StoredListComprehend#structfield.item_variable).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn item_variable<T2>(self, value: T2) -> StoredListComprehendBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            {
                let (v0, v1) = self.0;
                StoredListComprehendBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> StoredListComprehendBuilder<(T0, T1, T2)> {
            /// Setter for the [`end_label` field](StoredListComprehend#structfield.end_label).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_label<T3>(self, value: T3) -> StoredListComprehendBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1, v2) = self.0;
                StoredListComprehendBuilder((v0, v1, v2, value))
            }

            /// Sets the [`end_label` field](StoredListComprehend#structfield.end_label) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_label_as_default(
                self,
            ) -> StoredListComprehendBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.end_label(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> StoredListComprehendBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredListComprehend].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredListComprehend>
            where
                Self: ::planus::WriteAsOffset<StoredListComprehend>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T2: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T3: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAs<::planus::Offset<StoredListComprehend>>
            for StoredListComprehendBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<StoredListComprehend>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredListComprehend> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T2: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T3: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredListComprehend>>
            for StoredListComprehendBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<StoredListComprehend>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredListComprehend>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T1: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T2: ::planus::WriteAs<::planus::Offset<self::StoredName>>,
            T3: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOffset<StoredListComprehend>
            for StoredListComprehendBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<StoredListComprehend> {
                let (v0, v1, v2, v3) = &self.0;
                StoredListComprehend::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [StoredListComprehend].
        #[derive(Copy, Clone)]
        pub struct StoredListComprehendRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredListComprehendRef<'a> {
            /// Getter for the [`position_register` field](StoredListComprehend#structfield.position_register).
            #[inline]
            pub fn position_register(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0
                    .access_required(0, "StoredListComprehend", "position_register")
            }

            /// Getter for the [`list_register` field](StoredListComprehend#structfield.list_register).
            #[inline]
            pub fn list_register(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0
                    .access_required(1, "StoredListComprehend", "list_register")
            }

            /// Getter for the [`item_variable` field](StoredListComprehend#structfield.item_variable).
            #[inline]
            pub fn item_variable(&self) -> ::planus::Result<self::StoredNameRef<'a>> {
                self.0
                    .access_required(2, "StoredListComprehend", "item_variable")
            }

            /// Getter for the [`end_label` field](StoredListComprehend#structfield.end_label).
            #[inline]
            pub fn end_label(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "StoredListComprehend", "end_label")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for StoredListComprehendRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredListComprehendRef");
                f.field("position_register", &self.position_register());
                f.field("list_register", &self.list_register());
                f.field("item_variable", &self.item_variable());
                f.field("end_label", &self.end_label());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredListComprehendRef<'a>> for StoredListComprehend {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredListComprehendRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    position_register: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.position_register()?)?,
                    ),
                    list_register: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.list_register()?)?,
                    ),
                    item_variable: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.item_variable()?)?,
                    ),
                    end_label: ::core::convert::TryInto::try_into(value.end_label()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredListComprehendRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredListComprehendRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredListComprehendRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredListComprehend>> for StoredListComprehend {
            type Value = ::planus::Offset<StoredListComprehend>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredListComprehend>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredListComprehendRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredListComprehendRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ForkVector` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `ForkVector` in the file `../../../schema/schema/moor_program.fbs:164`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ForkVector {
            /// The field `offset` in the table `ForkVector`
            pub offset: u64,
            /// The field `opcodes` in the table `ForkVector`
            pub opcodes: ::planus::alloc::vec::Vec<u16>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ForkVector {
            fn default() -> Self {
                Self {
                    offset: 0,
                    opcodes: ::core::default::Default::default(),
                }
            }
        }

        impl ForkVector {
            /// Creates a [ForkVectorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ForkVectorBuilder<()> {
                ForkVectorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_offset: impl ::planus::WriteAsDefault<u64, u64>,
                field_opcodes: impl ::planus::WriteAs<::planus::Offset<[u16]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_offset = field_offset.prepare(builder, &0);
                let prepared_opcodes = field_opcodes.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_offset.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                table_writer.write_entry::<::planus::Offset<[u16]>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_offset) = prepared_offset {
                            object_writer.write::<_, _, 8>(&prepared_offset);
                        }
                        object_writer.write::<_, _, 4>(&prepared_opcodes);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ForkVector>> for ForkVector {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ForkVector> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ForkVector>> for ForkVector {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ForkVector>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ForkVector> for ForkVector {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ForkVector> {
                ForkVector::create(builder, self.offset, &self.opcodes)
            }
        }

        /// Builder for serializing an instance of the [ForkVector] type.
        ///
        /// Can be created using the [ForkVector::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ForkVectorBuilder<State>(State);

        impl ForkVectorBuilder<()> {
            /// Setter for the [`offset` field](ForkVector#structfield.offset).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn offset<T0>(self, value: T0) -> ForkVectorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                ForkVectorBuilder((value,))
            }

            /// Sets the [`offset` field](ForkVector#structfield.offset) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn offset_as_default(self) -> ForkVectorBuilder<(::planus::DefaultValue,)> {
                self.offset(::planus::DefaultValue)
            }
        }

        impl<T0> ForkVectorBuilder<(T0,)> {
            /// Setter for the [`opcodes` field](ForkVector#structfield.opcodes).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn opcodes<T1>(self, value: T1) -> ForkVectorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<[u16]>>,
            {
                let (v0,) = self.0;
                ForkVectorBuilder((v0, value))
            }
        }

        impl<T0, T1> ForkVectorBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ForkVector].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ForkVector>
            where
                Self: ::planus::WriteAsOffset<ForkVector>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAs<::planus::Offset<[u16]>>>
            ::planus::WriteAs<::planus::Offset<ForkVector>> for ForkVectorBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<ForkVector>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ForkVector> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAs<::planus::Offset<[u16]>>>
            ::planus::WriteAsOptional<::planus::Offset<ForkVector>>
            for ForkVectorBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<ForkVector>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ForkVector>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAs<::planus::Offset<[u16]>>>
            ::planus::WriteAsOffset<ForkVector> for ForkVectorBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ForkVector> {
                let (v0, v1) = &self.0;
                ForkVector::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [ForkVector].
        #[derive(Copy, Clone)]
        pub struct ForkVectorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ForkVectorRef<'a> {
            /// Getter for the [`offset` field](ForkVector#structfield.offset).
            #[inline]
            pub fn offset(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(0, "ForkVector", "offset")?.unwrap_or(0))
            }

            /// Getter for the [`opcodes` field](ForkVector#structfield.opcodes).
            #[inline]
            pub fn opcodes(&self) -> ::planus::Result<::planus::Vector<'a, u16>> {
                self.0.access_required(1, "ForkVector", "opcodes")
            }
        }

        impl<'a> ::core::fmt::Debug for ForkVectorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ForkVectorRef");
                f.field("offset", &self.offset());
                f.field("opcodes", &self.opcodes());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ForkVectorRef<'a>> for ForkVector {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ForkVectorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    offset: ::core::convert::TryInto::try_into(value.offset()?)?,
                    opcodes: value.opcodes()?.to_vec()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ForkVectorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ForkVectorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ForkVectorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ForkVector>> for ForkVector {
            type Value = ::planus::Offset<ForkVector>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ForkVector>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ForkVectorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ForkVectorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StoredProgram` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `StoredProgram` in the file `../../../schema/schema/moor_program.fbs:173`
        #[derive(Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize)]
        pub struct StoredProgram {
            /// The field `version` in the table `StoredProgram`
            pub version: u16,
            /// The field `main_vector` in the table `StoredProgram`
            pub main_vector: ::planus::alloc::vec::Vec<u16>,
            /// The field `fork_vectors` in the table `StoredProgram`
            pub fork_vectors: ::planus::alloc::vec::Vec<self::ForkVector>,
            /// The field `literals` in the table `StoredProgram`
            pub literals: ::planus::alloc::vec::Vec<super::moor_var::Var>,
            /// The field `jump_labels` in the table `StoredProgram`
            pub jump_labels: ::planus::alloc::vec::Vec<self::StoredJumpLabel>,
            /// The field `var_names` in the table `StoredProgram`
            pub var_names: ::planus::alloc::boxed::Box<self::StoredNames>,
            /// The field `symbol_table` in the table `StoredProgram`
            pub symbol_table: ::planus::alloc::vec::Vec<super::moor_common::Symbol>,
            /// The field `scatter_tables` in the table `StoredProgram`
            pub scatter_tables: ::planus::alloc::vec::Vec<self::StoredScatterArgs>,
            /// The field `for_sequence_operands` in the table `StoredProgram`
            pub for_sequence_operands: ::planus::alloc::vec::Vec<self::StoredForSequenceOperand>,
            /// The field `for_range_operands` in the table `StoredProgram`
            pub for_range_operands: ::planus::alloc::vec::Vec<self::StoredForRangeOperand>,
            /// The field `range_comprehensions` in the table `StoredProgram`
            pub range_comprehensions: ::planus::alloc::vec::Vec<self::StoredRangeComprehend>,
            /// The field `list_comprehensions` in the table `StoredProgram`
            pub list_comprehensions: ::planus::alloc::vec::Vec<self::StoredListComprehend>,
            /// The field `error_operands` in the table `StoredProgram`
            pub error_operands: ::planus::alloc::vec::Vec<u8>,
            /// The field `lambda_programs` in the table `StoredProgram`
            pub lambda_programs: ::planus::alloc::vec::Vec<self::StoredProgram>,
            /// The field `line_number_spans` in the table `StoredProgram`
            pub line_number_spans: ::planus::alloc::vec::Vec<self::LineSpan>,
            /// The field `fork_line_number_spans` in the table `StoredProgram`
            pub fork_line_number_spans: ::planus::alloc::vec::Vec<self::ForkLineSpans>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StoredProgram {
            fn default() -> Self {
                Self {
                    version: 0,
                    main_vector: ::core::default::Default::default(),
                    fork_vectors: ::core::default::Default::default(),
                    literals: ::core::default::Default::default(),
                    jump_labels: ::core::default::Default::default(),
                    var_names: ::core::default::Default::default(),
                    symbol_table: ::core::default::Default::default(),
                    scatter_tables: ::core::default::Default::default(),
                    for_sequence_operands: ::core::default::Default::default(),
                    for_range_operands: ::core::default::Default::default(),
                    range_comprehensions: ::core::default::Default::default(),
                    list_comprehensions: ::core::default::Default::default(),
                    error_operands: ::core::default::Default::default(),
                    lambda_programs: ::core::default::Default::default(),
                    line_number_spans: ::core::default::Default::default(),
                    fork_line_number_spans: ::core::default::Default::default(),
                }
            }
        }

        impl StoredProgram {
            /// Creates a [StoredProgramBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StoredProgramBuilder<()> {
                StoredProgramBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_version: impl ::planus::WriteAsDefault<u16, u16>,
                field_main_vector: impl ::planus::WriteAs<::planus::Offset<[u16]>>,
                field_fork_vectors: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::ForkVector>]>,
                >,
                field_literals: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<super::moor_var::Var>]>,
                >,
                field_jump_labels: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::StoredJumpLabel>]>,
                >,
                field_var_names: impl ::planus::WriteAs<::planus::Offset<self::StoredNames>>,
                field_symbol_table: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>,
                >,
                field_scatter_tables: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::StoredScatterArgs>]>,
                >,
                field_for_sequence_operands: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::StoredForSequenceOperand>]>,
                >,
                field_for_range_operands: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::StoredForRangeOperand>]>,
                >,
                field_range_comprehensions: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::StoredRangeComprehend>]>,
                >,
                field_list_comprehensions: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::StoredListComprehend>]>,
                >,
                field_error_operands: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                field_lambda_programs: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::StoredProgram>]>,
                >,
                field_line_number_spans: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::LineSpan>]>,
                >,
                field_fork_line_number_spans: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::ForkLineSpans>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_version = field_version.prepare(builder, &0);
                let prepared_main_vector = field_main_vector.prepare(builder);
                let prepared_fork_vectors = field_fork_vectors.prepare(builder);
                let prepared_literals = field_literals.prepare(builder);
                let prepared_jump_labels = field_jump_labels.prepare(builder);
                let prepared_var_names = field_var_names.prepare(builder);
                let prepared_symbol_table = field_symbol_table.prepare(builder);
                let prepared_scatter_tables = field_scatter_tables.prepare(builder);
                let prepared_for_sequence_operands = field_for_sequence_operands.prepare(builder);
                let prepared_for_range_operands = field_for_range_operands.prepare(builder);
                let prepared_range_comprehensions = field_range_comprehensions.prepare(builder);
                let prepared_list_comprehensions = field_list_comprehensions.prepare(builder);
                let prepared_error_operands = field_error_operands.prepare(builder);
                let prepared_lambda_programs = field_lambda_programs.prepare(builder);
                let prepared_line_number_spans = field_line_number_spans.prepare(builder);
                let prepared_fork_line_number_spans = field_fork_line_number_spans.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<36> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[u16]>>(1);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::ForkVector>]>>(2);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>(3);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::StoredJumpLabel>]>>(4);
                table_writer.write_entry::<::planus::Offset<self::StoredNames>>(5);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>>(6);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::StoredScatterArgs>]>>(
                        7,
                    );
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::StoredForSequenceOperand>]>>(8);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::StoredForRangeOperand>]>>(9);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::StoredRangeComprehend>]>>(10);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::StoredListComprehend>]>>(11);
                table_writer.write_entry::<::planus::Offset<[u8]>>(12);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::StoredProgram>]>>(13);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::LineSpan>]>>(14);
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::ForkLineSpans>]>>(15);
                if prepared_version.is_some() {
                    table_writer.write_entry::<u16>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_main_vector);
                        object_writer.write::<_, _, 4>(&prepared_fork_vectors);
                        object_writer.write::<_, _, 4>(&prepared_literals);
                        object_writer.write::<_, _, 4>(&prepared_jump_labels);
                        object_writer.write::<_, _, 4>(&prepared_var_names);
                        object_writer.write::<_, _, 4>(&prepared_symbol_table);
                        object_writer.write::<_, _, 4>(&prepared_scatter_tables);
                        object_writer.write::<_, _, 4>(&prepared_for_sequence_operands);
                        object_writer.write::<_, _, 4>(&prepared_for_range_operands);
                        object_writer.write::<_, _, 4>(&prepared_range_comprehensions);
                        object_writer.write::<_, _, 4>(&prepared_list_comprehensions);
                        object_writer.write::<_, _, 4>(&prepared_error_operands);
                        object_writer.write::<_, _, 4>(&prepared_lambda_programs);
                        object_writer.write::<_, _, 4>(&prepared_line_number_spans);
                        object_writer.write::<_, _, 4>(&prepared_fork_line_number_spans);
                        if let ::core::option::Option::Some(prepared_version) = prepared_version {
                            object_writer.write::<_, _, 2>(&prepared_version);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StoredProgram>> for StoredProgram {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredProgram> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StoredProgram>> for StoredProgram {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredProgram>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StoredProgram> for StoredProgram {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredProgram> {
                StoredProgram::create(
                    builder,
                    self.version,
                    &self.main_vector,
                    &self.fork_vectors,
                    &self.literals,
                    &self.jump_labels,
                    &self.var_names,
                    &self.symbol_table,
                    &self.scatter_tables,
                    &self.for_sequence_operands,
                    &self.for_range_operands,
                    &self.range_comprehensions,
                    &self.list_comprehensions,
                    &self.error_operands,
                    &self.lambda_programs,
                    &self.line_number_spans,
                    &self.fork_line_number_spans,
                )
            }
        }

        /// Builder for serializing an instance of the [StoredProgram] type.
        ///
        /// Can be created using the [StoredProgram::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StoredProgramBuilder<State>(State);

        impl StoredProgramBuilder<()> {
            /// Setter for the [`version` field](StoredProgram#structfield.version).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn version<T0>(self, value: T0) -> StoredProgramBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u16, u16>,
            {
                StoredProgramBuilder((value,))
            }

            /// Sets the [`version` field](StoredProgram#structfield.version) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn version_as_default(self) -> StoredProgramBuilder<(::planus::DefaultValue,)> {
                self.version(::planus::DefaultValue)
            }
        }

        impl<T0> StoredProgramBuilder<(T0,)> {
            /// Setter for the [`main_vector` field](StoredProgram#structfield.main_vector).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn main_vector<T1>(self, value: T1) -> StoredProgramBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<[u16]>>,
            {
                let (v0,) = self.0;
                StoredProgramBuilder((v0, value))
            }
        }

        impl<T0, T1> StoredProgramBuilder<(T0, T1)> {
            /// Setter for the [`fork_vectors` field](StoredProgram#structfield.fork_vectors).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn fork_vectors<T2>(self, value: T2) -> StoredProgramBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ForkVector>]>>,
            {
                let (v0, v1) = self.0;
                StoredProgramBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> StoredProgramBuilder<(T0, T1, T2)> {
            /// Setter for the [`literals` field](StoredProgram#structfield.literals).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn literals<T3>(self, value: T3) -> StoredProgramBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
            {
                let (v0, v1, v2) = self.0;
                StoredProgramBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> StoredProgramBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`jump_labels` field](StoredProgram#structfield.jump_labels).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn jump_labels<T4>(self, value: T4) -> StoredProgramBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredJumpLabel>]>>,
            {
                let (v0, v1, v2, v3) = self.0;
                StoredProgramBuilder((v0, v1, v2, v3, value))
            }
        }

        impl<T0, T1, T2, T3, T4> StoredProgramBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`var_names` field](StoredProgram#structfield.var_names).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn var_names<T5>(self, value: T5) -> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAs<::planus::Offset<self::StoredNames>>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                StoredProgramBuilder((v0, v1, v2, v3, v4, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Setter for the [`symbol_table` field](StoredProgram#structfield.symbol_table).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn symbol_table<T6>(
                self,
                value: T6,
            ) -> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            where
                T6: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>,
                    >,
            {
                let (v0, v1, v2, v3, v4, v5) = self.0;
                StoredProgramBuilder((v0, v1, v2, v3, v4, v5, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
            /// Setter for the [`scatter_tables` field](StoredProgram#structfield.scatter_tables).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scatter_tables<T7>(
                self,
                value: T7,
            ) -> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            where
                T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredScatterArgs>]>>,
            {
                let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                StoredProgramBuilder((v0, v1, v2, v3, v4, v5, v6, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
            /// Setter for the [`for_sequence_operands` field](StoredProgram#structfield.for_sequence_operands).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn for_sequence_operands<T8>(
                self,
                value: T8,
            ) -> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            where
                T8: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::StoredForSequenceOperand>]>,
                    >,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                StoredProgramBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8>
            StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
        {
            /// Setter for the [`for_range_operands` field](StoredProgram#structfield.for_range_operands).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn for_range_operands<T9>(
                self,
                value: T9,
            ) -> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            where
                T9: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::StoredForRangeOperand>]>,
                    >,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                StoredProgramBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
            StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
        {
            /// Setter for the [`range_comprehensions` field](StoredProgram#structfield.range_comprehensions).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn range_comprehensions<T10>(
                self,
                value: T10,
            ) -> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            where
                T10: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::StoredRangeComprehend>]>,
                    >,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                StoredProgramBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
            StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
        {
            /// Setter for the [`list_comprehensions` field](StoredProgram#structfield.list_comprehensions).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn list_comprehensions<T11>(
                self,
                value: T11,
            ) -> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            where
                T11: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::StoredListComprehend>]>,
                    >,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                StoredProgramBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
        {
            /// Setter for the [`error_operands` field](StoredProgram#structfield.error_operands).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error_operands<T12>(
                self,
                value: T12,
            ) -> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            where
                T12: ::planus::WriteAs<::planus::Offset<[u8]>>,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                StoredProgramBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
            StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
        {
            /// Setter for the [`lambda_programs` field](StoredProgram#structfield.lambda_programs).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn lambda_programs<T13>(
                self,
                value: T13,
            ) -> StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            where
                T13: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredProgram>]>>,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                StoredProgramBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
            StoredProgramBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
        {
            /// Setter for the [`line_number_spans` field](StoredProgram#structfield.line_number_spans).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn line_number_spans<T14>(
                self,
                value: T14,
            ) -> StoredProgramBuilder<(
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
            )>
            where
                T14: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::LineSpan>]>>,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = self.0;
                StoredProgramBuilder((
                    v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, value,
                ))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
            StoredProgramBuilder<(
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
            )>
        {
            /// Setter for the [`fork_line_number_spans` field](StoredProgram#structfield.fork_line_number_spans).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn fork_line_number_spans<T15>(
                self,
                value: T15,
            ) -> StoredProgramBuilder<(
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
            )>
            where
                T15: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ForkLineSpans>]>>,
            {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) = self.0;
                StoredProgramBuilder((
                    v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, value,
                ))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
            StoredProgramBuilder<(
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
            )>
        {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StoredProgram].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredProgram>
            where
                Self: ::planus::WriteAsOffset<StoredProgram>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAs<::planus::Offset<[u16]>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ForkVector>]>>,
            T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredJumpLabel>]>>,
            T5: ::planus::WriteAs<::planus::Offset<self::StoredNames>>,
            T6: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>>,
            T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredScatterArgs>]>>,
            T8: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredForSequenceOperand>]>>,
            T9: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredForRangeOperand>]>>,
            T10: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredRangeComprehend>]>>,
            T11: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredListComprehend>]>>,
            T12: ::planus::WriteAs<::planus::Offset<[u8]>>,
            T13: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredProgram>]>>,
            T14: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::LineSpan>]>>,
            T15: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ForkLineSpans>]>>,
        > ::planus::WriteAs<::planus::Offset<StoredProgram>>
            for StoredProgramBuilder<(
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
            )>
        {
            type Prepared = ::planus::Offset<StoredProgram>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredProgram> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAs<::planus::Offset<[u16]>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ForkVector>]>>,
            T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredJumpLabel>]>>,
            T5: ::planus::WriteAs<::planus::Offset<self::StoredNames>>,
            T6: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>>,
            T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredScatterArgs>]>>,
            T8: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredForSequenceOperand>]>>,
            T9: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredForRangeOperand>]>>,
            T10: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredRangeComprehend>]>>,
            T11: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredListComprehend>]>>,
            T12: ::planus::WriteAs<::planus::Offset<[u8]>>,
            T13: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredProgram>]>>,
            T14: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::LineSpan>]>>,
            T15: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ForkLineSpans>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<StoredProgram>>
            for StoredProgramBuilder<(
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
            )>
        {
            type Prepared = ::planus::Offset<StoredProgram>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StoredProgram>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u16, u16>,
            T1: ::planus::WriteAs<::planus::Offset<[u16]>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ForkVector>]>>,
            T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_var::Var>]>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredJumpLabel>]>>,
            T5: ::planus::WriteAs<::planus::Offset<self::StoredNames>>,
            T6: ::planus::WriteAs<::planus::Offset<[::planus::Offset<super::moor_common::Symbol>]>>,
            T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredScatterArgs>]>>,
            T8: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredForSequenceOperand>]>>,
            T9: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredForRangeOperand>]>>,
            T10: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredRangeComprehend>]>>,
            T11: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredListComprehend>]>>,
            T12: ::planus::WriteAs<::planus::Offset<[u8]>>,
            T13: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::StoredProgram>]>>,
            T14: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::LineSpan>]>>,
            T15: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ForkLineSpans>]>>,
        > ::planus::WriteAsOffset<StoredProgram>
            for StoredProgramBuilder<(
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
            )>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StoredProgram> {
                let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) =
                    &self.0;
                StoredProgram::create(
                    builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,
                )
            }
        }

        /// Reference to a deserialized [StoredProgram].
        #[derive(Copy, Clone)]
        pub struct StoredProgramRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StoredProgramRef<'a> {
            /// Getter for the [`version` field](StoredProgram#structfield.version).
            #[inline]
            pub fn version(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0.access(0, "StoredProgram", "version")?.unwrap_or(0),
                )
            }

            /// Getter for the [`main_vector` field](StoredProgram#structfield.main_vector).
            #[inline]
            pub fn main_vector(&self) -> ::planus::Result<::planus::Vector<'a, u16>> {
                self.0.access_required(1, "StoredProgram", "main_vector")
            }

            /// Getter for the [`fork_vectors` field](StoredProgram#structfield.fork_vectors).
            #[inline]
            pub fn fork_vectors(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::ForkVectorRef<'a>>>>
            {
                self.0.access_required(2, "StoredProgram", "fork_vectors")
            }

            /// Getter for the [`literals` field](StoredProgram#structfield.literals).
            #[inline]
            pub fn literals(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<super::moor_var::VarRef<'a>>>>
            {
                self.0.access_required(3, "StoredProgram", "literals")
            }

            /// Getter for the [`jump_labels` field](StoredProgram#structfield.jump_labels).
            #[inline]
            pub fn jump_labels(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::StoredJumpLabelRef<'a>>>,
            > {
                self.0.access_required(4, "StoredProgram", "jump_labels")
            }

            /// Getter for the [`var_names` field](StoredProgram#structfield.var_names).
            #[inline]
            pub fn var_names(&self) -> ::planus::Result<self::StoredNamesRef<'a>> {
                self.0.access_required(5, "StoredProgram", "var_names")
            }

            /// Getter for the [`symbol_table` field](StoredProgram#structfield.symbol_table).
            #[inline]
            pub fn symbol_table(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<super::moor_common::SymbolRef<'a>>>,
            > {
                self.0.access_required(6, "StoredProgram", "symbol_table")
            }

            /// Getter for the [`scatter_tables` field](StoredProgram#structfield.scatter_tables).
            #[inline]
            pub fn scatter_tables(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::StoredScatterArgsRef<'a>>>,
            > {
                self.0.access_required(7, "StoredProgram", "scatter_tables")
            }

            /// Getter for the [`for_sequence_operands` field](StoredProgram#structfield.for_sequence_operands).
            #[inline]
            pub fn for_sequence_operands(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::StoredForSequenceOperandRef<'a>>>,
            > {
                self.0
                    .access_required(8, "StoredProgram", "for_sequence_operands")
            }

            /// Getter for the [`for_range_operands` field](StoredProgram#structfield.for_range_operands).
            #[inline]
            pub fn for_range_operands(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::StoredForRangeOperandRef<'a>>>,
            > {
                self.0
                    .access_required(9, "StoredProgram", "for_range_operands")
            }

            /// Getter for the [`range_comprehensions` field](StoredProgram#structfield.range_comprehensions).
            #[inline]
            pub fn range_comprehensions(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::StoredRangeComprehendRef<'a>>>,
            > {
                self.0
                    .access_required(10, "StoredProgram", "range_comprehensions")
            }

            /// Getter for the [`list_comprehensions` field](StoredProgram#structfield.list_comprehensions).
            #[inline]
            pub fn list_comprehensions(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::StoredListComprehendRef<'a>>>,
            > {
                self.0
                    .access_required(11, "StoredProgram", "list_comprehensions")
            }

            /// Getter for the [`error_operands` field](StoredProgram#structfield.error_operands).
            #[inline]
            pub fn error_operands(&self) -> ::planus::Result<&'a [u8]> {
                self.0
                    .access_required(12, "StoredProgram", "error_operands")
            }

            /// Getter for the [`lambda_programs` field](StoredProgram#structfield.lambda_programs).
            #[inline]
            pub fn lambda_programs(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::StoredProgramRef<'a>>>>
            {
                self.0
                    .access_required(13, "StoredProgram", "lambda_programs")
            }

            /// Getter for the [`line_number_spans` field](StoredProgram#structfield.line_number_spans).
            #[inline]
            pub fn line_number_spans(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::LineSpanRef<'a>>>>
            {
                self.0
                    .access_required(14, "StoredProgram", "line_number_spans")
            }

            /// Getter for the [`fork_line_number_spans` field](StoredProgram#structfield.fork_line_number_spans).
            #[inline]
            pub fn fork_line_number_spans(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::ForkLineSpansRef<'a>>>>
            {
                self.0
                    .access_required(15, "StoredProgram", "fork_line_number_spans")
            }
        }

        impl<'a> ::core::fmt::Debug for StoredProgramRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StoredProgramRef");
                f.field("version", &self.version());
                f.field("main_vector", &self.main_vector());
                f.field("fork_vectors", &self.fork_vectors());
                f.field("literals", &self.literals());
                f.field("jump_labels", &self.jump_labels());
                f.field("var_names", &self.var_names());
                f.field("symbol_table", &self.symbol_table());
                f.field("scatter_tables", &self.scatter_tables());
                f.field("for_sequence_operands", &self.for_sequence_operands());
                f.field("for_range_operands", &self.for_range_operands());
                f.field("range_comprehensions", &self.range_comprehensions());
                f.field("list_comprehensions", &self.list_comprehensions());
                f.field("error_operands", &self.error_operands());
                f.field("lambda_programs", &self.lambda_programs());
                f.field("line_number_spans", &self.line_number_spans());
                f.field("fork_line_number_spans", &self.fork_line_number_spans());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StoredProgramRef<'a>> for StoredProgram {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StoredProgramRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    version: ::core::convert::TryInto::try_into(value.version()?)?,
                    main_vector: value.main_vector()?.to_vec()?,
                    fork_vectors: value.fork_vectors()?.to_vec_result()?,
                    literals: value.literals()?.to_vec_result()?,
                    jump_labels: value.jump_labels()?.to_vec_result()?,
                    var_names: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.var_names()?)?,
                    ),
                    symbol_table: value.symbol_table()?.to_vec_result()?,
                    scatter_tables: value.scatter_tables()?.to_vec_result()?,
                    for_sequence_operands: value.for_sequence_operands()?.to_vec_result()?,
                    for_range_operands: value.for_range_operands()?.to_vec_result()?,
                    range_comprehensions: value.range_comprehensions()?.to_vec_result()?,
                    list_comprehensions: value.list_comprehensions()?.to_vec_result()?,
                    error_operands: value.error_operands()?.to_vec(),
                    lambda_programs: value.lambda_programs()?.to_vec_result()?,
                    line_number_spans: value.line_number_spans()?.to_vec_result()?,
                    fork_line_number_spans: value.fork_line_number_spans()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StoredProgramRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StoredProgramRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StoredProgramRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StoredProgram>> for StoredProgram {
            type Value = ::planus::Offset<StoredProgram>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StoredProgram>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StoredProgramRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StoredProgramRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `LineSpan` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `LineSpan` in the file `../../../schema/schema/moor_program.fbs:223`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct LineSpan {
            /// The field `offset` in the table `LineSpan`
            pub offset: u64,
            /// The field `line_number` in the table `LineSpan`
            pub line_number: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for LineSpan {
            fn default() -> Self {
                Self {
                    offset: 0,
                    line_number: 0,
                }
            }
        }

        impl LineSpan {
            /// Creates a [LineSpanBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> LineSpanBuilder<()> {
                LineSpanBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_offset: impl ::planus::WriteAsDefault<u64, u64>,
                field_line_number: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_offset = field_offset.prepare(builder, &0);
                let prepared_line_number = field_line_number.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_offset.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                if prepared_line_number.is_some() {
                    table_writer.write_entry::<u64>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_offset) = prepared_offset {
                            object_writer.write::<_, _, 8>(&prepared_offset);
                        }
                        if let ::core::option::Option::Some(prepared_line_number) =
                            prepared_line_number
                        {
                            object_writer.write::<_, _, 8>(&prepared_line_number);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<LineSpan>> for LineSpan {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LineSpan> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<LineSpan>> for LineSpan {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<LineSpan>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<LineSpan> for LineSpan {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LineSpan> {
                LineSpan::create(builder, self.offset, self.line_number)
            }
        }

        /// Builder for serializing an instance of the [LineSpan] type.
        ///
        /// Can be created using the [LineSpan::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct LineSpanBuilder<State>(State);

        impl LineSpanBuilder<()> {
            /// Setter for the [`offset` field](LineSpan#structfield.offset).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn offset<T0>(self, value: T0) -> LineSpanBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                LineSpanBuilder((value,))
            }

            /// Sets the [`offset` field](LineSpan#structfield.offset) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn offset_as_default(self) -> LineSpanBuilder<(::planus::DefaultValue,)> {
                self.offset(::planus::DefaultValue)
            }
        }

        impl<T0> LineSpanBuilder<(T0,)> {
            /// Setter for the [`line_number` field](LineSpan#structfield.line_number).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn line_number<T1>(self, value: T1) -> LineSpanBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                LineSpanBuilder((v0, value))
            }

            /// Sets the [`line_number` field](LineSpan#structfield.line_number) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn line_number_as_default(self) -> LineSpanBuilder<(T0, ::planus::DefaultValue)> {
                self.line_number(::planus::DefaultValue)
            }
        }

        impl<T0, T1> LineSpanBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [LineSpan].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<LineSpan>
            where
                Self: ::planus::WriteAsOffset<LineSpan>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAs<::planus::Offset<LineSpan>> for LineSpanBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<LineSpan>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LineSpan> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<LineSpan>> for LineSpanBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<LineSpan>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<LineSpan>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOffset<LineSpan> for LineSpanBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LineSpan> {
                let (v0, v1) = &self.0;
                LineSpan::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [LineSpan].
        #[derive(Copy, Clone)]
        pub struct LineSpanRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> LineSpanRef<'a> {
            /// Getter for the [`offset` field](LineSpan#structfield.offset).
            #[inline]
            pub fn offset(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(0, "LineSpan", "offset")?.unwrap_or(0))
            }

            /// Getter for the [`line_number` field](LineSpan#structfield.line_number).
            #[inline]
            pub fn line_number(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0.access(1, "LineSpan", "line_number")?.unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for LineSpanRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("LineSpanRef");
                f.field("offset", &self.offset());
                f.field("line_number", &self.line_number());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<LineSpanRef<'a>> for LineSpan {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: LineSpanRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    offset: ::core::convert::TryInto::try_into(value.offset()?)?,
                    line_number: ::core::convert::TryInto::try_into(value.line_number()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for LineSpanRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for LineSpanRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[LineSpanRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<LineSpan>> for LineSpan {
            type Value = ::planus::Offset<LineSpan>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<LineSpan>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for LineSpanRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[LineSpanRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ForkLineSpans` in the namespace `MoorProgram`
        ///
        /// Generated from these locations:
        /// * Table `ForkLineSpans` in the file `../../../schema/schema/moor_program.fbs:228`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ForkLineSpans {
            /// The field `spans` in the table `ForkLineSpans`
            pub spans: ::planus::alloc::vec::Vec<self::LineSpan>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ForkLineSpans {
            fn default() -> Self {
                Self {
                    spans: ::core::default::Default::default(),
                }
            }
        }

        impl ForkLineSpans {
            /// Creates a [ForkLineSpansBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ForkLineSpansBuilder<()> {
                ForkLineSpansBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_spans: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::LineSpan>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_spans = field_spans.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::LineSpan>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_spans);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ForkLineSpans>> for ForkLineSpans {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ForkLineSpans> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ForkLineSpans>> for ForkLineSpans {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ForkLineSpans>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ForkLineSpans> for ForkLineSpans {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ForkLineSpans> {
                ForkLineSpans::create(builder, &self.spans)
            }
        }

        /// Builder for serializing an instance of the [ForkLineSpans] type.
        ///
        /// Can be created using the [ForkLineSpans::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ForkLineSpansBuilder<State>(State);

        impl ForkLineSpansBuilder<()> {
            /// Setter for the [`spans` field](ForkLineSpans#structfield.spans).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn spans<T0>(self, value: T0) -> ForkLineSpansBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::LineSpan>]>>,
            {
                ForkLineSpansBuilder((value,))
            }
        }

        impl<T0> ForkLineSpansBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ForkLineSpans].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ForkLineSpans>
            where
                Self: ::planus::WriteAsOffset<ForkLineSpans>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::LineSpan>]>>>
            ::planus::WriteAs<::planus::Offset<ForkLineSpans>> for ForkLineSpansBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ForkLineSpans>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ForkLineSpans> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::LineSpan>]>>>
            ::planus::WriteAsOptional<::planus::Offset<ForkLineSpans>>
            for ForkLineSpansBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ForkLineSpans>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ForkLineSpans>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::LineSpan>]>>>
            ::planus::WriteAsOffset<ForkLineSpans> for ForkLineSpansBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ForkLineSpans> {
                let (v0,) = &self.0;
                ForkLineSpans::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ForkLineSpans].
        #[derive(Copy, Clone)]
        pub struct ForkLineSpansRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ForkLineSpansRef<'a> {
            /// Getter for the [`spans` field](ForkLineSpans#structfield.spans).
            #[inline]
            pub fn spans(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::LineSpanRef<'a>>>>
            {
                self.0.access_required(0, "ForkLineSpans", "spans")
            }
        }

        impl<'a> ::core::fmt::Debug for ForkLineSpansRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ForkLineSpansRef");
                f.field("spans", &self.spans());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ForkLineSpansRef<'a>> for ForkLineSpans {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ForkLineSpansRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    spans: value.spans()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ForkLineSpansRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ForkLineSpansRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ForkLineSpansRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ForkLineSpans>> for ForkLineSpans {
            type Value = ::planus::Offset<ForkLineSpans>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ForkLineSpans>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ForkLineSpansRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ForkLineSpansRef]", "read_as_root", 0)
                })
            }
        }
    }
}
