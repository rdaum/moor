pub use root::*;

const _: () = ::planus::check_version_compatibility("planus-1.2.0");

/// The root namespace
///
/// Generated from these locations:
/// * File `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs`
#[no_implicit_prelude]
#[allow(dead_code, clippy::needless_lifetimes)]
mod root {
    /// The namespace `MoorRpc`
    ///
    /// Generated from these locations:
    /// * File `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs`
    pub mod moor_rpc {
        /// The table `HostToken` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostToken` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:9`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostToken {
            /// The field `token` in the table `HostToken`
            pub token: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for HostToken {
            fn default() -> Self {
                Self {
                    token: ::core::default::Default::default(),
                }
            }
        }

        impl HostToken {
            /// Creates a [HostTokenBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostTokenBuilder<()> {
                HostTokenBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostToken>> for HostToken {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostToken> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostToken>> for HostToken {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostToken>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostToken> for HostToken {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostToken> {
                HostToken::create(builder, &self.token)
            }
        }

        /// Builder for serializing an instance of the [HostToken] type.
        ///
        /// Can be created using the [HostToken::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostTokenBuilder<State>(State);

        impl HostTokenBuilder<()> {
            /// Setter for the [`token` field](HostToken#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> HostTokenBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                HostTokenBuilder((value,))
            }
        }

        impl<T0> HostTokenBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostToken].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostToken>
            where
                Self: ::planus::WriteAsOffset<HostToken>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<HostToken>> for HostTokenBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostToken>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostToken> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<HostToken>> for HostTokenBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostToken>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostToken>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<HostToken>
            for HostTokenBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostToken> {
                let (v0,) = &self.0;
                HostToken::create(builder, v0)
            }
        }

        /// Reference to a deserialized [HostToken].
        #[derive(Copy, Clone)]
        pub struct HostTokenRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostTokenRef<'a> {
            /// Getter for the [`token` field](HostToken#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "HostToken", "token")
            }
        }

        impl<'a> ::core::fmt::Debug for HostTokenRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostTokenRef");
                f.field("token", &self.token());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostTokenRef<'a>> for HostToken {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostTokenRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::core::convert::Into::into(value.token()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostTokenRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostTokenRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostTokenRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostToken>> for HostToken {
            type Value = ::planus::Offset<HostToken>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostToken>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostTokenRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HostTokenRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ClientToken` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ClientToken` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:13`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ClientToken {
            /// The field `token` in the table `ClientToken`
            pub token: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ClientToken {
            fn default() -> Self {
                Self {
                    token: ::core::default::Default::default(),
                }
            }
        }

        impl ClientToken {
            /// Creates a [ClientTokenBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ClientTokenBuilder<()> {
                ClientTokenBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ClientToken>> for ClientToken {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientToken> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ClientToken>> for ClientToken {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientToken>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ClientToken> for ClientToken {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientToken> {
                ClientToken::create(builder, &self.token)
            }
        }

        /// Builder for serializing an instance of the [ClientToken] type.
        ///
        /// Can be created using the [ClientToken::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ClientTokenBuilder<State>(State);

        impl ClientTokenBuilder<()> {
            /// Setter for the [`token` field](ClientToken#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> ClientTokenBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                ClientTokenBuilder((value,))
            }
        }

        impl<T0> ClientTokenBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ClientToken].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientToken>
            where
                Self: ::planus::WriteAsOffset<ClientToken>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<ClientToken>> for ClientTokenBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ClientToken>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientToken> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<ClientToken>> for ClientTokenBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ClientToken>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientToken>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<ClientToken>
            for ClientTokenBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientToken> {
                let (v0,) = &self.0;
                ClientToken::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ClientToken].
        #[derive(Copy, Clone)]
        pub struct ClientTokenRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ClientTokenRef<'a> {
            /// Getter for the [`token` field](ClientToken#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "ClientToken", "token")
            }
        }

        impl<'a> ::core::fmt::Debug for ClientTokenRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ClientTokenRef");
                f.field("token", &self.token());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ClientTokenRef<'a>> for ClientToken {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ClientTokenRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::core::convert::Into::into(value.token()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ClientTokenRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ClientTokenRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ClientTokenRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ClientToken>> for ClientToken {
            type Value = ::planus::Offset<ClientToken>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ClientToken>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ClientTokenRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ClientTokenRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `AuthToken` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `AuthToken` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:17`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct AuthToken {
            /// The field `token` in the table `AuthToken`
            pub token: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for AuthToken {
            fn default() -> Self {
                Self {
                    token: ::core::default::Default::default(),
                }
            }
        }

        impl AuthToken {
            /// Creates a [AuthTokenBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AuthTokenBuilder<()> {
                AuthTokenBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<AuthToken>> for AuthToken {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AuthToken> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<AuthToken>> for AuthToken {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AuthToken>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<AuthToken> for AuthToken {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AuthToken> {
                AuthToken::create(builder, &self.token)
            }
        }

        /// Builder for serializing an instance of the [AuthToken] type.
        ///
        /// Can be created using the [AuthToken::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AuthTokenBuilder<State>(State);

        impl AuthTokenBuilder<()> {
            /// Setter for the [`token` field](AuthToken#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> AuthTokenBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                AuthTokenBuilder((value,))
            }
        }

        impl<T0> AuthTokenBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AuthToken].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<AuthToken>
            where
                Self: ::planus::WriteAsOffset<AuthToken>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<AuthToken>> for AuthTokenBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<AuthToken>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AuthToken> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<AuthToken>> for AuthTokenBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<AuthToken>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AuthToken>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<AuthToken>
            for AuthTokenBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AuthToken> {
                let (v0,) = &self.0;
                AuthToken::create(builder, v0)
            }
        }

        /// Reference to a deserialized [AuthToken].
        #[derive(Copy, Clone)]
        pub struct AuthTokenRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AuthTokenRef<'a> {
            /// Getter for the [`token` field](AuthToken#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "AuthToken", "token")
            }
        }

        impl<'a> ::core::fmt::Debug for AuthTokenRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AuthTokenRef");
                f.field("token", &self.token());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AuthTokenRef<'a>> for AuthToken {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AuthTokenRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::core::convert::Into::into(value.token()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AuthTokenRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AuthTokenRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[AuthTokenRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<AuthToken>> for AuthToken {
            type Value = ::planus::Offset<AuthToken>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<AuthToken>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AuthTokenRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AuthTokenRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerToken` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerToken` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:21`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerToken {
            /// The field `token` in the table `WorkerToken`
            pub token: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerToken {
            fn default() -> Self {
                Self {
                    token: ::core::default::Default::default(),
                }
            }
        }

        impl WorkerToken {
            /// Creates a [WorkerTokenBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerTokenBuilder<()> {
                WorkerTokenBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerToken>> for WorkerToken {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerToken> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerToken>> for WorkerToken {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerToken>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerToken> for WorkerToken {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerToken> {
                WorkerToken::create(builder, &self.token)
            }
        }

        /// Builder for serializing an instance of the [WorkerToken] type.
        ///
        /// Can be created using the [WorkerToken::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerTokenBuilder<State>(State);

        impl WorkerTokenBuilder<()> {
            /// Setter for the [`token` field](WorkerToken#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> WorkerTokenBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                WorkerTokenBuilder((value,))
            }
        }

        impl<T0> WorkerTokenBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerToken].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerToken>
            where
                Self: ::planus::WriteAsOffset<WorkerToken>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<WorkerToken>> for WorkerTokenBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerToken>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerToken> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<WorkerToken>> for WorkerTokenBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerToken>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerToken>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<WorkerToken>
            for WorkerTokenBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerToken> {
                let (v0,) = &self.0;
                WorkerToken::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorkerToken].
        #[derive(Copy, Clone)]
        pub struct WorkerTokenRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerTokenRef<'a> {
            /// Getter for the [`token` field](WorkerToken#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "WorkerToken", "token")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerTokenRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerTokenRef");
                f.field("token", &self.token());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerTokenRef<'a>> for WorkerToken {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerTokenRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::core::convert::Into::into(value.token()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerTokenRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerTokenRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerTokenRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerToken>> for WorkerToken {
            type Value = ::planus::Offset<WorkerToken>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerToken>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerTokenRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerTokenRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VarBytes` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VarBytes` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:29`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VarBytes {
            /// The field `data` in the table `VarBytes`
            pub data: ::planus::alloc::vec::Vec<u8>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VarBytes {
            fn default() -> Self {
                Self {
                    data: ::core::default::Default::default(),
                }
            }
        }

        impl VarBytes {
            /// Creates a [VarBytesBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VarBytesBuilder<()> {
                VarBytesBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_data = field_data.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[u8]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_data);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VarBytes>> for VarBytes {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBytes> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VarBytes>> for VarBytes {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarBytes>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VarBytes> for VarBytes {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBytes> {
                VarBytes::create(builder, &self.data)
            }
        }

        /// Builder for serializing an instance of the [VarBytes] type.
        ///
        /// Can be created using the [VarBytes::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VarBytesBuilder<State>(State);

        impl VarBytesBuilder<()> {
            /// Setter for the [`data` field](VarBytes#structfield.data).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn data<T0>(self, value: T0) -> VarBytesBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
            {
                VarBytesBuilder((value,))
            }
        }

        impl<T0> VarBytesBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VarBytes].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBytes>
            where
                Self: ::planus::WriteAsOffset<VarBytes>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAs<::planus::Offset<VarBytes>> for VarBytesBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarBytes>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBytes> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAsOptional<::planus::Offset<VarBytes>> for VarBytesBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VarBytes>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VarBytes>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>> ::planus::WriteAsOffset<VarBytes>
            for VarBytesBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VarBytes> {
                let (v0,) = &self.0;
                VarBytes::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VarBytes].
        #[derive(Copy, Clone)]
        pub struct VarBytesRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VarBytesRef<'a> {
            /// Getter for the [`data` field](VarBytes#structfield.data).
            #[inline]
            pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                self.0.access_required(0, "VarBytes", "data")
            }
        }

        impl<'a> ::core::fmt::Debug for VarBytesRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VarBytesRef");
                f.field("data", &self.data());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VarBytesRef<'a>> for VarBytes {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VarBytesRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    data: value.data()?.to_vec(),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VarBytesRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VarBytesRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VarBytesRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VarBytes>> for VarBytes {
            type Value = ::planus::Offset<VarBytes>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VarBytes>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VarBytesRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VarBytesRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Symbol` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Symbol` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:33`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Symbol {
            /// The field `value` in the table `Symbol`
            pub value: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Symbol {
            fn default() -> Self {
                Self {
                    value: ::core::default::Default::default(),
                }
            }
        }

        impl Symbol {
            /// Creates a [SymbolBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> SymbolBuilder<()> {
                SymbolBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Symbol>> for Symbol {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Symbol> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Symbol>> for Symbol {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Symbol>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Symbol> for Symbol {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Symbol> {
                Symbol::create(builder, &self.value)
            }
        }

        /// Builder for serializing an instance of the [Symbol] type.
        ///
        /// Can be created using the [Symbol::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct SymbolBuilder<State>(State);

        impl SymbolBuilder<()> {
            /// Setter for the [`value` field](Symbol#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T0>(self, value: T0) -> SymbolBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                SymbolBuilder((value,))
            }
        }

        impl<T0> SymbolBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Symbol].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Symbol>
            where
                Self: ::planus::WriteAsOffset<Symbol>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<Symbol>> for SymbolBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Symbol>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Symbol> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<Symbol>> for SymbolBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Symbol>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Symbol>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<Symbol>
            for SymbolBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Symbol> {
                let (v0,) = &self.0;
                Symbol::create(builder, v0)
            }
        }

        /// Reference to a deserialized [Symbol].
        #[derive(Copy, Clone)]
        pub struct SymbolRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> SymbolRef<'a> {
            /// Getter for the [`value` field](Symbol#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "Symbol", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for SymbolRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("SymbolRef");
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<SymbolRef<'a>> for Symbol {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: SymbolRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value: ::core::convert::Into::into(value.value()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for SymbolRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for SymbolRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[SymbolRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Symbol>> for Symbol {
            type Value = ::planus::Offset<Symbol>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Symbol>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for SymbolRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[SymbolRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Uuid` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Uuid` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:37`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Uuid {
            /// The field `data` in the table `Uuid`
            pub data: ::planus::alloc::vec::Vec<u8>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Uuid {
            fn default() -> Self {
                Self {
                    data: ::core::default::Default::default(),
                }
            }
        }

        impl Uuid {
            /// Creates a [UuidBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UuidBuilder<()> {
                UuidBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_data = field_data.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[u8]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_data);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Uuid>> for Uuid {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Uuid> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Uuid>> for Uuid {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Uuid>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Uuid> for Uuid {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Uuid> {
                Uuid::create(builder, &self.data)
            }
        }

        /// Builder for serializing an instance of the [Uuid] type.
        ///
        /// Can be created using the [Uuid::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UuidBuilder<State>(State);

        impl UuidBuilder<()> {
            /// Setter for the [`data` field](Uuid#structfield.data).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn data<T0>(self, value: T0) -> UuidBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
            {
                UuidBuilder((value,))
            }
        }

        impl<T0> UuidBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Uuid].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Uuid>
            where
                Self: ::planus::WriteAsOffset<Uuid>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAs<::planus::Offset<Uuid>> for UuidBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Uuid>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Uuid> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
            ::planus::WriteAsOptional<::planus::Offset<Uuid>> for UuidBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Uuid>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Uuid>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>> ::planus::WriteAsOffset<Uuid>
            for UuidBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Uuid> {
                let (v0,) = &self.0;
                Uuid::create(builder, v0)
            }
        }

        /// Reference to a deserialized [Uuid].
        #[derive(Copy, Clone)]
        pub struct UuidRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UuidRef<'a> {
            /// Getter for the [`data` field](Uuid#structfield.data).
            #[inline]
            pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                self.0.access_required(0, "Uuid", "data")
            }
        }

        impl<'a> ::core::fmt::Debug for UuidRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UuidRef");
                f.field("data", &self.data());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UuidRef<'a>> for Uuid {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UuidRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    data: value.data()?.to_vec(),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UuidRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UuidRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[UuidRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Uuid>> for Uuid {
            type Value = ::planus::Offset<Uuid>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Uuid>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UuidRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UuidRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `ObjUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `ObjUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:45`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum ObjUnion {
            /// The variant of type `ObjId` in the union `ObjUnion`
            ObjId(::planus::alloc::boxed::Box<self::ObjId>),

            /// The variant of type `UuObjId` in the union `ObjUnion`
            UuObjId(::planus::alloc::boxed::Box<self::UuObjId>),

            /// The variant of type `AnonymousObjId` in the union `ObjUnion`
            AnonymousObjId(::planus::alloc::boxed::Box<self::AnonymousObjId>),
        }

        impl ObjUnion {
            /// Creates a [ObjUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjUnionBuilder<::planus::Uninitialized> {
                ObjUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_obj_id(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjId>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_uu_obj_id(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::UuObjId>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_anonymous_obj_id(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::AnonymousObjId>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<ObjUnion> for ObjUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::ObjId(value) => Self::create_obj_id(builder, value),
                    Self::UuObjId(value) => Self::create_uu_obj_id(builder, value),
                    Self::AnonymousObjId(value) => Self::create_anonymous_obj_id(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<ObjUnion> for ObjUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [ObjUnion] type.
        ///
        /// Can be created using the [ObjUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjUnionBuilder<T>(T);

        impl ObjUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`ObjId` variant](ObjUnion#variant.ObjId).
            #[inline]
            pub fn obj_id<T>(self, value: T) -> ObjUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjId>,
            {
                ObjUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`UuObjId` variant](ObjUnion#variant.UuObjId).
            #[inline]
            pub fn uu_obj_id<T>(self, value: T) -> ObjUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::UuObjId>,
            {
                ObjUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`AnonymousObjId` variant](ObjUnion#variant.AnonymousObjId).
            #[inline]
            pub fn anonymous_obj_id<T>(
                self,
                value: T,
            ) -> ObjUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::AnonymousObjId>,
            {
                ObjUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> ObjUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [ObjUnion].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<ObjUnion>
            where
                Self: ::planus::WriteAsUnion<ObjUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjId>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<ObjUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjId>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::UuObjId>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<ObjUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::UuObjId>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::AnonymousObjId>,
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<ObjUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjUnion> for ObjUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::AnonymousObjId>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [ObjUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum ObjUnionRef<'a> {
            ObjId(self::ObjIdRef<'a>),
            UuObjId(self::UuObjIdRef<'a>),
            AnonymousObjId(self::AnonymousObjIdRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<ObjUnionRef<'a>> for ObjUnion {
            type Error = ::planus::Error;

            fn try_from(value: ObjUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    ObjUnionRef::ObjId(value) => Self::ObjId(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    ObjUnionRef::UuObjId(value) => Self::UuObjId(::planus::alloc::boxed::Box::new(
                        ::core::convert::TryFrom::try_from(value)?,
                    )),

                    ObjUnionRef::AnonymousObjId(value) => {
                        Self::AnonymousObjId(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for ObjUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::ObjId(::planus::TableRead::from_buffer(
                        buffer,
                        field_offset,
                    )?)),
                    2 => ::core::result::Result::Ok(Self::UuObjId(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::AnonymousObjId(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for ObjUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[ObjUnionRef]";
        }

        /// The table `ObjId` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ObjId` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:51`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjId {
            /// The field `id` in the table `ObjId`
            pub id: i32,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ObjId {
            fn default() -> Self {
                Self { id: 0 }
            }
        }

        impl ObjId {
            /// Creates a [ObjIdBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjIdBuilder<()> {
                ObjIdBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_id: impl ::planus::WriteAsDefault<i32, i32>,
            ) -> ::planus::Offset<Self> {
                let prepared_id = field_id.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_id.is_some() {
                    table_writer.write_entry::<i32>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_id) = prepared_id {
                            object_writer.write::<_, _, 4>(&prepared_id);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjId>> for ObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjId>> for ObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjId> for ObjId {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjId> {
                ObjId::create(builder, self.id)
            }
        }

        /// Builder for serializing an instance of the [ObjId] type.
        ///
        /// Can be created using the [ObjId::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjIdBuilder<State>(State);

        impl ObjIdBuilder<()> {
            /// Setter for the [`id` field](ObjId#structfield.id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id<T0>(self, value: T0) -> ObjIdBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<i32, i32>,
            {
                ObjIdBuilder((value,))
            }

            /// Sets the [`id` field](ObjId#structfield.id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id_as_default(self) -> ObjIdBuilder<(::planus::DefaultValue,)> {
                self.id(::planus::DefaultValue)
            }
        }

        impl<T0> ObjIdBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjId].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjId>
            where
                Self: ::planus::WriteAsOffset<ObjId>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i32, i32>> ::planus::WriteAs<::planus::Offset<ObjId>>
            for ObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjId>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i32, i32>>
            ::planus::WriteAsOptional<::planus::Offset<ObjId>> for ObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjId>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<i32, i32>> ::planus::WriteAsOffset<ObjId>
            for ObjIdBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjId> {
                let (v0,) = &self.0;
                ObjId::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjId].
        #[derive(Copy, Clone)]
        pub struct ObjIdRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjIdRef<'a> {
            /// Getter for the [`id` field](ObjId#structfield.id).
            #[inline]
            pub fn id(&self) -> ::planus::Result<i32> {
                ::core::result::Result::Ok(self.0.access(0, "ObjId", "id")?.unwrap_or(0))
            }
        }

        impl<'a> ::core::fmt::Debug for ObjIdRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjIdRef");
                f.field("id", &self.id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjIdRef<'a>> for ObjId {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjIdRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    id: ::core::convert::TryInto::try_into(value.id()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjIdRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjIdRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[ObjIdRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjId>> for ObjId {
            type Value = ::planus::Offset<ObjId>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjId>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjIdRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjIdRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `UuObjId` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `UuObjId` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:55`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct UuObjId {
            /// The field `packed_value` in the table `UuObjId`
            pub packed_value: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for UuObjId {
            fn default() -> Self {
                Self { packed_value: 0 }
            }
        }

        impl UuObjId {
            /// Creates a [UuObjIdBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UuObjIdBuilder<()> {
                UuObjIdBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_packed_value: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_packed_value = field_packed_value.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_packed_value.is_some() {
                    table_writer.write_entry::<u64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_packed_value) =
                            prepared_packed_value
                        {
                            object_writer.write::<_, _, 8>(&prepared_packed_value);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<UuObjId>> for UuObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UuObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<UuObjId>> for UuObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UuObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<UuObjId> for UuObjId {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UuObjId> {
                UuObjId::create(builder, self.packed_value)
            }
        }

        /// Builder for serializing an instance of the [UuObjId] type.
        ///
        /// Can be created using the [UuObjId::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UuObjIdBuilder<State>(State);

        impl UuObjIdBuilder<()> {
            /// Setter for the [`packed_value` field](UuObjId#structfield.packed_value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn packed_value<T0>(self, value: T0) -> UuObjIdBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                UuObjIdBuilder((value,))
            }

            /// Sets the [`packed_value` field](UuObjId#structfield.packed_value) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn packed_value_as_default(self) -> UuObjIdBuilder<(::planus::DefaultValue,)> {
                self.packed_value(::planus::DefaultValue)
            }
        }

        impl<T0> UuObjIdBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UuObjId].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<UuObjId>
            where
                Self: ::planus::WriteAsOffset<UuObjId>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAs<::planus::Offset<UuObjId>>
            for UuObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<UuObjId>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UuObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<UuObjId>> for UuObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<UuObjId>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UuObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAsOffset<UuObjId>
            for UuObjIdBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UuObjId> {
                let (v0,) = &self.0;
                UuObjId::create(builder, v0)
            }
        }

        /// Reference to a deserialized [UuObjId].
        #[derive(Copy, Clone)]
        pub struct UuObjIdRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UuObjIdRef<'a> {
            /// Getter for the [`packed_value` field](UuObjId#structfield.packed_value).
            #[inline]
            pub fn packed_value(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0.access(0, "UuObjId", "packed_value")?.unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for UuObjIdRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UuObjIdRef");
                f.field("packed_value", &self.packed_value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UuObjIdRef<'a>> for UuObjId {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UuObjIdRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    packed_value: ::core::convert::TryInto::try_into(value.packed_value()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UuObjIdRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UuObjIdRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[UuObjIdRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<UuObjId>> for UuObjId {
            type Value = ::planus::Offset<UuObjId>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<UuObjId>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UuObjIdRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UuObjIdRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `AnonymousObjId` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `AnonymousObjId` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:60`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct AnonymousObjId {
            /// The field `packed_value` in the table `AnonymousObjId`
            pub packed_value: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for AnonymousObjId {
            fn default() -> Self {
                Self { packed_value: 0 }
            }
        }

        impl AnonymousObjId {
            /// Creates a [AnonymousObjIdBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AnonymousObjIdBuilder<()> {
                AnonymousObjIdBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_packed_value: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_packed_value = field_packed_value.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_packed_value.is_some() {
                    table_writer.write_entry::<u64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_packed_value) =
                            prepared_packed_value
                        {
                            object_writer.write::<_, _, 8>(&prepared_packed_value);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<AnonymousObjId>> for AnonymousObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AnonymousObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<AnonymousObjId>> for AnonymousObjId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AnonymousObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<AnonymousObjId> for AnonymousObjId {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AnonymousObjId> {
                AnonymousObjId::create(builder, self.packed_value)
            }
        }

        /// Builder for serializing an instance of the [AnonymousObjId] type.
        ///
        /// Can be created using the [AnonymousObjId::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AnonymousObjIdBuilder<State>(State);

        impl AnonymousObjIdBuilder<()> {
            /// Setter for the [`packed_value` field](AnonymousObjId#structfield.packed_value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn packed_value<T0>(self, value: T0) -> AnonymousObjIdBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                AnonymousObjIdBuilder((value,))
            }

            /// Sets the [`packed_value` field](AnonymousObjId#structfield.packed_value) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn packed_value_as_default(
                self,
            ) -> AnonymousObjIdBuilder<(::planus::DefaultValue,)> {
                self.packed_value(::planus::DefaultValue)
            }
        }

        impl<T0> AnonymousObjIdBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AnonymousObjId].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<AnonymousObjId>
            where
                Self: ::planus::WriteAsOffset<AnonymousObjId>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAs<::planus::Offset<AnonymousObjId>> for AnonymousObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<AnonymousObjId>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AnonymousObjId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<AnonymousObjId>>
            for AnonymousObjIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<AnonymousObjId>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AnonymousObjId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAsOffset<AnonymousObjId>
            for AnonymousObjIdBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AnonymousObjId> {
                let (v0,) = &self.0;
                AnonymousObjId::create(builder, v0)
            }
        }

        /// Reference to a deserialized [AnonymousObjId].
        #[derive(Copy, Clone)]
        pub struct AnonymousObjIdRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AnonymousObjIdRef<'a> {
            /// Getter for the [`packed_value` field](AnonymousObjId#structfield.packed_value).
            #[inline]
            pub fn packed_value(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "AnonymousObjId", "packed_value")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for AnonymousObjIdRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AnonymousObjIdRef");
                f.field("packed_value", &self.packed_value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AnonymousObjIdRef<'a>> for AnonymousObjId {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AnonymousObjIdRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    packed_value: ::core::convert::TryInto::try_into(value.packed_value()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AnonymousObjIdRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AnonymousObjIdRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[AnonymousObjIdRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<AnonymousObjId>> for AnonymousObjId {
            type Value = ::planus::Offset<AnonymousObjId>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<AnonymousObjId>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AnonymousObjIdRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AnonymousObjIdRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Obj` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Obj` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:65`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Obj {
            /// The field `obj` in the table `Obj`
            pub obj: self::ObjUnion,
        }

        impl Obj {
            /// Creates a [ObjBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjBuilder<()> {
                ObjBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAsUnion<self::ObjUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ObjUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj.offset());
                        object_writer.write::<_, _, 1>(&prepared_obj.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Obj>> for Obj {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Obj> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Obj>> for Obj {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Obj>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Obj> for Obj {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Obj> {
                Obj::create(builder, &self.obj)
            }
        }

        /// Builder for serializing an instance of the [Obj] type.
        ///
        /// Can be created using the [Obj::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjBuilder<State>(State);

        impl ObjBuilder<()> {
            /// Setter for the [`obj` field](Obj#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> ObjBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::ObjUnion>,
            {
                ObjBuilder((value,))
            }
        }

        impl<T0> ObjBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Obj].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Obj>
            where
                Self: ::planus::WriteAsOffset<Obj>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjUnion>> ::planus::WriteAs<::planus::Offset<Obj>>
            for ObjBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Obj>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Obj> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjUnion>>
            ::planus::WriteAsOptional<::planus::Offset<Obj>> for ObjBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Obj>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Obj>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjUnion>> ::planus::WriteAsOffset<Obj>
            for ObjBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Obj> {
                let (v0,) = &self.0;
                Obj::create(builder, v0)
            }
        }

        /// Reference to a deserialized [Obj].
        #[derive(Copy, Clone)]
        pub struct ObjRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjRef<'a> {
            /// Getter for the [`obj` field](Obj#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjUnionRef<'a>> {
                self.0.access_union_required(0, "Obj", "obj")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjRef");
                f.field("obj", &self.obj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjRef<'a>> for Obj {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::core::convert::TryInto::try_into(value.obj()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[ObjRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Obj>> for Obj {
            type Value = ::planus::Offset<Obj>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Obj>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| error_kind.with_error_location("[ObjRef]", "read_as_root", 0))
            }
        }

        /// The enum `ErrorCode` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Enum `ErrorCode` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:73`
        #[derive(
            Copy,
            Clone,
            Debug,
            PartialEq,
            Eq,
            PartialOrd,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        #[repr(u8)]
        pub enum ErrorCode {
            /// The variant `E_NONE` in the enum `ErrorCode`
            ENone = 0,

            /// The variant `E_TYPE` in the enum `ErrorCode`
            EType = 1,

            /// The variant `E_DIV` in the enum `ErrorCode`
            EDiv = 2,

            /// The variant `E_PERM` in the enum `ErrorCode`
            EPerm = 3,

            /// The variant `E_PROPNF` in the enum `ErrorCode`
            EPropnf = 4,

            /// The variant `E_VERBNF` in the enum `ErrorCode`
            EVerbnf = 5,

            /// The variant `E_VARNF` in the enum `ErrorCode`
            EVarnf = 6,

            /// The variant `E_INVIND` in the enum `ErrorCode`
            EInvind = 7,

            /// The variant `E_RECMOVE` in the enum `ErrorCode`
            ERecmove = 8,

            /// The variant `E_MAXREC` in the enum `ErrorCode`
            EMaxrec = 9,

            /// The variant `E_RANGE` in the enum `ErrorCode`
            ERange = 10,

            /// The variant `E_ARGS` in the enum `ErrorCode`
            EArgs = 11,

            /// The variant `E_NACC` in the enum `ErrorCode`
            ENacc = 12,

            /// The variant `E_INVARG` in the enum `ErrorCode`
            EInvarg = 13,

            /// The variant `E_QUOTA` in the enum `ErrorCode`
            EQuota = 14,

            /// The variant `E_FLOAT` in the enum `ErrorCode`
            EFloat = 15,

            /// The variant `E_FILE` in the enum `ErrorCode`
            EFile = 16,

            /// The variant `E_EXEC` in the enum `ErrorCode`
            EExec = 17,

            /// The variant `E_INTRPT` in the enum `ErrorCode`
            EIntrpt = 18,

            /// The variant `ErrCustom` in the enum `ErrorCode`
            ErrCustom = 255,
        }

        impl ErrorCode {
            /// Array containing all valid variants of ErrorCode
            pub const ENUM_VALUES: [Self; 20] = [
                Self::ENone,
                Self::EType,
                Self::EDiv,
                Self::EPerm,
                Self::EPropnf,
                Self::EVerbnf,
                Self::EVarnf,
                Self::EInvind,
                Self::ERecmove,
                Self::EMaxrec,
                Self::ERange,
                Self::EArgs,
                Self::ENacc,
                Self::EInvarg,
                Self::EQuota,
                Self::EFloat,
                Self::EFile,
                Self::EExec,
                Self::EIntrpt,
                Self::ErrCustom,
            ];
        }

        impl ::core::convert::TryFrom<u8> for ErrorCode {
            type Error = ::planus::errors::UnknownEnumTagKind;
            #[inline]
            fn try_from(
                value: u8,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind> {
                #[allow(clippy::match_single_binding)]
                match value {
                    0 => ::core::result::Result::Ok(ErrorCode::ENone),
                    1 => ::core::result::Result::Ok(ErrorCode::EType),
                    2 => ::core::result::Result::Ok(ErrorCode::EDiv),
                    3 => ::core::result::Result::Ok(ErrorCode::EPerm),
                    4 => ::core::result::Result::Ok(ErrorCode::EPropnf),
                    5 => ::core::result::Result::Ok(ErrorCode::EVerbnf),
                    6 => ::core::result::Result::Ok(ErrorCode::EVarnf),
                    7 => ::core::result::Result::Ok(ErrorCode::EInvind),
                    8 => ::core::result::Result::Ok(ErrorCode::ERecmove),
                    9 => ::core::result::Result::Ok(ErrorCode::EMaxrec),
                    10 => ::core::result::Result::Ok(ErrorCode::ERange),
                    11 => ::core::result::Result::Ok(ErrorCode::EArgs),
                    12 => ::core::result::Result::Ok(ErrorCode::ENacc),
                    13 => ::core::result::Result::Ok(ErrorCode::EInvarg),
                    14 => ::core::result::Result::Ok(ErrorCode::EQuota),
                    15 => ::core::result::Result::Ok(ErrorCode::EFloat),
                    16 => ::core::result::Result::Ok(ErrorCode::EFile),
                    17 => ::core::result::Result::Ok(ErrorCode::EExec),
                    18 => ::core::result::Result::Ok(ErrorCode::EIntrpt),
                    255 => ::core::result::Result::Ok(ErrorCode::ErrCustom),

                    _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                        tag: value as i128,
                    }),
                }
            }
        }

        impl ::core::convert::From<ErrorCode> for u8 {
            #[inline]
            fn from(value: ErrorCode) -> Self {
                value as u8
            }
        }

        /// # Safety
        /// The Planus compiler correctly calculates `ALIGNMENT` and `SIZE`.
        unsafe impl ::planus::Primitive for ErrorCode {
            const ALIGNMENT: usize = 1;
            const SIZE: usize = 1;
        }

        impl ::planus::WriteAsPrimitive<ErrorCode> for ErrorCode {
            #[inline]
            fn write<const N: usize>(&self, cursor: ::planus::Cursor<'_, N>, buffer_position: u32) {
                (*self as u8).write(cursor, buffer_position);
            }
        }

        impl ::planus::WriteAs<ErrorCode> for ErrorCode {
            type Prepared = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> ErrorCode {
                *self
            }
        }

        impl ::planus::WriteAsDefault<ErrorCode, ErrorCode> for ErrorCode {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
                default: &ErrorCode,
            ) -> ::core::option::Option<ErrorCode> {
                if self == default {
                    ::core::option::Option::None
                } else {
                    ::core::option::Option::Some(*self)
                }
            }
        }

        impl ::planus::WriteAsOptional<ErrorCode> for ErrorCode {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<ErrorCode> {
                ::core::option::Option::Some(*self)
            }
        }

        impl<'buf> ::planus::TableRead<'buf> for ErrorCode {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
            }
        }

        impl<'buf> ::planus::VectorReadInner<'buf> for ErrorCode {
            type Error = ::planus::errors::UnknownEnumTag;
            const STRIDE: usize = 1;
            #[inline]
            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag> {
                let value = unsafe { *buffer.buffer.get_unchecked(offset) };
                let value: ::core::result::Result<Self, _> =
                    ::core::convert::TryInto::try_into(value);
                value.map_err(|error_kind| {
                    error_kind.with_error_location(
                        "ErrorCode",
                        "VectorRead::from_buffer",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<ErrorCode> for ErrorCode {
            const STRIDE: usize = 1;

            type Value = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                *self
            }

            #[inline]
            unsafe fn write_values(
                values: &[Self],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - i as u32,
                    );
                }
            }
        }

        /// The table `Error` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Error` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:96`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Error {
            /// The field `err_type` in the table `Error`
            pub err_type: self::ErrorCode,
            /// The field `msg` in the table `Error`
            pub msg: ::core::option::Option<::planus::alloc::string::String>,
            /// The field `value` in the table `Error`
            pub value: ::core::option::Option<::planus::alloc::boxed::Box<self::VarBytes>>,
            /// The field `custom_symbol` in the table `Error`
            pub custom_symbol: ::core::option::Option<::planus::alloc::boxed::Box<self::Symbol>>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Error {
            fn default() -> Self {
                Self {
                    err_type: self::ErrorCode::ENone,
                    msg: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    custom_symbol: ::core::default::Default::default(),
                }
            }
        }

        impl Error {
            /// Creates a [ErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ErrorBuilder<()> {
                ErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_err_type: impl ::planus::WriteAsDefault<self::ErrorCode, self::ErrorCode>,
                field_msg: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                field_value: impl ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
                field_custom_symbol: impl ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_err_type = field_err_type.prepare(builder, &self::ErrorCode::ENone);
                let prepared_msg = field_msg.prepare(builder);
                let prepared_value = field_value.prepare(builder);
                let prepared_custom_symbol = field_custom_symbol.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                if prepared_msg.is_some() {
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                }
                if prepared_value.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::VarBytes>>(2);
                }
                if prepared_custom_symbol.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::Symbol>>(3);
                }
                if prepared_err_type.is_some() {
                    table_writer.write_entry::<self::ErrorCode>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_msg) = prepared_msg {
                            object_writer.write::<_, _, 4>(&prepared_msg);
                        }
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            object_writer.write::<_, _, 4>(&prepared_value);
                        }
                        if let ::core::option::Option::Some(prepared_custom_symbol) =
                            prepared_custom_symbol
                        {
                            object_writer.write::<_, _, 4>(&prepared_custom_symbol);
                        }
                        if let ::core::option::Option::Some(prepared_err_type) = prepared_err_type {
                            object_writer.write::<_, _, 1>(&prepared_err_type);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Error>> for Error {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Error> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Error>> for Error {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Error>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Error> for Error {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Error> {
                Error::create(
                    builder,
                    self.err_type,
                    &self.msg,
                    &self.value,
                    &self.custom_symbol,
                )
            }
        }

        /// Builder for serializing an instance of the [Error] type.
        ///
        /// Can be created using the [Error::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ErrorBuilder<State>(State);

        impl ErrorBuilder<()> {
            /// Setter for the [`err_type` field](Error#structfield.err_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn err_type<T0>(self, value: T0) -> ErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<self::ErrorCode, self::ErrorCode>,
            {
                ErrorBuilder((value,))
            }

            /// Sets the [`err_type` field](Error#structfield.err_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn err_type_as_default(self) -> ErrorBuilder<(::planus::DefaultValue,)> {
                self.err_type(::planus::DefaultValue)
            }
        }

        impl<T0> ErrorBuilder<(T0,)> {
            /// Setter for the [`msg` field](Error#structfield.msg).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn msg<T1>(self, value: T1) -> ErrorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            {
                let (v0,) = self.0;
                ErrorBuilder((v0, value))
            }

            /// Sets the [`msg` field](Error#structfield.msg) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn msg_as_null(self) -> ErrorBuilder<(T0, ())> {
                self.msg(())
            }
        }

        impl<T0, T1> ErrorBuilder<(T0, T1)> {
            /// Setter for the [`value` field](Error#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T2>(self, value: T2) -> ErrorBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
            {
                let (v0, v1) = self.0;
                ErrorBuilder((v0, v1, value))
            }

            /// Sets the [`value` field](Error#structfield.value) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value_as_null(self) -> ErrorBuilder<(T0, T1, ())> {
                self.value(())
            }
        }

        impl<T0, T1, T2> ErrorBuilder<(T0, T1, T2)> {
            /// Setter for the [`custom_symbol` field](Error#structfield.custom_symbol).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn custom_symbol<T3>(self, value: T3) -> ErrorBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            {
                let (v0, v1, v2) = self.0;
                ErrorBuilder((v0, v1, v2, value))
            }

            /// Sets the [`custom_symbol` field](Error#structfield.custom_symbol) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn custom_symbol_as_null(self) -> ErrorBuilder<(T0, T1, T2, ())> {
                self.custom_symbol(())
            }
        }

        impl<T0, T1, T2, T3> ErrorBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Error].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Error>
            where
                Self: ::planus::WriteAsOffset<Error>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::ErrorCode, self::ErrorCode>,
            T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<Error>> for ErrorBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<Error>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Error> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::ErrorCode, self::ErrorCode>,
            T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<Error>> for ErrorBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<Error>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Error>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::ErrorCode, self::ErrorCode>,
            T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<Error> for ErrorBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Error> {
                let (v0, v1, v2, v3) = &self.0;
                Error::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [Error].
        #[derive(Copy, Clone)]
        pub struct ErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ErrorRef<'a> {
            /// Getter for the [`err_type` field](Error#structfield.err_type).
            #[inline]
            pub fn err_type(&self) -> ::planus::Result<self::ErrorCode> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "Error", "err_type")?
                        .unwrap_or(self::ErrorCode::ENone),
                )
            }

            /// Getter for the [`msg` field](Error#structfield.msg).
            #[inline]
            pub fn msg(
                &self,
            ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>> {
                self.0.access(1, "Error", "msg")
            }

            /// Getter for the [`value` field](Error#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<::core::option::Option<self::VarBytesRef<'a>>> {
                self.0.access(2, "Error", "value")
            }

            /// Getter for the [`custom_symbol` field](Error#structfield.custom_symbol).
            #[inline]
            pub fn custom_symbol(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::SymbolRef<'a>>> {
                self.0.access(3, "Error", "custom_symbol")
            }
        }

        impl<'a> ::core::fmt::Debug for ErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ErrorRef");
                f.field("err_type", &self.err_type());
                if let ::core::option::Option::Some(field_msg) = self.msg().transpose() {
                    f.field("msg", &field_msg);
                }
                if let ::core::option::Option::Some(field_value) = self.value().transpose() {
                    f.field("value", &field_value);
                }
                if let ::core::option::Option::Some(field_custom_symbol) =
                    self.custom_symbol().transpose()
                {
                    f.field("custom_symbol", &field_custom_symbol);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ErrorRef<'a>> for Error {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    err_type: ::core::convert::TryInto::try_into(value.err_type()?)?,
                    msg: value.msg()?.map(::core::convert::Into::into),
                    value: if let ::core::option::Option::Some(value) = value.value()? {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                    custom_symbol: if let ::core::option::Option::Some(custom_symbol) =
                        value.custom_symbol()?
                    {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(custom_symbol)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[ErrorRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Error>> for Error {
            type Value = ::planus::Offset<Error>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Error>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `NarrativeEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `NarrativeEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:107`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct NarrativeEvent {
            /// The field `event_id` in the table `NarrativeEvent`
            pub event_id: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `timestamp` in the table `NarrativeEvent`
            pub timestamp: u64,
            /// The field `author` in the table `NarrativeEvent`
            pub author: ::planus::alloc::boxed::Box<self::VarBytes>,
            /// The field `event` in the table `NarrativeEvent`
            pub event: ::planus::alloc::boxed::Box<self::Event>,
        }

        impl NarrativeEvent {
            /// Creates a [NarrativeEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> NarrativeEventBuilder<()> {
                NarrativeEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_event_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                field_author: impl ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
                field_event: impl ::planus::WriteAs<::planus::Offset<self::Event>>,
            ) -> ::planus::Offset<Self> {
                let prepared_event_id = field_event_id.prepare(builder);
                let prepared_timestamp = field_timestamp.prepare(builder, &0);
                let prepared_author = field_author.prepare(builder);
                let prepared_event = field_event.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                if prepared_timestamp.is_some() {
                    table_writer.write_entry::<u64>(1);
                }
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(0);
                table_writer.write_entry::<::planus::Offset<self::VarBytes>>(2);
                table_writer.write_entry::<::planus::Offset<self::Event>>(3);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            object_writer.write::<_, _, 8>(&prepared_timestamp);
                        }
                        object_writer.write::<_, _, 4>(&prepared_event_id);
                        object_writer.write::<_, _, 4>(&prepared_author);
                        object_writer.write::<_, _, 4>(&prepared_event);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NarrativeEvent>> for NarrativeEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NarrativeEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NarrativeEvent>> for NarrativeEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NarrativeEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NarrativeEvent> for NarrativeEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NarrativeEvent> {
                NarrativeEvent::create(
                    builder,
                    &self.event_id,
                    self.timestamp,
                    &self.author,
                    &self.event,
                )
            }
        }

        /// Builder for serializing an instance of the [NarrativeEvent] type.
        ///
        /// Can be created using the [NarrativeEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct NarrativeEventBuilder<State>(State);

        impl NarrativeEventBuilder<()> {
            /// Setter for the [`event_id` field](NarrativeEvent#structfield.event_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event_id<T0>(self, value: T0) -> NarrativeEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                NarrativeEventBuilder((value,))
            }
        }

        impl<T0> NarrativeEventBuilder<(T0,)> {
            /// Setter for the [`timestamp` field](NarrativeEvent#structfield.timestamp).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp<T1>(self, value: T1) -> NarrativeEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                NarrativeEventBuilder((v0, value))
            }

            /// Sets the [`timestamp` field](NarrativeEvent#structfield.timestamp) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp_as_default(
                self,
            ) -> NarrativeEventBuilder<(T0, ::planus::DefaultValue)> {
                self.timestamp(::planus::DefaultValue)
            }
        }

        impl<T0, T1> NarrativeEventBuilder<(T0, T1)> {
            /// Setter for the [`author` field](NarrativeEvent#structfield.author).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn author<T2>(self, value: T2) -> NarrativeEventBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            {
                let (v0, v1) = self.0;
                NarrativeEventBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> NarrativeEventBuilder<(T0, T1, T2)> {
            /// Setter for the [`event` field](NarrativeEvent#structfield.event).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event<T3>(self, value: T3) -> NarrativeEventBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<self::Event>>,
            {
                let (v0, v1, v2) = self.0;
                NarrativeEventBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> NarrativeEventBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NarrativeEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<NarrativeEvent>
            where
                Self: ::planus::WriteAsOffset<NarrativeEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Event>>,
        > ::planus::WriteAs<::planus::Offset<NarrativeEvent>>
            for NarrativeEventBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<NarrativeEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NarrativeEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Event>>,
        > ::planus::WriteAsOptional<::planus::Offset<NarrativeEvent>>
            for NarrativeEventBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<NarrativeEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NarrativeEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Event>>,
        > ::planus::WriteAsOffset<NarrativeEvent> for NarrativeEventBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NarrativeEvent> {
                let (v0, v1, v2, v3) = &self.0;
                NarrativeEvent::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [NarrativeEvent].
        #[derive(Copy, Clone)]
        pub struct NarrativeEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> NarrativeEventRef<'a> {
            /// Getter for the [`event_id` field](NarrativeEvent#structfield.event_id).
            #[inline]
            pub fn event_id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(0, "NarrativeEvent", "event_id")
            }

            /// Getter for the [`timestamp` field](NarrativeEvent#structfield.timestamp).
            #[inline]
            pub fn timestamp(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "NarrativeEvent", "timestamp")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`author` field](NarrativeEvent#structfield.author).
            #[inline]
            pub fn author(&self) -> ::planus::Result<self::VarBytesRef<'a>> {
                self.0.access_required(2, "NarrativeEvent", "author")
            }

            /// Getter for the [`event` field](NarrativeEvent#structfield.event).
            #[inline]
            pub fn event(&self) -> ::planus::Result<self::EventRef<'a>> {
                self.0.access_required(3, "NarrativeEvent", "event")
            }
        }

        impl<'a> ::core::fmt::Debug for NarrativeEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("NarrativeEventRef");
                f.field("event_id", &self.event_id());
                f.field("timestamp", &self.timestamp());
                f.field("author", &self.author());
                f.field("event", &self.event());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<NarrativeEventRef<'a>> for NarrativeEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: NarrativeEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    event_id: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.event_id()?,
                    )?),
                    timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                    author: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.author()?,
                    )?),
                    event: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.event()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for NarrativeEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for NarrativeEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[NarrativeEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<NarrativeEvent>> for NarrativeEvent {
            type Value = ::planus::Offset<NarrativeEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<NarrativeEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for NarrativeEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[NarrativeEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `EventUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `EventUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:114`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum EventUnion {
            /// The variant of type `NotifyEvent` in the union `EventUnion`
            NotifyEvent(::planus::alloc::boxed::Box<self::NotifyEvent>),

            /// The variant of type `PresentEvent` in the union `EventUnion`
            PresentEvent(::planus::alloc::boxed::Box<self::PresentEvent>),

            /// The variant of type `UnpresentEvent` in the union `EventUnion`
            UnpresentEvent(::planus::alloc::boxed::Box<self::UnpresentEvent>),

            /// The variant of type `TracebackEvent` in the union `EventUnion`
            TracebackEvent(::planus::alloc::boxed::Box<self::TracebackEvent>),
        }

        impl EventUnion {
            /// Creates a [EventUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> EventUnionBuilder<::planus::Uninitialized> {
                EventUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_notify_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::NotifyEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_present_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PresentEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_unpresent_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::UnpresentEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_traceback_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::TracebackEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<EventUnion> for EventUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::NotifyEvent(value) => Self::create_notify_event(builder, value),
                    Self::PresentEvent(value) => Self::create_present_event(builder, value),
                    Self::UnpresentEvent(value) => Self::create_unpresent_event(builder, value),
                    Self::TracebackEvent(value) => Self::create_traceback_event(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<EventUnion> for EventUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [EventUnion] type.
        ///
        /// Can be created using the [EventUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct EventUnionBuilder<T>(T);

        impl EventUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`NotifyEvent` variant](EventUnion#variant.NotifyEvent).
            #[inline]
            pub fn notify_event<T>(self, value: T) -> EventUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::NotifyEvent>,
            {
                EventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PresentEvent` variant](EventUnion#variant.PresentEvent).
            #[inline]
            pub fn present_event<T>(
                self,
                value: T,
            ) -> EventUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::PresentEvent>,
            {
                EventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`UnpresentEvent` variant](EventUnion#variant.UnpresentEvent).
            #[inline]
            pub fn unpresent_event<T>(
                self,
                value: T,
            ) -> EventUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::UnpresentEvent>,
            {
                EventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`TracebackEvent` variant](EventUnion#variant.TracebackEvent).
            #[inline]
            pub fn traceback_event<T>(
                self,
                value: T,
            ) -> EventUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::TracebackEvent>,
            {
                EventUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> EventUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [EventUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<EventUnion>
            where
                Self: ::planus::WriteAsUnion<EventUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<EventUnion> for EventUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::NotifyEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<EventUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<EventUnion>
            for EventUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::NotifyEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<EventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<EventUnion> for EventUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::PresentEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<EventUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<EventUnion>
            for EventUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::PresentEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<EventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<EventUnion> for EventUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::UnpresentEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<EventUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<EventUnion>
            for EventUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::UnpresentEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<EventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<EventUnion> for EventUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::TracebackEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<EventUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<EventUnion>
            for EventUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::TracebackEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<EventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [EventUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum EventUnionRef<'a> {
            NotifyEvent(self::NotifyEventRef<'a>),
            PresentEvent(self::PresentEventRef<'a>),
            UnpresentEvent(self::UnpresentEventRef<'a>),
            TracebackEvent(self::TracebackEventRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<EventUnionRef<'a>> for EventUnion {
            type Error = ::planus::Error;

            fn try_from(value: EventUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    EventUnionRef::NotifyEvent(value) => {
                        Self::NotifyEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    EventUnionRef::PresentEvent(value) => {
                        Self::PresentEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    EventUnionRef::UnpresentEvent(value) => {
                        Self::UnpresentEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    EventUnionRef::TracebackEvent(value) => {
                        Self::TracebackEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for EventUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::NotifyEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::PresentEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::UnpresentEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::TracebackEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for EventUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[EventUnionRef]";
        }

        /// The table `NotifyEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `NotifyEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:121`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct NotifyEvent {
            /// The field `value` in the table `NotifyEvent`
            pub value: ::planus::alloc::boxed::Box<self::VarBytes>,
            /// The field `content_type` in the table `NotifyEvent`
            pub content_type: ::core::option::Option<::planus::alloc::boxed::Box<self::Symbol>>,
            /// The field `no_flush` in the table `NotifyEvent`
            pub no_flush: bool,
            /// The field `no_newline` in the table `NotifyEvent`
            pub no_newline: bool,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for NotifyEvent {
            fn default() -> Self {
                Self {
                    value: ::core::default::Default::default(),
                    content_type: ::core::default::Default::default(),
                    no_flush: false,
                    no_newline: false,
                }
            }
        }

        impl NotifyEvent {
            /// Creates a [NotifyEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> NotifyEventBuilder<()> {
                NotifyEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value: impl ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
                field_content_type: impl ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
                field_no_flush: impl ::planus::WriteAsDefault<bool, bool>,
                field_no_newline: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_value = field_value.prepare(builder);
                let prepared_content_type = field_content_type.prepare(builder);
                let prepared_no_flush = field_no_flush.prepare(builder, &false);
                let prepared_no_newline = field_no_newline.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::VarBytes>>(0);
                if prepared_content_type.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);
                }
                if prepared_no_flush.is_some() {
                    table_writer.write_entry::<bool>(2);
                }
                if prepared_no_newline.is_some() {
                    table_writer.write_entry::<bool>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_value);
                        if let ::core::option::Option::Some(prepared_content_type) =
                            prepared_content_type
                        {
                            object_writer.write::<_, _, 4>(&prepared_content_type);
                        }
                        if let ::core::option::Option::Some(prepared_no_flush) = prepared_no_flush {
                            object_writer.write::<_, _, 1>(&prepared_no_flush);
                        }
                        if let ::core::option::Option::Some(prepared_no_newline) =
                            prepared_no_newline
                        {
                            object_writer.write::<_, _, 1>(&prepared_no_newline);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NotifyEvent>> for NotifyEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NotifyEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NotifyEvent>> for NotifyEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NotifyEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NotifyEvent> for NotifyEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NotifyEvent> {
                NotifyEvent::create(
                    builder,
                    &self.value,
                    &self.content_type,
                    self.no_flush,
                    self.no_newline,
                )
            }
        }

        /// Builder for serializing an instance of the [NotifyEvent] type.
        ///
        /// Can be created using the [NotifyEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct NotifyEventBuilder<State>(State);

        impl NotifyEventBuilder<()> {
            /// Setter for the [`value` field](NotifyEvent#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T0>(self, value: T0) -> NotifyEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            {
                NotifyEventBuilder((value,))
            }
        }

        impl<T0> NotifyEventBuilder<(T0,)> {
            /// Setter for the [`content_type` field](NotifyEvent#structfield.content_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn content_type<T1>(self, value: T1) -> NotifyEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                NotifyEventBuilder((v0, value))
            }

            /// Sets the [`content_type` field](NotifyEvent#structfield.content_type) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn content_type_as_null(self) -> NotifyEventBuilder<(T0, ())> {
                self.content_type(())
            }
        }

        impl<T0, T1> NotifyEventBuilder<(T0, T1)> {
            /// Setter for the [`no_flush` field](NotifyEvent#structfield.no_flush).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn no_flush<T2>(self, value: T2) -> NotifyEventBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1) = self.0;
                NotifyEventBuilder((v0, v1, value))
            }

            /// Sets the [`no_flush` field](NotifyEvent#structfield.no_flush) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn no_flush_as_default(
                self,
            ) -> NotifyEventBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.no_flush(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> NotifyEventBuilder<(T0, T1, T2)> {
            /// Setter for the [`no_newline` field](NotifyEvent#structfield.no_newline).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn no_newline<T3>(self, value: T3) -> NotifyEventBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2) = self.0;
                NotifyEventBuilder((v0, v1, v2, value))
            }

            /// Sets the [`no_newline` field](NotifyEvent#structfield.no_newline) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn no_newline_as_default(
                self,
            ) -> NotifyEventBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.no_newline(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> NotifyEventBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NotifyEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<NotifyEvent>
            where
                Self: ::planus::WriteAsOffset<NotifyEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            T2: ::planus::WriteAsDefault<bool, bool>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAs<::planus::Offset<NotifyEvent>>
            for NotifyEventBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<NotifyEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NotifyEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            T2: ::planus::WriteAsDefault<bool, bool>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOptional<::planus::Offset<NotifyEvent>>
            for NotifyEventBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<NotifyEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NotifyEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::Symbol>>,
            T2: ::planus::WriteAsDefault<bool, bool>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOffset<NotifyEvent> for NotifyEventBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NotifyEvent> {
                let (v0, v1, v2, v3) = &self.0;
                NotifyEvent::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [NotifyEvent].
        #[derive(Copy, Clone)]
        pub struct NotifyEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> NotifyEventRef<'a> {
            /// Getter for the [`value` field](NotifyEvent#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<self::VarBytesRef<'a>> {
                self.0.access_required(0, "NotifyEvent", "value")
            }

            /// Getter for the [`content_type` field](NotifyEvent#structfield.content_type).
            #[inline]
            pub fn content_type(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::SymbolRef<'a>>> {
                self.0.access(1, "NotifyEvent", "content_type")
            }

            /// Getter for the [`no_flush` field](NotifyEvent#structfield.no_flush).
            #[inline]
            pub fn no_flush(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "NotifyEvent", "no_flush")?
                        .unwrap_or(false),
                )
            }

            /// Getter for the [`no_newline` field](NotifyEvent#structfield.no_newline).
            #[inline]
            pub fn no_newline(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "NotifyEvent", "no_newline")?
                        .unwrap_or(false),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for NotifyEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("NotifyEventRef");
                f.field("value", &self.value());
                if let ::core::option::Option::Some(field_content_type) =
                    self.content_type().transpose()
                {
                    f.field("content_type", &field_content_type);
                }
                f.field("no_flush", &self.no_flush());
                f.field("no_newline", &self.no_newline());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<NotifyEventRef<'a>> for NotifyEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: NotifyEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.value()?,
                    )?),
                    content_type: if let ::core::option::Option::Some(content_type) =
                        value.content_type()?
                    {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(content_type)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                    no_flush: ::core::convert::TryInto::try_into(value.no_flush()?)?,
                    no_newline: ::core::convert::TryInto::try_into(value.no_newline()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for NotifyEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for NotifyEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[NotifyEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<NotifyEvent>> for NotifyEvent {
            type Value = ::planus::Offset<NotifyEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<NotifyEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for NotifyEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[NotifyEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PresentEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PresentEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:128`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PresentEvent {
            /// The field `presentation` in the table `PresentEvent`
            pub presentation: ::planus::alloc::boxed::Box<self::Presentation>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PresentEvent {
            fn default() -> Self {
                Self {
                    presentation: ::core::default::Default::default(),
                }
            }
        }

        impl PresentEvent {
            /// Creates a [PresentEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PresentEventBuilder<()> {
                PresentEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_presentation: impl ::planus::WriteAs<::planus::Offset<self::Presentation>>,
            ) -> ::planus::Offset<Self> {
                let prepared_presentation = field_presentation.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Presentation>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_presentation);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PresentEvent>> for PresentEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PresentEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PresentEvent>> for PresentEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PresentEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PresentEvent> for PresentEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PresentEvent> {
                PresentEvent::create(builder, &self.presentation)
            }
        }

        /// Builder for serializing an instance of the [PresentEvent] type.
        ///
        /// Can be created using the [PresentEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PresentEventBuilder<State>(State);

        impl PresentEventBuilder<()> {
            /// Setter for the [`presentation` field](PresentEvent#structfield.presentation).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn presentation<T0>(self, value: T0) -> PresentEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Presentation>>,
            {
                PresentEventBuilder((value,))
            }
        }

        impl<T0> PresentEventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PresentEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PresentEvent>
            where
                Self: ::planus::WriteAsOffset<PresentEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Presentation>>>
            ::planus::WriteAs<::planus::Offset<PresentEvent>> for PresentEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PresentEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PresentEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Presentation>>>
            ::planus::WriteAsOptional<::planus::Offset<PresentEvent>>
            for PresentEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PresentEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PresentEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Presentation>>>
            ::planus::WriteAsOffset<PresentEvent> for PresentEventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PresentEvent> {
                let (v0,) = &self.0;
                PresentEvent::create(builder, v0)
            }
        }

        /// Reference to a deserialized [PresentEvent].
        #[derive(Copy, Clone)]
        pub struct PresentEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PresentEventRef<'a> {
            /// Getter for the [`presentation` field](PresentEvent#structfield.presentation).
            #[inline]
            pub fn presentation(&self) -> ::planus::Result<self::PresentationRef<'a>> {
                self.0.access_required(0, "PresentEvent", "presentation")
            }
        }

        impl<'a> ::core::fmt::Debug for PresentEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PresentEventRef");
                f.field("presentation", &self.presentation());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PresentEventRef<'a>> for PresentEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PresentEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    presentation: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.presentation()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PresentEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PresentEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PresentEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PresentEvent>> for PresentEvent {
            type Value = ::planus::Offset<PresentEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PresentEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PresentEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PresentEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `UnpresentEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `UnpresentEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:132`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct UnpresentEvent {
            /// The field `presentation_id` in the table `UnpresentEvent`
            pub presentation_id: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for UnpresentEvent {
            fn default() -> Self {
                Self {
                    presentation_id: ::core::default::Default::default(),
                }
            }
        }

        impl UnpresentEvent {
            /// Creates a [UnpresentEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UnpresentEventBuilder<()> {
                UnpresentEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_presentation_id: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_presentation_id = field_presentation_id.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_presentation_id);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<UnpresentEvent>> for UnpresentEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UnpresentEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<UnpresentEvent>> for UnpresentEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnpresentEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<UnpresentEvent> for UnpresentEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UnpresentEvent> {
                UnpresentEvent::create(builder, &self.presentation_id)
            }
        }

        /// Builder for serializing an instance of the [UnpresentEvent] type.
        ///
        /// Can be created using the [UnpresentEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UnpresentEventBuilder<State>(State);

        impl UnpresentEventBuilder<()> {
            /// Setter for the [`presentation_id` field](UnpresentEvent#structfield.presentation_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn presentation_id<T0>(self, value: T0) -> UnpresentEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                UnpresentEventBuilder((value,))
            }
        }

        impl<T0> UnpresentEventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UnpresentEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<UnpresentEvent>
            where
                Self: ::planus::WriteAsOffset<UnpresentEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<UnpresentEvent>> for UnpresentEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<UnpresentEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UnpresentEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<UnpresentEvent>>
            for UnpresentEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<UnpresentEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnpresentEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<UnpresentEvent>
            for UnpresentEventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<UnpresentEvent> {
                let (v0,) = &self.0;
                UnpresentEvent::create(builder, v0)
            }
        }

        /// Reference to a deserialized [UnpresentEvent].
        #[derive(Copy, Clone)]
        pub struct UnpresentEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UnpresentEventRef<'a> {
            /// Getter for the [`presentation_id` field](UnpresentEvent#structfield.presentation_id).
            #[inline]
            pub fn presentation_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(0, "UnpresentEvent", "presentation_id")
            }
        }

        impl<'a> ::core::fmt::Debug for UnpresentEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UnpresentEventRef");
                f.field("presentation_id", &self.presentation_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UnpresentEventRef<'a>> for UnpresentEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UnpresentEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    presentation_id: ::core::convert::Into::into(value.presentation_id()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UnpresentEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UnpresentEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[UnpresentEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<UnpresentEvent>> for UnpresentEvent {
            type Value = ::planus::Offset<UnpresentEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<UnpresentEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UnpresentEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UnpresentEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `TracebackEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `TracebackEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:136`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct TracebackEvent {
            /// The field `exception` in the table `TracebackEvent`
            pub exception: ::planus::alloc::boxed::Box<self::Exception>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for TracebackEvent {
            fn default() -> Self {
                Self {
                    exception: ::core::default::Default::default(),
                }
            }
        }

        impl TracebackEvent {
            /// Creates a [TracebackEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> TracebackEventBuilder<()> {
                TracebackEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_exception: impl ::planus::WriteAs<::planus::Offset<self::Exception>>,
            ) -> ::planus::Offset<Self> {
                let prepared_exception = field_exception.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Exception>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_exception);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TracebackEvent>> for TracebackEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TracebackEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TracebackEvent>> for TracebackEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TracebackEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TracebackEvent> for TracebackEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TracebackEvent> {
                TracebackEvent::create(builder, &self.exception)
            }
        }

        /// Builder for serializing an instance of the [TracebackEvent] type.
        ///
        /// Can be created using the [TracebackEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct TracebackEventBuilder<State>(State);

        impl TracebackEventBuilder<()> {
            /// Setter for the [`exception` field](TracebackEvent#structfield.exception).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn exception<T0>(self, value: T0) -> TracebackEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Exception>>,
            {
                TracebackEventBuilder((value,))
            }
        }

        impl<T0> TracebackEventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TracebackEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<TracebackEvent>
            where
                Self: ::planus::WriteAsOffset<TracebackEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Exception>>>
            ::planus::WriteAs<::planus::Offset<TracebackEvent>> for TracebackEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TracebackEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TracebackEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Exception>>>
            ::planus::WriteAsOptional<::planus::Offset<TracebackEvent>>
            for TracebackEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TracebackEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TracebackEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Exception>>>
            ::planus::WriteAsOffset<TracebackEvent> for TracebackEventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TracebackEvent> {
                let (v0,) = &self.0;
                TracebackEvent::create(builder, v0)
            }
        }

        /// Reference to a deserialized [TracebackEvent].
        #[derive(Copy, Clone)]
        pub struct TracebackEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> TracebackEventRef<'a> {
            /// Getter for the [`exception` field](TracebackEvent#structfield.exception).
            #[inline]
            pub fn exception(&self) -> ::planus::Result<self::ExceptionRef<'a>> {
                self.0.access_required(0, "TracebackEvent", "exception")
            }
        }

        impl<'a> ::core::fmt::Debug for TracebackEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("TracebackEventRef");
                f.field("exception", &self.exception());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<TracebackEventRef<'a>> for TracebackEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: TracebackEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    exception: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.exception()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for TracebackEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for TracebackEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[TracebackEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<TracebackEvent>> for TracebackEvent {
            type Value = ::planus::Offset<TracebackEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<TracebackEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for TracebackEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[TracebackEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Event` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Event` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:140`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Event {
            /// The field `event` in the table `Event`
            pub event: self::EventUnion,
        }

        impl Event {
            /// Creates a [EventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> EventBuilder<()> {
                EventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_event: impl ::planus::WriteAsUnion<self::EventUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_event = field_event.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::EventUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_event.offset());
                        object_writer.write::<_, _, 1>(&prepared_event.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Event>> for Event {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Event> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Event>> for Event {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Event>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Event> for Event {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Event> {
                Event::create(builder, &self.event)
            }
        }

        /// Builder for serializing an instance of the [Event] type.
        ///
        /// Can be created using the [Event::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct EventBuilder<State>(State);

        impl EventBuilder<()> {
            /// Setter for the [`event` field](Event#structfield.event).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event<T0>(self, value: T0) -> EventBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::EventUnion>,
            {
                EventBuilder((value,))
            }
        }

        impl<T0> EventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Event].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Event>
            where
                Self: ::planus::WriteAsOffset<Event>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::EventUnion>>
            ::planus::WriteAs<::planus::Offset<Event>> for EventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Event>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Event> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::EventUnion>>
            ::planus::WriteAsOptional<::planus::Offset<Event>> for EventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Event>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Event>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::EventUnion>> ::planus::WriteAsOffset<Event>
            for EventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Event> {
                let (v0,) = &self.0;
                Event::create(builder, v0)
            }
        }

        /// Reference to a deserialized [Event].
        #[derive(Copy, Clone)]
        pub struct EventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> EventRef<'a> {
            /// Getter for the [`event` field](Event#structfield.event).
            #[inline]
            pub fn event(&self) -> ::planus::Result<self::EventUnionRef<'a>> {
                self.0.access_union_required(0, "Event", "event")
            }
        }

        impl<'a> ::core::fmt::Debug for EventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("EventRef");
                f.field("event", &self.event());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<EventRef<'a>> for Event {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: EventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    event: ::core::convert::TryInto::try_into(value.event()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for EventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for EventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[EventRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Event>> for Event {
            type Value = ::planus::Offset<Event>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Event>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for EventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[EventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Presentation` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Presentation` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:144`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Presentation {
            /// The field `id` in the table `Presentation`
            pub id: ::planus::alloc::string::String,
            /// The field `content_type` in the table `Presentation`
            pub content_type: ::planus::alloc::string::String,
            /// The field `content` in the table `Presentation`
            pub content: ::planus::alloc::string::String,
            /// The field `target` in the table `Presentation`
            pub target: ::planus::alloc::string::String,
            /// The field `attributes` in the table `Presentation`
            pub attributes: ::planus::alloc::vec::Vec<self::PresentationAttribute>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Presentation {
            fn default() -> Self {
                Self {
                    id: ::core::default::Default::default(),
                    content_type: ::core::default::Default::default(),
                    content: ::core::default::Default::default(),
                    target: ::core::default::Default::default(),
                    attributes: ::core::default::Default::default(),
                }
            }
        }

        impl Presentation {
            /// Creates a [PresentationBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PresentationBuilder<()> {
                PresentationBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_content_type: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_content: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_target: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_attributes: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_id = field_id.prepare(builder);
                let prepared_content_type = field_content_type.prepare(builder);
                let prepared_content = field_content.prepare(builder);
                let prepared_target = field_target.prepare(builder);
                let prepared_attributes = field_attributes.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<14> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);
                table_writer.write_entry::<::planus::Offset<str>>(2);
                table_writer.write_entry::<::planus::Offset<str>>(3);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>>(4);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_id);
                        object_writer.write::<_, _, 4>(&prepared_content_type);
                        object_writer.write::<_, _, 4>(&prepared_content);
                        object_writer.write::<_, _, 4>(&prepared_target);
                        object_writer.write::<_, _, 4>(&prepared_attributes);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Presentation>> for Presentation {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Presentation> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Presentation>> for Presentation {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Presentation>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Presentation> for Presentation {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Presentation> {
                Presentation::create(
                    builder,
                    &self.id,
                    &self.content_type,
                    &self.content,
                    &self.target,
                    &self.attributes,
                )
            }
        }

        /// Builder for serializing an instance of the [Presentation] type.
        ///
        /// Can be created using the [Presentation::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PresentationBuilder<State>(State);

        impl PresentationBuilder<()> {
            /// Setter for the [`id` field](Presentation#structfield.id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id<T0>(self, value: T0) -> PresentationBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                PresentationBuilder((value,))
            }
        }

        impl<T0> PresentationBuilder<(T0,)> {
            /// Setter for the [`content_type` field](Presentation#structfield.content_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn content_type<T1>(self, value: T1) -> PresentationBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                PresentationBuilder((v0, value))
            }
        }

        impl<T0, T1> PresentationBuilder<(T0, T1)> {
            /// Setter for the [`content` field](Presentation#structfield.content).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn content<T2>(self, value: T2) -> PresentationBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1) = self.0;
                PresentationBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> PresentationBuilder<(T0, T1, T2)> {
            /// Setter for the [`target` field](Presentation#structfield.target).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn target<T3>(self, value: T3) -> PresentationBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1, v2) = self.0;
                PresentationBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> PresentationBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`attributes` field](Presentation#structfield.attributes).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn attributes<T4>(self, value: T4) -> PresentationBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>,
                    >,
            {
                let (v0, v1, v2, v3) = self.0;
                PresentationBuilder((v0, v1, v2, v3, value))
            }
        }

        impl<T0, T1, T2, T3, T4> PresentationBuilder<(T0, T1, T2, T3, T4)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Presentation].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Presentation>
            where
                Self: ::planus::WriteAsOffset<Presentation>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>>,
        > ::planus::WriteAs<::planus::Offset<Presentation>>
            for PresentationBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<Presentation>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Presentation> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<Presentation>>
            for PresentationBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<Presentation>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Presentation>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PresentationAttribute>]>>,
        > ::planus::WriteAsOffset<Presentation> for PresentationBuilder<(T0, T1, T2, T3, T4)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Presentation> {
                let (v0, v1, v2, v3, v4) = &self.0;
                Presentation::create(builder, v0, v1, v2, v3, v4)
            }
        }

        /// Reference to a deserialized [Presentation].
        #[derive(Copy, Clone)]
        pub struct PresentationRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PresentationRef<'a> {
            /// Getter for the [`id` field](Presentation#structfield.id).
            #[inline]
            pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "Presentation", "id")
            }

            /// Getter for the [`content_type` field](Presentation#structfield.content_type).
            #[inline]
            pub fn content_type(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "Presentation", "content_type")
            }

            /// Getter for the [`content` field](Presentation#structfield.content).
            #[inline]
            pub fn content(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(2, "Presentation", "content")
            }

            /// Getter for the [`target` field](Presentation#structfield.target).
            #[inline]
            pub fn target(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(3, "Presentation", "target")
            }

            /// Getter for the [`attributes` field](Presentation#structfield.attributes).
            #[inline]
            pub fn attributes(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::PresentationAttributeRef<'a>>>,
            > {
                self.0.access_required(4, "Presentation", "attributes")
            }
        }

        impl<'a> ::core::fmt::Debug for PresentationRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PresentationRef");
                f.field("id", &self.id());
                f.field("content_type", &self.content_type());
                f.field("content", &self.content());
                f.field("target", &self.target());
                f.field("attributes", &self.attributes());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PresentationRef<'a>> for Presentation {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PresentationRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    id: ::core::convert::Into::into(value.id()?),
                    content_type: ::core::convert::Into::into(value.content_type()?),
                    content: ::core::convert::Into::into(value.content()?),
                    target: ::core::convert::Into::into(value.target()?),
                    attributes: value.attributes()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PresentationRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PresentationRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PresentationRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Presentation>> for Presentation {
            type Value = ::planus::Offset<Presentation>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Presentation>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PresentationRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PresentationRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PresentationAttribute` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PresentationAttribute` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:152`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PresentationAttribute {
            /// The field `key` in the table `PresentationAttribute`
            pub key: ::planus::alloc::string::String,
            /// The field `value` in the table `PresentationAttribute`
            pub value: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PresentationAttribute {
            fn default() -> Self {
                Self {
                    key: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }

        impl PresentationAttribute {
            /// Creates a [PresentationAttributeBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PresentationAttributeBuilder<()> {
                PresentationAttributeBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_key: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_key = field_key.prepare(builder);
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_key);
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PresentationAttribute>> for PresentationAttribute {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationAttribute> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PresentationAttribute>> for PresentationAttribute {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PresentationAttribute>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PresentationAttribute> for PresentationAttribute {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationAttribute> {
                PresentationAttribute::create(builder, &self.key, &self.value)
            }
        }

        /// Builder for serializing an instance of the [PresentationAttribute] type.
        ///
        /// Can be created using the [PresentationAttribute::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PresentationAttributeBuilder<State>(State);

        impl PresentationAttributeBuilder<()> {
            /// Setter for the [`key` field](PresentationAttribute#structfield.key).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn key<T0>(self, value: T0) -> PresentationAttributeBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                PresentationAttributeBuilder((value,))
            }
        }

        impl<T0> PresentationAttributeBuilder<(T0,)> {
            /// Setter for the [`value` field](PresentationAttribute#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T1>(self, value: T1) -> PresentationAttributeBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                PresentationAttributeBuilder((v0, value))
            }
        }

        impl<T0, T1> PresentationAttributeBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PresentationAttribute].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationAttribute>
            where
                Self: ::planus::WriteAsOffset<PresentationAttribute>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<PresentationAttribute>>
            for PresentationAttributeBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PresentationAttribute>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationAttribute> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<PresentationAttribute>>
            for PresentationAttributeBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PresentationAttribute>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PresentationAttribute>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<PresentationAttribute>
            for PresentationAttributeBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationAttribute> {
                let (v0, v1) = &self.0;
                PresentationAttribute::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [PresentationAttribute].
        #[derive(Copy, Clone)]
        pub struct PresentationAttributeRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PresentationAttributeRef<'a> {
            /// Getter for the [`key` field](PresentationAttribute#structfield.key).
            #[inline]
            pub fn key(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "PresentationAttribute", "key")
            }

            /// Getter for the [`value` field](PresentationAttribute#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "PresentationAttribute", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for PresentationAttributeRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PresentationAttributeRef");
                f.field("key", &self.key());
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PresentationAttributeRef<'a>> for PresentationAttribute {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PresentationAttributeRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    key: ::core::convert::Into::into(value.key()?),
                    value: ::core::convert::Into::into(value.value()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PresentationAttributeRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PresentationAttributeRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PresentationAttributeRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PresentationAttribute>>
            for PresentationAttribute
        {
            type Value = ::planus::Offset<PresentationAttribute>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PresentationAttribute>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PresentationAttributeRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PresentationAttributeRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Exception` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Exception` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:157`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Exception {
            /// The field `error` in the table `Exception`
            pub error: ::planus::alloc::boxed::Box<self::Error>,
            /// The field `stack` in the table `Exception`
            pub stack: ::planus::alloc::vec::Vec<self::VarBytes>,
            /// The field `backtrace` in the table `Exception`
            pub backtrace: ::planus::alloc::vec::Vec<self::VarBytes>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Exception {
            fn default() -> Self {
                Self {
                    error: ::core::default::Default::default(),
                    stack: ::core::default::Default::default(),
                    backtrace: ::core::default::Default::default(),
                }
            }
        }

        impl Exception {
            /// Creates a [ExceptionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ExceptionBuilder<()> {
                ExceptionBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::Error>>,
                field_stack: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::VarBytes>]>,
                >,
                field_backtrace: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::VarBytes>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);
                let prepared_stack = field_stack.prepare(builder);
                let prepared_backtrace = field_backtrace.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Error>>(0);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::VarBytes>]>>(1);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::VarBytes>]>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                        object_writer.write::<_, _, 4>(&prepared_stack);
                        object_writer.write::<_, _, 4>(&prepared_backtrace);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Exception>> for Exception {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Exception> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Exception>> for Exception {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Exception>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Exception> for Exception {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Exception> {
                Exception::create(builder, &self.error, &self.stack, &self.backtrace)
            }
        }

        /// Builder for serializing an instance of the [Exception] type.
        ///
        /// Can be created using the [Exception::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ExceptionBuilder<State>(State);

        impl ExceptionBuilder<()> {
            /// Setter for the [`error` field](Exception#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> ExceptionBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Error>>,
            {
                ExceptionBuilder((value,))
            }
        }

        impl<T0> ExceptionBuilder<(T0,)> {
            /// Setter for the [`stack` field](Exception#structfield.stack).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn stack<T1>(self, value: T1) -> ExceptionBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            {
                let (v0,) = self.0;
                ExceptionBuilder((v0, value))
            }
        }

        impl<T0, T1> ExceptionBuilder<(T0, T1)> {
            /// Setter for the [`backtrace` field](Exception#structfield.backtrace).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn backtrace<T2>(self, value: T2) -> ExceptionBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            {
                let (v0, v1) = self.0;
                ExceptionBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> ExceptionBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Exception].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Exception>
            where
                Self: ::planus::WriteAsOffset<Exception>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Error>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
        > ::planus::WriteAs<::planus::Offset<Exception>> for ExceptionBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<Exception>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Exception> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Error>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<Exception>>
            for ExceptionBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<Exception>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Exception>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Error>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
        > ::planus::WriteAsOffset<Exception> for ExceptionBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Exception> {
                let (v0, v1, v2) = &self.0;
                Exception::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [Exception].
        #[derive(Copy, Clone)]
        pub struct ExceptionRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ExceptionRef<'a> {
            /// Getter for the [`error` field](Exception#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::ErrorRef<'a>> {
                self.0.access_required(0, "Exception", "error")
            }

            /// Getter for the [`stack` field](Exception#structfield.stack).
            #[inline]
            pub fn stack(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VarBytesRef<'a>>>>
            {
                self.0.access_required(1, "Exception", "stack")
            }

            /// Getter for the [`backtrace` field](Exception#structfield.backtrace).
            #[inline]
            pub fn backtrace(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VarBytesRef<'a>>>>
            {
                self.0.access_required(2, "Exception", "backtrace")
            }
        }

        impl<'a> ::core::fmt::Debug for ExceptionRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ExceptionRef");
                f.field("error", &self.error());
                f.field("stack", &self.stack());
                f.field("backtrace", &self.backtrace());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ExceptionRef<'a>> for Exception {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ExceptionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                    stack: value.stack()?.to_vec_result()?,
                    backtrace: value.backtrace()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ExceptionRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ExceptionRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ExceptionRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Exception>> for Exception {
            type Value = ::planus::Offset<Exception>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Exception>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ExceptionRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ExceptionRef]", "read_as_root", 0)
                })
            }
        }

        /// The enum `AbortLimitReason` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Enum `AbortLimitReason` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:167`
        #[derive(
            Copy,
            Clone,
            Debug,
            PartialEq,
            Eq,
            PartialOrd,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        #[repr(u8)]
        pub enum AbortLimitReason {
            /// The variant `Ticks` in the enum `AbortLimitReason`
            Ticks = 0,

            /// The variant `Time` in the enum `AbortLimitReason`
            Time = 1,
        }

        impl AbortLimitReason {
            /// Array containing all valid variants of AbortLimitReason
            pub const ENUM_VALUES: [Self; 2] = [Self::Ticks, Self::Time];
        }

        impl ::core::convert::TryFrom<u8> for AbortLimitReason {
            type Error = ::planus::errors::UnknownEnumTagKind;
            #[inline]
            fn try_from(
                value: u8,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind> {
                #[allow(clippy::match_single_binding)]
                match value {
                    0 => ::core::result::Result::Ok(AbortLimitReason::Ticks),
                    1 => ::core::result::Result::Ok(AbortLimitReason::Time),

                    _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                        tag: value as i128,
                    }),
                }
            }
        }

        impl ::core::convert::From<AbortLimitReason> for u8 {
            #[inline]
            fn from(value: AbortLimitReason) -> Self {
                value as u8
            }
        }

        /// # Safety
        /// The Planus compiler correctly calculates `ALIGNMENT` and `SIZE`.
        unsafe impl ::planus::Primitive for AbortLimitReason {
            const ALIGNMENT: usize = 1;
            const SIZE: usize = 1;
        }

        impl ::planus::WriteAsPrimitive<AbortLimitReason> for AbortLimitReason {
            #[inline]
            fn write<const N: usize>(&self, cursor: ::planus::Cursor<'_, N>, buffer_position: u32) {
                (*self as u8).write(cursor, buffer_position);
            }
        }

        impl ::planus::WriteAs<AbortLimitReason> for AbortLimitReason {
            type Prepared = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> AbortLimitReason {
                *self
            }
        }

        impl ::planus::WriteAsDefault<AbortLimitReason, AbortLimitReason> for AbortLimitReason {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
                default: &AbortLimitReason,
            ) -> ::core::option::Option<AbortLimitReason> {
                if self == default {
                    ::core::option::Option::None
                } else {
                    ::core::option::Option::Some(*self)
                }
            }
        }

        impl ::planus::WriteAsOptional<AbortLimitReason> for AbortLimitReason {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<AbortLimitReason> {
                ::core::option::Option::Some(*self)
            }
        }

        impl<'buf> ::planus::TableRead<'buf> for AbortLimitReason {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
            }
        }

        impl<'buf> ::planus::VectorReadInner<'buf> for AbortLimitReason {
            type Error = ::planus::errors::UnknownEnumTag;
            const STRIDE: usize = 1;
            #[inline]
            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag> {
                let value = unsafe { *buffer.buffer.get_unchecked(offset) };
                let value: ::core::result::Result<Self, _> =
                    ::core::convert::TryInto::try_into(value);
                value.map_err(|error_kind| {
                    error_kind.with_error_location(
                        "AbortLimitReason",
                        "VectorRead::from_buffer",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<AbortLimitReason> for AbortLimitReason {
            const STRIDE: usize = 1;

            type Value = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                *self
            }

            #[inline]
            unsafe fn write_values(
                values: &[Self],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - i as u32,
                    );
                }
            }
        }

        /// The table `AbortLimit` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `AbortLimit` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:172`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct AbortLimit {
            /// The field `reason` in the table `AbortLimit`
            pub reason: self::AbortLimitReason,
            /// The field `ticks` in the table `AbortLimit`
            pub ticks: u64,
            /// The field `time_nanos` in the table `AbortLimit`
            pub time_nanos: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for AbortLimit {
            fn default() -> Self {
                Self {
                    reason: self::AbortLimitReason::Ticks,
                    ticks: 0,
                    time_nanos: 0,
                }
            }
        }

        impl AbortLimit {
            /// Creates a [AbortLimitBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AbortLimitBuilder<()> {
                AbortLimitBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_reason: impl ::planus::WriteAsDefault<
                    self::AbortLimitReason,
                    self::AbortLimitReason,
                >,
                field_ticks: impl ::planus::WriteAsDefault<u64, u64>,
                field_time_nanos: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_reason = field_reason.prepare(builder, &self::AbortLimitReason::Ticks);
                let prepared_ticks = field_ticks.prepare(builder, &0);
                let prepared_time_nanos = field_time_nanos.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                if prepared_ticks.is_some() {
                    table_writer.write_entry::<u64>(1);
                }
                if prepared_time_nanos.is_some() {
                    table_writer.write_entry::<u64>(2);
                }
                if prepared_reason.is_some() {
                    table_writer.write_entry::<self::AbortLimitReason>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_ticks) = prepared_ticks {
                            object_writer.write::<_, _, 8>(&prepared_ticks);
                        }
                        if let ::core::option::Option::Some(prepared_time_nanos) =
                            prepared_time_nanos
                        {
                            object_writer.write::<_, _, 8>(&prepared_time_nanos);
                        }
                        if let ::core::option::Option::Some(prepared_reason) = prepared_reason {
                            object_writer.write::<_, _, 1>(&prepared_reason);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<AbortLimit>> for AbortLimit {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AbortLimit> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<AbortLimit>> for AbortLimit {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AbortLimit>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<AbortLimit> for AbortLimit {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AbortLimit> {
                AbortLimit::create(builder, self.reason, self.ticks, self.time_nanos)
            }
        }

        /// Builder for serializing an instance of the [AbortLimit] type.
        ///
        /// Can be created using the [AbortLimit::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AbortLimitBuilder<State>(State);

        impl AbortLimitBuilder<()> {
            /// Setter for the [`reason` field](AbortLimit#structfield.reason).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn reason<T0>(self, value: T0) -> AbortLimitBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<self::AbortLimitReason, self::AbortLimitReason>,
            {
                AbortLimitBuilder((value,))
            }

            /// Sets the [`reason` field](AbortLimit#structfield.reason) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn reason_as_default(self) -> AbortLimitBuilder<(::planus::DefaultValue,)> {
                self.reason(::planus::DefaultValue)
            }
        }

        impl<T0> AbortLimitBuilder<(T0,)> {
            /// Setter for the [`ticks` field](AbortLimit#structfield.ticks).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn ticks<T1>(self, value: T1) -> AbortLimitBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                AbortLimitBuilder((v0, value))
            }

            /// Sets the [`ticks` field](AbortLimit#structfield.ticks) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn ticks_as_default(self) -> AbortLimitBuilder<(T0, ::planus::DefaultValue)> {
                self.ticks(::planus::DefaultValue)
            }
        }

        impl<T0, T1> AbortLimitBuilder<(T0, T1)> {
            /// Setter for the [`time_nanos` field](AbortLimit#structfield.time_nanos).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn time_nanos<T2>(self, value: T2) -> AbortLimitBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1) = self.0;
                AbortLimitBuilder((v0, v1, value))
            }

            /// Sets the [`time_nanos` field](AbortLimit#structfield.time_nanos) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn time_nanos_as_default(
                self,
            ) -> AbortLimitBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.time_nanos(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> AbortLimitBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AbortLimit].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<AbortLimit>
            where
                Self: ::planus::WriteAsOffset<AbortLimit>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::AbortLimitReason, self::AbortLimitReason>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAs<::planus::Offset<AbortLimit>> for AbortLimitBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<AbortLimit>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AbortLimit> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::AbortLimitReason, self::AbortLimitReason>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAsOptional<::planus::Offset<AbortLimit>>
            for AbortLimitBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<AbortLimit>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AbortLimit>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::AbortLimitReason, self::AbortLimitReason>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAsOffset<AbortLimit> for AbortLimitBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AbortLimit> {
                let (v0, v1, v2) = &self.0;
                AbortLimit::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [AbortLimit].
        #[derive(Copy, Clone)]
        pub struct AbortLimitRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AbortLimitRef<'a> {
            /// Getter for the [`reason` field](AbortLimit#structfield.reason).
            #[inline]
            pub fn reason(&self) -> ::planus::Result<self::AbortLimitReason> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "AbortLimit", "reason")?
                        .unwrap_or(self::AbortLimitReason::Ticks),
                )
            }

            /// Getter for the [`ticks` field](AbortLimit#structfield.ticks).
            #[inline]
            pub fn ticks(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(1, "AbortLimit", "ticks")?.unwrap_or(0))
            }

            /// Getter for the [`time_nanos` field](AbortLimit#structfield.time_nanos).
            #[inline]
            pub fn time_nanos(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0.access(2, "AbortLimit", "time_nanos")?.unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for AbortLimitRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AbortLimitRef");
                f.field("reason", &self.reason());
                f.field("ticks", &self.ticks());
                f.field("time_nanos", &self.time_nanos());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AbortLimitRef<'a>> for AbortLimit {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AbortLimitRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    reason: ::core::convert::TryInto::try_into(value.reason()?)?,
                    ticks: ::core::convert::TryInto::try_into(value.ticks()?)?,
                    time_nanos: ::core::convert::TryInto::try_into(value.time_nanos()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AbortLimitRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AbortLimitRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[AbortLimitRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<AbortLimit>> for AbortLimit {
            type Value = ::planus::Offset<AbortLimit>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<AbortLimit>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AbortLimitRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AbortLimitRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `SchedulerErrorUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `SchedulerErrorUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:178`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum SchedulerErrorUnion {
            /// The variant of type `SchedulerNotResponding` in the union `SchedulerErrorUnion`
            SchedulerNotResponding(::planus::alloc::boxed::Box<self::SchedulerNotResponding>),

            /// The variant of type `TaskNotFound` in the union `SchedulerErrorUnion`
            TaskNotFound(::planus::alloc::boxed::Box<self::TaskNotFound>),

            /// The variant of type `InputRequestNotFound` in the union `SchedulerErrorUnion`
            InputRequestNotFound(::planus::alloc::boxed::Box<self::InputRequestNotFound>),

            /// The variant of type `CouldNotStartTask` in the union `SchedulerErrorUnion`
            CouldNotStartTask(::planus::alloc::boxed::Box<self::CouldNotStartTask>),

            /// The variant of type `CompilationError` in the union `SchedulerErrorUnion`
            CompilationError(::planus::alloc::boxed::Box<self::CompilationError>),

            /// The variant of type `CommandExecutionError` in the union `SchedulerErrorUnion`
            CommandExecutionError(::planus::alloc::boxed::Box<self::CommandExecutionError>),

            /// The variant of type `TaskAbortedLimit` in the union `SchedulerErrorUnion`
            TaskAbortedLimit(::planus::alloc::boxed::Box<self::TaskAbortedLimit>),

            /// The variant of type `TaskAbortedError` in the union `SchedulerErrorUnion`
            TaskAbortedError(::planus::alloc::boxed::Box<self::TaskAbortedError>),

            /// The variant of type `TaskAbortedException` in the union `SchedulerErrorUnion`
            TaskAbortedException(::planus::alloc::boxed::Box<self::TaskAbortedException>),

            /// The variant of type `TaskAbortedCancelled` in the union `SchedulerErrorUnion`
            TaskAbortedCancelled(::planus::alloc::boxed::Box<self::TaskAbortedCancelled>),

            /// The variant of type `VerbProgramFailed` in the union `SchedulerErrorUnion`
            VerbProgramFailed(::planus::alloc::boxed::Box<self::VerbProgramFailed>),

            /// The variant of type `PropertyRetrievalFailed` in the union `SchedulerErrorUnion`
            PropertyRetrievalFailed(::planus::alloc::boxed::Box<self::PropertyRetrievalFailed>),

            /// The variant of type `VerbRetrievalFailed` in the union `SchedulerErrorUnion`
            VerbRetrievalFailed(::planus::alloc::boxed::Box<self::VerbRetrievalFailed>),

            /// The variant of type `ObjectResolutionFailed` in the union `SchedulerErrorUnion`
            ObjectResolutionFailed(::planus::alloc::boxed::Box<self::ObjectResolutionFailed>),

            /// The variant of type `GarbageCollectionFailed` in the union `SchedulerErrorUnion`
            GarbageCollectionFailed(::planus::alloc::boxed::Box<self::GarbageCollectionFailed>),
        }

        impl SchedulerErrorUnion {
            /// Creates a [SchedulerErrorUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> SchedulerErrorUnionBuilder<::planus::Uninitialized> {
                SchedulerErrorUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_scheduler_not_responding(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::SchedulerNotResponding>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_task_not_found(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::TaskNotFound>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_input_request_not_found(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::InputRequestNotFound>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_could_not_start_task(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::CouldNotStartTask>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_compilation_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::CompilationError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_command_execution_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::CommandExecutionError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_task_aborted_limit(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::TaskAbortedLimit>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_task_aborted_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::TaskAbortedError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_task_aborted_exception(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::TaskAbortedException>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_task_aborted_cancelled(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::TaskAbortedCancelled>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_program_failed(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbProgramFailed>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_property_retrieval_failed(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertyRetrievalFailed>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_retrieval_failed(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbRetrievalFailed>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_object_resolution_failed(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectResolutionFailed>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(14, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_garbage_collection_failed(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::GarbageCollectionFailed>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(15, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<SchedulerErrorUnion> for SchedulerErrorUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::SchedulerNotResponding(value) => {
                        Self::create_scheduler_not_responding(builder, value)
                    }
                    Self::TaskNotFound(value) => Self::create_task_not_found(builder, value),
                    Self::InputRequestNotFound(value) => {
                        Self::create_input_request_not_found(builder, value)
                    }
                    Self::CouldNotStartTask(value) => {
                        Self::create_could_not_start_task(builder, value)
                    }
                    Self::CompilationError(value) => Self::create_compilation_error(builder, value),
                    Self::CommandExecutionError(value) => {
                        Self::create_command_execution_error(builder, value)
                    }
                    Self::TaskAbortedLimit(value) => {
                        Self::create_task_aborted_limit(builder, value)
                    }
                    Self::TaskAbortedError(value) => {
                        Self::create_task_aborted_error(builder, value)
                    }
                    Self::TaskAbortedException(value) => {
                        Self::create_task_aborted_exception(builder, value)
                    }
                    Self::TaskAbortedCancelled(value) => {
                        Self::create_task_aborted_cancelled(builder, value)
                    }
                    Self::VerbProgramFailed(value) => {
                        Self::create_verb_program_failed(builder, value)
                    }
                    Self::PropertyRetrievalFailed(value) => {
                        Self::create_property_retrieval_failed(builder, value)
                    }
                    Self::VerbRetrievalFailed(value) => {
                        Self::create_verb_retrieval_failed(builder, value)
                    }
                    Self::ObjectResolutionFailed(value) => {
                        Self::create_object_resolution_failed(builder, value)
                    }
                    Self::GarbageCollectionFailed(value) => {
                        Self::create_garbage_collection_failed(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<SchedulerErrorUnion> for SchedulerErrorUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [SchedulerErrorUnion] type.
        ///
        /// Can be created using the [SchedulerErrorUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct SchedulerErrorUnionBuilder<T>(T);

        impl SchedulerErrorUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`SchedulerNotResponding` variant](SchedulerErrorUnion#variant.SchedulerNotResponding).
            #[inline]
            pub fn scheduler_not_responding<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::SchedulerNotResponding>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`TaskNotFound` variant](SchedulerErrorUnion#variant.TaskNotFound).
            #[inline]
            pub fn task_not_found<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::TaskNotFound>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`InputRequestNotFound` variant](SchedulerErrorUnion#variant.InputRequestNotFound).
            #[inline]
            pub fn input_request_not_found<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::InputRequestNotFound>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`CouldNotStartTask` variant](SchedulerErrorUnion#variant.CouldNotStartTask).
            #[inline]
            pub fn could_not_start_task<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::CouldNotStartTask>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`CompilationError` variant](SchedulerErrorUnion#variant.CompilationError).
            #[inline]
            pub fn compilation_error<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::CompilationError>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`CommandExecutionError` variant](SchedulerErrorUnion#variant.CommandExecutionError).
            #[inline]
            pub fn command_execution_error<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::CommandExecutionError>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`TaskAbortedLimit` variant](SchedulerErrorUnion#variant.TaskAbortedLimit).
            #[inline]
            pub fn task_aborted_limit<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<self::TaskAbortedLimit>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`TaskAbortedError` variant](SchedulerErrorUnion#variant.TaskAbortedError).
            #[inline]
            pub fn task_aborted_error<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<self::TaskAbortedError>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`TaskAbortedException` variant](SchedulerErrorUnion#variant.TaskAbortedException).
            #[inline]
            pub fn task_aborted_exception<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<self::TaskAbortedException>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`TaskAbortedCancelled` variant](SchedulerErrorUnion#variant.TaskAbortedCancelled).
            #[inline]
            pub fn task_aborted_cancelled<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<self::TaskAbortedCancelled>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbProgramFailed` variant](SchedulerErrorUnion#variant.VerbProgramFailed).
            #[inline]
            pub fn verb_program_failed<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbProgramFailed>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertyRetrievalFailed` variant](SchedulerErrorUnion#variant.PropertyRetrievalFailed).
            #[inline]
            pub fn property_retrieval_failed<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertyRetrievalFailed>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbRetrievalFailed` variant](SchedulerErrorUnion#variant.VerbRetrievalFailed).
            #[inline]
            pub fn verb_retrieval_failed<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbRetrievalFailed>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ObjectResolutionFailed` variant](SchedulerErrorUnion#variant.ObjectResolutionFailed).
            #[inline]
            pub fn object_resolution_failed<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectResolutionFailed>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`GarbageCollectionFailed` variant](SchedulerErrorUnion#variant.GarbageCollectionFailed).
            #[inline]
            pub fn garbage_collection_failed<T>(
                self,
                value: T,
            ) -> SchedulerErrorUnionBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<self::GarbageCollectionFailed>,
            {
                SchedulerErrorUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> SchedulerErrorUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [SchedulerErrorUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion>
            where
                Self: ::planus::WriteAsUnion<SchedulerErrorUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::SchedulerNotResponding>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::SchedulerNotResponding>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::InputRequestNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::InputRequestNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::CouldNotStartTask>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::CouldNotStartTask>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::CompilationError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::CompilationError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::CommandExecutionError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::CommandExecutionError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskAbortedLimit>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskAbortedLimit>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskAbortedError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskAbortedError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskAbortedException>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskAbortedException>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskAbortedCancelled>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskAbortedCancelled>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbProgramFailed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(11, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbProgramFailed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyRetrievalFailed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(12, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyRetrievalFailed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbRetrievalFailed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(13, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbRetrievalFailed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<14, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectResolutionFailed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(14, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<14, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectResolutionFailed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<15, T>>
        where
            T: ::planus::WriteAsOffset<self::GarbageCollectionFailed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<SchedulerErrorUnion> {
                ::planus::UnionOffset::new(15, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<SchedulerErrorUnion>
            for SchedulerErrorUnionBuilder<::planus::Initialized<15, T>>
        where
            T: ::planus::WriteAsOffset<self::GarbageCollectionFailed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<SchedulerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [SchedulerErrorUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum SchedulerErrorUnionRef<'a> {
            SchedulerNotResponding(self::SchedulerNotRespondingRef<'a>),
            TaskNotFound(self::TaskNotFoundRef<'a>),
            InputRequestNotFound(self::InputRequestNotFoundRef<'a>),
            CouldNotStartTask(self::CouldNotStartTaskRef<'a>),
            CompilationError(self::CompilationErrorRef<'a>),
            CommandExecutionError(self::CommandExecutionErrorRef<'a>),
            TaskAbortedLimit(self::TaskAbortedLimitRef<'a>),
            TaskAbortedError(self::TaskAbortedErrorRef<'a>),
            TaskAbortedException(self::TaskAbortedExceptionRef<'a>),
            TaskAbortedCancelled(self::TaskAbortedCancelledRef<'a>),
            VerbProgramFailed(self::VerbProgramFailedRef<'a>),
            PropertyRetrievalFailed(self::PropertyRetrievalFailedRef<'a>),
            VerbRetrievalFailed(self::VerbRetrievalFailedRef<'a>),
            ObjectResolutionFailed(self::ObjectResolutionFailedRef<'a>),
            GarbageCollectionFailed(self::GarbageCollectionFailedRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<SchedulerErrorUnionRef<'a>> for SchedulerErrorUnion {
            type Error = ::planus::Error;

            fn try_from(value: SchedulerErrorUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    SchedulerErrorUnionRef::SchedulerNotResponding(value) => {
                        Self::SchedulerNotResponding(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::TaskNotFound(value) => {
                        Self::TaskNotFound(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::InputRequestNotFound(value) => {
                        Self::InputRequestNotFound(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::CouldNotStartTask(value) => {
                        Self::CouldNotStartTask(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::CompilationError(value) => {
                        Self::CompilationError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::CommandExecutionError(value) => {
                        Self::CommandExecutionError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::TaskAbortedLimit(value) => {
                        Self::TaskAbortedLimit(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::TaskAbortedError(value) => {
                        Self::TaskAbortedError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::TaskAbortedException(value) => {
                        Self::TaskAbortedException(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::TaskAbortedCancelled(value) => {
                        Self::TaskAbortedCancelled(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::VerbProgramFailed(value) => {
                        Self::VerbProgramFailed(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::PropertyRetrievalFailed(value) => {
                        Self::PropertyRetrievalFailed(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::VerbRetrievalFailed(value) => {
                        Self::VerbRetrievalFailed(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::ObjectResolutionFailed(value) => {
                        Self::ObjectResolutionFailed(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    SchedulerErrorUnionRef::GarbageCollectionFailed(value) => {
                        Self::GarbageCollectionFailed(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for SchedulerErrorUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::SchedulerNotResponding(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::TaskNotFound(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::InputRequestNotFound(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::CouldNotStartTask(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::CompilationError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    6 => ::core::result::Result::Ok(Self::CommandExecutionError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    7 => ::core::result::Result::Ok(Self::TaskAbortedLimit(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    8 => ::core::result::Result::Ok(Self::TaskAbortedError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    9 => ::core::result::Result::Ok(Self::TaskAbortedException(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    10 => ::core::result::Result::Ok(Self::TaskAbortedCancelled(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    11 => ::core::result::Result::Ok(Self::VerbProgramFailed(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    12 => ::core::result::Result::Ok(Self::PropertyRetrievalFailed(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    13 => ::core::result::Result::Ok(Self::VerbRetrievalFailed(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    14 => ::core::result::Result::Ok(Self::ObjectResolutionFailed(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    15 => ::core::result::Result::Ok(Self::GarbageCollectionFailed(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for SchedulerErrorUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[SchedulerErrorUnionRef]";
        }

        /// The table `SchedulerNotResponding` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `SchedulerNotResponding` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:196`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct SchedulerNotResponding {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for SchedulerNotResponding {
            fn default() -> Self {
                Self {}
            }
        }

        impl SchedulerNotResponding {
            /// Creates a [SchedulerNotRespondingBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> SchedulerNotRespondingBuilder<()> {
                SchedulerNotRespondingBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<SchedulerNotResponding>> for SchedulerNotResponding {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SchedulerNotResponding> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<SchedulerNotResponding>>
            for SchedulerNotResponding
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SchedulerNotResponding>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<SchedulerNotResponding> for SchedulerNotResponding {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SchedulerNotResponding> {
                SchedulerNotResponding::create(builder)
            }
        }

        /// Builder for serializing an instance of the [SchedulerNotResponding] type.
        ///
        /// Can be created using the [SchedulerNotResponding::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct SchedulerNotRespondingBuilder<State>(State);

        impl SchedulerNotRespondingBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SchedulerNotResponding].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SchedulerNotResponding>
            where
                Self: ::planus::WriteAsOffset<SchedulerNotResponding>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<SchedulerNotResponding>>
            for SchedulerNotRespondingBuilder<()>
        {
            type Prepared = ::planus::Offset<SchedulerNotResponding>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SchedulerNotResponding> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<SchedulerNotResponding>>
            for SchedulerNotRespondingBuilder<()>
        {
            type Prepared = ::planus::Offset<SchedulerNotResponding>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SchedulerNotResponding>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<SchedulerNotResponding> for SchedulerNotRespondingBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SchedulerNotResponding> {
                SchedulerNotResponding::create(builder)
            }
        }

        /// Reference to a deserialized [SchedulerNotResponding].
        #[derive(Copy, Clone)]
        pub struct SchedulerNotRespondingRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> SchedulerNotRespondingRef<'a> {}

        impl<'a> ::core::fmt::Debug for SchedulerNotRespondingRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("SchedulerNotRespondingRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<SchedulerNotRespondingRef<'a>> for SchedulerNotResponding {
            type Error = ::planus::Error;

            fn try_from(_value: SchedulerNotRespondingRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for SchedulerNotRespondingRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for SchedulerNotRespondingRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[SchedulerNotRespondingRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<SchedulerNotResponding>>
            for SchedulerNotResponding
        {
            type Value = ::planus::Offset<SchedulerNotResponding>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<SchedulerNotResponding>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for SchedulerNotRespondingRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[SchedulerNotRespondingRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `TaskNotFound` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `TaskNotFound` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:199`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct TaskNotFound {
            /// The field `task_id` in the table `TaskNotFound`
            pub task_id: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for TaskNotFound {
            fn default() -> Self {
                Self { task_id: 0 }
            }
        }

        impl TaskNotFound {
            /// Creates a [TaskNotFoundBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> TaskNotFoundBuilder<()> {
                TaskNotFoundBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_task_id: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_task_id = field_task_id.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_task_id.is_some() {
                    table_writer.write_entry::<u64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_task_id) = prepared_task_id {
                            object_writer.write::<_, _, 8>(&prepared_task_id);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TaskNotFound>> for TaskNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TaskNotFound>> for TaskNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TaskNotFound> for TaskNotFound {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskNotFound> {
                TaskNotFound::create(builder, self.task_id)
            }
        }

        /// Builder for serializing an instance of the [TaskNotFound] type.
        ///
        /// Can be created using the [TaskNotFound::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct TaskNotFoundBuilder<State>(State);

        impl TaskNotFoundBuilder<()> {
            /// Setter for the [`task_id` field](TaskNotFound#structfield.task_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn task_id<T0>(self, value: T0) -> TaskNotFoundBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                TaskNotFoundBuilder((value,))
            }

            /// Sets the [`task_id` field](TaskNotFound#structfield.task_id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn task_id_as_default(self) -> TaskNotFoundBuilder<(::planus::DefaultValue,)> {
                self.task_id(::planus::DefaultValue)
            }
        }

        impl<T0> TaskNotFoundBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TaskNotFound].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskNotFound>
            where
                Self: ::planus::WriteAsOffset<TaskNotFound>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAs<::planus::Offset<TaskNotFound>> for TaskNotFoundBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TaskNotFound>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<TaskNotFound>>
            for TaskNotFoundBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TaskNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAsOffset<TaskNotFound>
            for TaskNotFoundBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskNotFound> {
                let (v0,) = &self.0;
                TaskNotFound::create(builder, v0)
            }
        }

        /// Reference to a deserialized [TaskNotFound].
        #[derive(Copy, Clone)]
        pub struct TaskNotFoundRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> TaskNotFoundRef<'a> {
            /// Getter for the [`task_id` field](TaskNotFound#structfield.task_id).
            #[inline]
            pub fn task_id(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0.access(0, "TaskNotFound", "task_id")?.unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for TaskNotFoundRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("TaskNotFoundRef");
                f.field("task_id", &self.task_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<TaskNotFoundRef<'a>> for TaskNotFound {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: TaskNotFoundRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    task_id: ::core::convert::TryInto::try_into(value.task_id()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for TaskNotFoundRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for TaskNotFoundRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[TaskNotFoundRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<TaskNotFound>> for TaskNotFound {
            type Value = ::planus::Offset<TaskNotFound>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<TaskNotFound>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for TaskNotFoundRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[TaskNotFoundRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `InputRequestNotFound` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `InputRequestNotFound` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:203`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct InputRequestNotFound {
            /// The field `request_id` in the table `InputRequestNotFound`
            pub request_id: ::planus::alloc::boxed::Box<self::Uuid>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for InputRequestNotFound {
            fn default() -> Self {
                Self {
                    request_id: ::core::default::Default::default(),
                }
            }
        }

        impl InputRequestNotFound {
            /// Creates a [InputRequestNotFoundBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> InputRequestNotFoundBuilder<()> {
                InputRequestNotFoundBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_request_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            ) -> ::planus::Offset<Self> {
                let prepared_request_id = field_request_id.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_request_id);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<InputRequestNotFound>> for InputRequestNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InputRequestNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<InputRequestNotFound>> for InputRequestNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InputRequestNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<InputRequestNotFound> for InputRequestNotFound {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InputRequestNotFound> {
                InputRequestNotFound::create(builder, &self.request_id)
            }
        }

        /// Builder for serializing an instance of the [InputRequestNotFound] type.
        ///
        /// Can be created using the [InputRequestNotFound::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct InputRequestNotFoundBuilder<State>(State);

        impl InputRequestNotFoundBuilder<()> {
            /// Setter for the [`request_id` field](InputRequestNotFound#structfield.request_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn request_id<T0>(self, value: T0) -> InputRequestNotFoundBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                InputRequestNotFoundBuilder((value,))
            }
        }

        impl<T0> InputRequestNotFoundBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [InputRequestNotFound].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InputRequestNotFound>
            where
                Self: ::planus::WriteAsOffset<InputRequestNotFound>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>>
            ::planus::WriteAs<::planus::Offset<InputRequestNotFound>>
            for InputRequestNotFoundBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InputRequestNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InputRequestNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>>
            ::planus::WriteAsOptional<::planus::Offset<InputRequestNotFound>>
            for InputRequestNotFoundBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InputRequestNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InputRequestNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>>
            ::planus::WriteAsOffset<InputRequestNotFound> for InputRequestNotFoundBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InputRequestNotFound> {
                let (v0,) = &self.0;
                InputRequestNotFound::create(builder, v0)
            }
        }

        /// Reference to a deserialized [InputRequestNotFound].
        #[derive(Copy, Clone)]
        pub struct InputRequestNotFoundRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> InputRequestNotFoundRef<'a> {
            /// Getter for the [`request_id` field](InputRequestNotFound#structfield.request_id).
            #[inline]
            pub fn request_id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0
                    .access_required(0, "InputRequestNotFound", "request_id")
            }
        }

        impl<'a> ::core::fmt::Debug for InputRequestNotFoundRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("InputRequestNotFoundRef");
                f.field("request_id", &self.request_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<InputRequestNotFoundRef<'a>> for InputRequestNotFound {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: InputRequestNotFoundRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    request_id: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.request_id()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for InputRequestNotFoundRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for InputRequestNotFoundRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[InputRequestNotFoundRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<InputRequestNotFound>> for InputRequestNotFound {
            type Value = ::planus::Offset<InputRequestNotFound>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<InputRequestNotFound>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for InputRequestNotFoundRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[InputRequestNotFoundRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `CouldNotStartTask` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `CouldNotStartTask` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:207`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CouldNotStartTask {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for CouldNotStartTask {
            fn default() -> Self {
                Self {}
            }
        }

        impl CouldNotStartTask {
            /// Creates a [CouldNotStartTaskBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CouldNotStartTaskBuilder<()> {
                CouldNotStartTaskBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CouldNotStartTask>> for CouldNotStartTask {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CouldNotStartTask> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CouldNotStartTask>> for CouldNotStartTask {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CouldNotStartTask>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CouldNotStartTask> for CouldNotStartTask {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CouldNotStartTask> {
                CouldNotStartTask::create(builder)
            }
        }

        /// Builder for serializing an instance of the [CouldNotStartTask] type.
        ///
        /// Can be created using the [CouldNotStartTask::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CouldNotStartTaskBuilder<State>(State);

        impl CouldNotStartTaskBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CouldNotStartTask].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CouldNotStartTask>
            where
                Self: ::planus::WriteAsOffset<CouldNotStartTask>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CouldNotStartTask>> for CouldNotStartTaskBuilder<()> {
            type Prepared = ::planus::Offset<CouldNotStartTask>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CouldNotStartTask> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CouldNotStartTask>>
            for CouldNotStartTaskBuilder<()>
        {
            type Prepared = ::planus::Offset<CouldNotStartTask>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CouldNotStartTask>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CouldNotStartTask> for CouldNotStartTaskBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CouldNotStartTask> {
                CouldNotStartTask::create(builder)
            }
        }

        /// Reference to a deserialized [CouldNotStartTask].
        #[derive(Copy, Clone)]
        pub struct CouldNotStartTaskRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CouldNotStartTaskRef<'a> {}

        impl<'a> ::core::fmt::Debug for CouldNotStartTaskRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CouldNotStartTaskRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CouldNotStartTaskRef<'a>> for CouldNotStartTask {
            type Error = ::planus::Error;

            fn try_from(_value: CouldNotStartTaskRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for CouldNotStartTaskRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CouldNotStartTaskRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CouldNotStartTaskRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CouldNotStartTask>> for CouldNotStartTask {
            type Value = ::planus::Offset<CouldNotStartTask>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CouldNotStartTask>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CouldNotStartTaskRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CouldNotStartTaskRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `CompilationError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `CompilationError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:210`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CompilationError {
            /// The field `error` in the table `CompilationError`
            pub error: ::planus::alloc::boxed::Box<self::CompileError>,
        }

        impl CompilationError {
            /// Creates a [CompilationErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CompilationErrorBuilder<()> {
                CompilationErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::CompileError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileError>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CompilationError>> for CompilationError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CompilationError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CompilationError>> for CompilationError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CompilationError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CompilationError> for CompilationError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CompilationError> {
                CompilationError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [CompilationError] type.
        ///
        /// Can be created using the [CompilationError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CompilationErrorBuilder<State>(State);

        impl CompilationErrorBuilder<()> {
            /// Setter for the [`error` field](CompilationError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> CompilationErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileError>>,
            {
                CompilationErrorBuilder((value,))
            }
        }

        impl<T0> CompilationErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CompilationError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CompilationError>
            where
                Self: ::planus::WriteAsOffset<CompilationError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileError>>>
            ::planus::WriteAs<::planus::Offset<CompilationError>>
            for CompilationErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CompilationError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CompilationError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileError>>>
            ::planus::WriteAsOptional<::planus::Offset<CompilationError>>
            for CompilationErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CompilationError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CompilationError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileError>>>
            ::planus::WriteAsOffset<CompilationError> for CompilationErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CompilationError> {
                let (v0,) = &self.0;
                CompilationError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [CompilationError].
        #[derive(Copy, Clone)]
        pub struct CompilationErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CompilationErrorRef<'a> {
            /// Getter for the [`error` field](CompilationError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::CompileErrorRef<'a>> {
                self.0.access_required(0, "CompilationError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for CompilationErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CompilationErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CompilationErrorRef<'a>> for CompilationError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CompilationErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CompilationErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CompilationErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CompilationErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CompilationError>> for CompilationError {
            type Value = ::planus::Offset<CompilationError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CompilationError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CompilationErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CompilationErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `CommandExecutionError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `CommandExecutionError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:214`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CommandExecutionError {
            /// The field `error` in the table `CommandExecutionError`
            pub error: ::planus::alloc::boxed::Box<self::CommandError>,
        }

        impl CommandExecutionError {
            /// Creates a [CommandExecutionErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CommandExecutionErrorBuilder<()> {
                CommandExecutionErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::CommandError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CommandError>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CommandExecutionError>> for CommandExecutionError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CommandExecutionError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CommandExecutionError>> for CommandExecutionError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CommandExecutionError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CommandExecutionError> for CommandExecutionError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CommandExecutionError> {
                CommandExecutionError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [CommandExecutionError] type.
        ///
        /// Can be created using the [CommandExecutionError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CommandExecutionErrorBuilder<State>(State);

        impl CommandExecutionErrorBuilder<()> {
            /// Setter for the [`error` field](CommandExecutionError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> CommandExecutionErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CommandError>>,
            {
                CommandExecutionErrorBuilder((value,))
            }
        }

        impl<T0> CommandExecutionErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CommandExecutionError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CommandExecutionError>
            where
                Self: ::planus::WriteAsOffset<CommandExecutionError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CommandError>>>
            ::planus::WriteAs<::planus::Offset<CommandExecutionError>>
            for CommandExecutionErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CommandExecutionError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CommandExecutionError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CommandError>>>
            ::planus::WriteAsOptional<::planus::Offset<CommandExecutionError>>
            for CommandExecutionErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CommandExecutionError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CommandExecutionError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CommandError>>>
            ::planus::WriteAsOffset<CommandExecutionError> for CommandExecutionErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CommandExecutionError> {
                let (v0,) = &self.0;
                CommandExecutionError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [CommandExecutionError].
        #[derive(Copy, Clone)]
        pub struct CommandExecutionErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CommandExecutionErrorRef<'a> {
            /// Getter for the [`error` field](CommandExecutionError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::CommandErrorRef<'a>> {
                self.0.access_required(0, "CommandExecutionError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for CommandExecutionErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CommandExecutionErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CommandExecutionErrorRef<'a>> for CommandExecutionError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CommandExecutionErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CommandExecutionErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CommandExecutionErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CommandExecutionErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CommandExecutionError>>
            for CommandExecutionError
        {
            type Value = ::planus::Offset<CommandExecutionError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CommandExecutionError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CommandExecutionErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CommandExecutionErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `TaskAbortedLimit` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `TaskAbortedLimit` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:218`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct TaskAbortedLimit {
            /// The field `limit` in the table `TaskAbortedLimit`
            pub limit: ::planus::alloc::boxed::Box<self::AbortLimit>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for TaskAbortedLimit {
            fn default() -> Self {
                Self {
                    limit: ::core::default::Default::default(),
                }
            }
        }

        impl TaskAbortedLimit {
            /// Creates a [TaskAbortedLimitBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> TaskAbortedLimitBuilder<()> {
                TaskAbortedLimitBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_limit: impl ::planus::WriteAs<::planus::Offset<self::AbortLimit>>,
            ) -> ::planus::Offset<Self> {
                let prepared_limit = field_limit.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::AbortLimit>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_limit);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TaskAbortedLimit>> for TaskAbortedLimit {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedLimit> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TaskAbortedLimit>> for TaskAbortedLimit {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskAbortedLimit>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TaskAbortedLimit> for TaskAbortedLimit {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedLimit> {
                TaskAbortedLimit::create(builder, &self.limit)
            }
        }

        /// Builder for serializing an instance of the [TaskAbortedLimit] type.
        ///
        /// Can be created using the [TaskAbortedLimit::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct TaskAbortedLimitBuilder<State>(State);

        impl TaskAbortedLimitBuilder<()> {
            /// Setter for the [`limit` field](TaskAbortedLimit#structfield.limit).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn limit<T0>(self, value: T0) -> TaskAbortedLimitBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::AbortLimit>>,
            {
                TaskAbortedLimitBuilder((value,))
            }
        }

        impl<T0> TaskAbortedLimitBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TaskAbortedLimit].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedLimit>
            where
                Self: ::planus::WriteAsOffset<TaskAbortedLimit>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::AbortLimit>>>
            ::planus::WriteAs<::planus::Offset<TaskAbortedLimit>>
            for TaskAbortedLimitBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TaskAbortedLimit>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedLimit> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::AbortLimit>>>
            ::planus::WriteAsOptional<::planus::Offset<TaskAbortedLimit>>
            for TaskAbortedLimitBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TaskAbortedLimit>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskAbortedLimit>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::AbortLimit>>>
            ::planus::WriteAsOffset<TaskAbortedLimit> for TaskAbortedLimitBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedLimit> {
                let (v0,) = &self.0;
                TaskAbortedLimit::create(builder, v0)
            }
        }

        /// Reference to a deserialized [TaskAbortedLimit].
        #[derive(Copy, Clone)]
        pub struct TaskAbortedLimitRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> TaskAbortedLimitRef<'a> {
            /// Getter for the [`limit` field](TaskAbortedLimit#structfield.limit).
            #[inline]
            pub fn limit(&self) -> ::planus::Result<self::AbortLimitRef<'a>> {
                self.0.access_required(0, "TaskAbortedLimit", "limit")
            }
        }

        impl<'a> ::core::fmt::Debug for TaskAbortedLimitRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("TaskAbortedLimitRef");
                f.field("limit", &self.limit());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<TaskAbortedLimitRef<'a>> for TaskAbortedLimit {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: TaskAbortedLimitRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    limit: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.limit()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for TaskAbortedLimitRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for TaskAbortedLimitRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[TaskAbortedLimitRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<TaskAbortedLimit>> for TaskAbortedLimit {
            type Value = ::planus::Offset<TaskAbortedLimit>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<TaskAbortedLimit>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for TaskAbortedLimitRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[TaskAbortedLimitRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `TaskAbortedError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `TaskAbortedError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:222`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct TaskAbortedError {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for TaskAbortedError {
            fn default() -> Self {
                Self {}
            }
        }

        impl TaskAbortedError {
            /// Creates a [TaskAbortedErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> TaskAbortedErrorBuilder<()> {
                TaskAbortedErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TaskAbortedError>> for TaskAbortedError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TaskAbortedError>> for TaskAbortedError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskAbortedError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TaskAbortedError> for TaskAbortedError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedError> {
                TaskAbortedError::create(builder)
            }
        }

        /// Builder for serializing an instance of the [TaskAbortedError] type.
        ///
        /// Can be created using the [TaskAbortedError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct TaskAbortedErrorBuilder<State>(State);

        impl TaskAbortedErrorBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TaskAbortedError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedError>
            where
                Self: ::planus::WriteAsOffset<TaskAbortedError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TaskAbortedError>> for TaskAbortedErrorBuilder<()> {
            type Prepared = ::planus::Offset<TaskAbortedError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TaskAbortedError>> for TaskAbortedErrorBuilder<()> {
            type Prepared = ::planus::Offset<TaskAbortedError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskAbortedError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TaskAbortedError> for TaskAbortedErrorBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedError> {
                TaskAbortedError::create(builder)
            }
        }

        /// Reference to a deserialized [TaskAbortedError].
        #[derive(Copy, Clone)]
        pub struct TaskAbortedErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> TaskAbortedErrorRef<'a> {}

        impl<'a> ::core::fmt::Debug for TaskAbortedErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("TaskAbortedErrorRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<TaskAbortedErrorRef<'a>> for TaskAbortedError {
            type Error = ::planus::Error;

            fn try_from(_value: TaskAbortedErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for TaskAbortedErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for TaskAbortedErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[TaskAbortedErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<TaskAbortedError>> for TaskAbortedError {
            type Value = ::planus::Offset<TaskAbortedError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<TaskAbortedError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for TaskAbortedErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[TaskAbortedErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `TaskAbortedException` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `TaskAbortedException` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:225`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct TaskAbortedException {
            /// The field `exception` in the table `TaskAbortedException`
            pub exception: ::planus::alloc::boxed::Box<self::Exception>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for TaskAbortedException {
            fn default() -> Self {
                Self {
                    exception: ::core::default::Default::default(),
                }
            }
        }

        impl TaskAbortedException {
            /// Creates a [TaskAbortedExceptionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> TaskAbortedExceptionBuilder<()> {
                TaskAbortedExceptionBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_exception: impl ::planus::WriteAs<::planus::Offset<self::Exception>>,
            ) -> ::planus::Offset<Self> {
                let prepared_exception = field_exception.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Exception>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_exception);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TaskAbortedException>> for TaskAbortedException {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedException> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TaskAbortedException>> for TaskAbortedException {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskAbortedException>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TaskAbortedException> for TaskAbortedException {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedException> {
                TaskAbortedException::create(builder, &self.exception)
            }
        }

        /// Builder for serializing an instance of the [TaskAbortedException] type.
        ///
        /// Can be created using the [TaskAbortedException::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct TaskAbortedExceptionBuilder<State>(State);

        impl TaskAbortedExceptionBuilder<()> {
            /// Setter for the [`exception` field](TaskAbortedException#structfield.exception).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn exception<T0>(self, value: T0) -> TaskAbortedExceptionBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Exception>>,
            {
                TaskAbortedExceptionBuilder((value,))
            }
        }

        impl<T0> TaskAbortedExceptionBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TaskAbortedException].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedException>
            where
                Self: ::planus::WriteAsOffset<TaskAbortedException>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Exception>>>
            ::planus::WriteAs<::planus::Offset<TaskAbortedException>>
            for TaskAbortedExceptionBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TaskAbortedException>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedException> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Exception>>>
            ::planus::WriteAsOptional<::planus::Offset<TaskAbortedException>>
            for TaskAbortedExceptionBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TaskAbortedException>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskAbortedException>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Exception>>>
            ::planus::WriteAsOffset<TaskAbortedException> for TaskAbortedExceptionBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedException> {
                let (v0,) = &self.0;
                TaskAbortedException::create(builder, v0)
            }
        }

        /// Reference to a deserialized [TaskAbortedException].
        #[derive(Copy, Clone)]
        pub struct TaskAbortedExceptionRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> TaskAbortedExceptionRef<'a> {
            /// Getter for the [`exception` field](TaskAbortedException#structfield.exception).
            #[inline]
            pub fn exception(&self) -> ::planus::Result<self::ExceptionRef<'a>> {
                self.0
                    .access_required(0, "TaskAbortedException", "exception")
            }
        }

        impl<'a> ::core::fmt::Debug for TaskAbortedExceptionRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("TaskAbortedExceptionRef");
                f.field("exception", &self.exception());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<TaskAbortedExceptionRef<'a>> for TaskAbortedException {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: TaskAbortedExceptionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    exception: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.exception()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for TaskAbortedExceptionRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for TaskAbortedExceptionRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[TaskAbortedExceptionRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<TaskAbortedException>> for TaskAbortedException {
            type Value = ::planus::Offset<TaskAbortedException>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<TaskAbortedException>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for TaskAbortedExceptionRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[TaskAbortedExceptionRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `TaskAbortedCancelled` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `TaskAbortedCancelled` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:229`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct TaskAbortedCancelled {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for TaskAbortedCancelled {
            fn default() -> Self {
                Self {}
            }
        }

        impl TaskAbortedCancelled {
            /// Creates a [TaskAbortedCancelledBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> TaskAbortedCancelledBuilder<()> {
                TaskAbortedCancelledBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TaskAbortedCancelled>> for TaskAbortedCancelled {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedCancelled> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TaskAbortedCancelled>> for TaskAbortedCancelled {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskAbortedCancelled>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TaskAbortedCancelled> for TaskAbortedCancelled {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedCancelled> {
                TaskAbortedCancelled::create(builder)
            }
        }

        /// Builder for serializing an instance of the [TaskAbortedCancelled] type.
        ///
        /// Can be created using the [TaskAbortedCancelled::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct TaskAbortedCancelledBuilder<State>(State);

        impl TaskAbortedCancelledBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TaskAbortedCancelled].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedCancelled>
            where
                Self: ::planus::WriteAsOffset<TaskAbortedCancelled>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TaskAbortedCancelled>> for TaskAbortedCancelledBuilder<()> {
            type Prepared = ::planus::Offset<TaskAbortedCancelled>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedCancelled> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TaskAbortedCancelled>>
            for TaskAbortedCancelledBuilder<()>
        {
            type Prepared = ::planus::Offset<TaskAbortedCancelled>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskAbortedCancelled>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TaskAbortedCancelled> for TaskAbortedCancelledBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskAbortedCancelled> {
                TaskAbortedCancelled::create(builder)
            }
        }

        /// Reference to a deserialized [TaskAbortedCancelled].
        #[derive(Copy, Clone)]
        pub struct TaskAbortedCancelledRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> TaskAbortedCancelledRef<'a> {}

        impl<'a> ::core::fmt::Debug for TaskAbortedCancelledRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("TaskAbortedCancelledRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<TaskAbortedCancelledRef<'a>> for TaskAbortedCancelled {
            type Error = ::planus::Error;

            fn try_from(_value: TaskAbortedCancelledRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for TaskAbortedCancelledRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for TaskAbortedCancelledRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[TaskAbortedCancelledRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<TaskAbortedCancelled>> for TaskAbortedCancelled {
            type Value = ::planus::Offset<TaskAbortedCancelled>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<TaskAbortedCancelled>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for TaskAbortedCancelledRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[TaskAbortedCancelledRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbProgramFailed` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbProgramFailed` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:232`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbProgramFailed {
            /// The field `error` in the table `VerbProgramFailed`
            pub error: ::planus::alloc::boxed::Box<self::VerbProgramError>,
        }

        impl VerbProgramFailed {
            /// Creates a [VerbProgramFailedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbProgramFailedBuilder<()> {
                VerbProgramFailedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::VerbProgramError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::VerbProgramError>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbProgramFailed>> for VerbProgramFailed {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramFailed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbProgramFailed>> for VerbProgramFailed {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramFailed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbProgramFailed> for VerbProgramFailed {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramFailed> {
                VerbProgramFailed::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [VerbProgramFailed] type.
        ///
        /// Can be created using the [VerbProgramFailed::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbProgramFailedBuilder<State>(State);

        impl VerbProgramFailedBuilder<()> {
            /// Setter for the [`error` field](VerbProgramFailed#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> VerbProgramFailedBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramError>>,
            {
                VerbProgramFailedBuilder((value,))
            }
        }

        impl<T0> VerbProgramFailedBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbProgramFailed].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramFailed>
            where
                Self: ::planus::WriteAsOffset<VerbProgramFailed>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramError>>>
            ::planus::WriteAs<::planus::Offset<VerbProgramFailed>>
            for VerbProgramFailedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbProgramFailed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramFailed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramError>>>
            ::planus::WriteAsOptional<::planus::Offset<VerbProgramFailed>>
            for VerbProgramFailedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbProgramFailed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramFailed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramError>>>
            ::planus::WriteAsOffset<VerbProgramFailed> for VerbProgramFailedBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramFailed> {
                let (v0,) = &self.0;
                VerbProgramFailed::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VerbProgramFailed].
        #[derive(Copy, Clone)]
        pub struct VerbProgramFailedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbProgramFailedRef<'a> {
            /// Getter for the [`error` field](VerbProgramFailed#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::VerbProgramErrorRef<'a>> {
                self.0.access_required(0, "VerbProgramFailed", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbProgramFailedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbProgramFailedRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbProgramFailedRef<'a>> for VerbProgramFailed {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbProgramFailedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbProgramFailedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbProgramFailedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbProgramFailedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbProgramFailed>> for VerbProgramFailed {
            type Value = ::planus::Offset<VerbProgramFailed>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbProgramFailed>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbProgramFailedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbProgramFailedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PropertyRetrievalFailed` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PropertyRetrievalFailed` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:236`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertyRetrievalFailed {
            /// The field `error` in the table `PropertyRetrievalFailed`
            pub error: ::planus::alloc::boxed::Box<self::WorldStateError>,
        }

        impl PropertyRetrievalFailed {
            /// Creates a [PropertyRetrievalFailedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertyRetrievalFailedBuilder<()> {
                PropertyRetrievalFailedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::WorldStateError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorldStateError>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyRetrievalFailed>> for PropertyRetrievalFailed {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyRetrievalFailed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyRetrievalFailed>>
            for PropertyRetrievalFailed
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyRetrievalFailed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyRetrievalFailed> for PropertyRetrievalFailed {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyRetrievalFailed> {
                PropertyRetrievalFailed::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [PropertyRetrievalFailed] type.
        ///
        /// Can be created using the [PropertyRetrievalFailed::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertyRetrievalFailedBuilder<State>(State);

        impl PropertyRetrievalFailedBuilder<()> {
            /// Setter for the [`error` field](PropertyRetrievalFailed#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> PropertyRetrievalFailedBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>,
            {
                PropertyRetrievalFailedBuilder((value,))
            }
        }

        impl<T0> PropertyRetrievalFailedBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertyRetrievalFailed].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyRetrievalFailed>
            where
                Self: ::planus::WriteAsOffset<PropertyRetrievalFailed>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAs<::planus::Offset<PropertyRetrievalFailed>>
            for PropertyRetrievalFailedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PropertyRetrievalFailed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyRetrievalFailed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAsOptional<::planus::Offset<PropertyRetrievalFailed>>
            for PropertyRetrievalFailedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PropertyRetrievalFailed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyRetrievalFailed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAsOffset<PropertyRetrievalFailed>
            for PropertyRetrievalFailedBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyRetrievalFailed> {
                let (v0,) = &self.0;
                PropertyRetrievalFailed::create(builder, v0)
            }
        }

        /// Reference to a deserialized [PropertyRetrievalFailed].
        #[derive(Copy, Clone)]
        pub struct PropertyRetrievalFailedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertyRetrievalFailedRef<'a> {
            /// Getter for the [`error` field](PropertyRetrievalFailed#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::WorldStateErrorRef<'a>> {
                self.0
                    .access_required(0, "PropertyRetrievalFailed", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for PropertyRetrievalFailedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertyRetrievalFailedRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertyRetrievalFailedRef<'a>> for PropertyRetrievalFailed {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropertyRetrievalFailedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertyRetrievalFailedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertyRetrievalFailedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyRetrievalFailedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertyRetrievalFailed>>
            for PropertyRetrievalFailed
        {
            type Value = ::planus::Offset<PropertyRetrievalFailed>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertyRetrievalFailed>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertyRetrievalFailedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyRetrievalFailedRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `VerbRetrievalFailed` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbRetrievalFailed` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:240`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbRetrievalFailed {
            /// The field `error` in the table `VerbRetrievalFailed`
            pub error: ::planus::alloc::boxed::Box<self::WorldStateError>,
        }

        impl VerbRetrievalFailed {
            /// Creates a [VerbRetrievalFailedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbRetrievalFailedBuilder<()> {
                VerbRetrievalFailedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::WorldStateError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorldStateError>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbRetrievalFailed>> for VerbRetrievalFailed {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbRetrievalFailed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbRetrievalFailed>> for VerbRetrievalFailed {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbRetrievalFailed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbRetrievalFailed> for VerbRetrievalFailed {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbRetrievalFailed> {
                VerbRetrievalFailed::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [VerbRetrievalFailed] type.
        ///
        /// Can be created using the [VerbRetrievalFailed::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbRetrievalFailedBuilder<State>(State);

        impl VerbRetrievalFailedBuilder<()> {
            /// Setter for the [`error` field](VerbRetrievalFailed#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> VerbRetrievalFailedBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>,
            {
                VerbRetrievalFailedBuilder((value,))
            }
        }

        impl<T0> VerbRetrievalFailedBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbRetrievalFailed].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbRetrievalFailed>
            where
                Self: ::planus::WriteAsOffset<VerbRetrievalFailed>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAs<::planus::Offset<VerbRetrievalFailed>>
            for VerbRetrievalFailedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbRetrievalFailed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbRetrievalFailed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAsOptional<::planus::Offset<VerbRetrievalFailed>>
            for VerbRetrievalFailedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbRetrievalFailed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbRetrievalFailed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAsOffset<VerbRetrievalFailed> for VerbRetrievalFailedBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbRetrievalFailed> {
                let (v0,) = &self.0;
                VerbRetrievalFailed::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VerbRetrievalFailed].
        #[derive(Copy, Clone)]
        pub struct VerbRetrievalFailedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbRetrievalFailedRef<'a> {
            /// Getter for the [`error` field](VerbRetrievalFailed#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::WorldStateErrorRef<'a>> {
                self.0.access_required(0, "VerbRetrievalFailed", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbRetrievalFailedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbRetrievalFailedRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbRetrievalFailedRef<'a>> for VerbRetrievalFailed {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbRetrievalFailedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbRetrievalFailedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbRetrievalFailedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbRetrievalFailedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbRetrievalFailed>> for VerbRetrievalFailed {
            type Value = ::planus::Offset<VerbRetrievalFailed>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbRetrievalFailed>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbRetrievalFailedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbRetrievalFailedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectResolutionFailed` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ObjectResolutionFailed` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:244`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectResolutionFailed {
            /// The field `error` in the table `ObjectResolutionFailed`
            pub error: ::planus::alloc::boxed::Box<self::WorldStateError>,
        }

        impl ObjectResolutionFailed {
            /// Creates a [ObjectResolutionFailedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectResolutionFailedBuilder<()> {
                ObjectResolutionFailedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::WorldStateError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorldStateError>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectResolutionFailed>> for ObjectResolutionFailed {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectResolutionFailed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectResolutionFailed>>
            for ObjectResolutionFailed
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectResolutionFailed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectResolutionFailed> for ObjectResolutionFailed {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectResolutionFailed> {
                ObjectResolutionFailed::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [ObjectResolutionFailed] type.
        ///
        /// Can be created using the [ObjectResolutionFailed::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectResolutionFailedBuilder<State>(State);

        impl ObjectResolutionFailedBuilder<()> {
            /// Setter for the [`error` field](ObjectResolutionFailed#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> ObjectResolutionFailedBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>,
            {
                ObjectResolutionFailedBuilder((value,))
            }
        }

        impl<T0> ObjectResolutionFailedBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectResolutionFailed].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectResolutionFailed>
            where
                Self: ::planus::WriteAsOffset<ObjectResolutionFailed>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAs<::planus::Offset<ObjectResolutionFailed>>
            for ObjectResolutionFailedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectResolutionFailed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectResolutionFailed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectResolutionFailed>>
            for ObjectResolutionFailedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectResolutionFailed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectResolutionFailed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAsOffset<ObjectResolutionFailed>
            for ObjectResolutionFailedBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectResolutionFailed> {
                let (v0,) = &self.0;
                ObjectResolutionFailed::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectResolutionFailed].
        #[derive(Copy, Clone)]
        pub struct ObjectResolutionFailedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectResolutionFailedRef<'a> {
            /// Getter for the [`error` field](ObjectResolutionFailed#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::WorldStateErrorRef<'a>> {
                self.0.access_required(0, "ObjectResolutionFailed", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectResolutionFailedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectResolutionFailedRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectResolutionFailedRef<'a>> for ObjectResolutionFailed {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectResolutionFailedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectResolutionFailedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectResolutionFailedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectResolutionFailedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectResolutionFailed>>
            for ObjectResolutionFailed
        {
            type Value = ::planus::Offset<ObjectResolutionFailed>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectResolutionFailed>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectResolutionFailedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectResolutionFailedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `GarbageCollectionFailed` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `GarbageCollectionFailed` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:248`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct GarbageCollectionFailed {
            /// The field `message` in the table `GarbageCollectionFailed`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for GarbageCollectionFailed {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl GarbageCollectionFailed {
            /// Creates a [GarbageCollectionFailedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> GarbageCollectionFailedBuilder<()> {
                GarbageCollectionFailedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<GarbageCollectionFailed>> for GarbageCollectionFailed {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<GarbageCollectionFailed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<GarbageCollectionFailed>>
            for GarbageCollectionFailed
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<GarbageCollectionFailed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<GarbageCollectionFailed> for GarbageCollectionFailed {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<GarbageCollectionFailed> {
                GarbageCollectionFailed::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [GarbageCollectionFailed] type.
        ///
        /// Can be created using the [GarbageCollectionFailed::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct GarbageCollectionFailedBuilder<State>(State);

        impl GarbageCollectionFailedBuilder<()> {
            /// Setter for the [`message` field](GarbageCollectionFailed#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> GarbageCollectionFailedBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                GarbageCollectionFailedBuilder((value,))
            }
        }

        impl<T0> GarbageCollectionFailedBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GarbageCollectionFailed].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<GarbageCollectionFailed>
            where
                Self: ::planus::WriteAsOffset<GarbageCollectionFailed>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<GarbageCollectionFailed>>
            for GarbageCollectionFailedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<GarbageCollectionFailed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<GarbageCollectionFailed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<GarbageCollectionFailed>>
            for GarbageCollectionFailedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<GarbageCollectionFailed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<GarbageCollectionFailed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOffset<GarbageCollectionFailed>
            for GarbageCollectionFailedBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<GarbageCollectionFailed> {
                let (v0,) = &self.0;
                GarbageCollectionFailed::create(builder, v0)
            }
        }

        /// Reference to a deserialized [GarbageCollectionFailed].
        #[derive(Copy, Clone)]
        pub struct GarbageCollectionFailedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> GarbageCollectionFailedRef<'a> {
            /// Getter for the [`message` field](GarbageCollectionFailed#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(0, "GarbageCollectionFailed", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for GarbageCollectionFailedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("GarbageCollectionFailedRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<GarbageCollectionFailedRef<'a>> for GarbageCollectionFailed {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: GarbageCollectionFailedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for GarbageCollectionFailedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for GarbageCollectionFailedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[GarbageCollectionFailedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<GarbageCollectionFailed>>
            for GarbageCollectionFailed
        {
            type Value = ::planus::Offset<GarbageCollectionFailed>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<GarbageCollectionFailed>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for GarbageCollectionFailedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[GarbageCollectionFailedRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `SchedulerError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `SchedulerError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:252`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct SchedulerError {
            /// The field `error` in the table `SchedulerError`
            pub error: self::SchedulerErrorUnion,
        }

        impl SchedulerError {
            /// Creates a [SchedulerErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> SchedulerErrorBuilder<()> {
                SchedulerErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAsUnion<self::SchedulerErrorUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::SchedulerErrorUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error.offset());
                        object_writer.write::<_, _, 1>(&prepared_error.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<SchedulerError>> for SchedulerError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SchedulerError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<SchedulerError>> for SchedulerError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SchedulerError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<SchedulerError> for SchedulerError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SchedulerError> {
                SchedulerError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [SchedulerError] type.
        ///
        /// Can be created using the [SchedulerError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct SchedulerErrorBuilder<State>(State);

        impl SchedulerErrorBuilder<()> {
            /// Setter for the [`error` field](SchedulerError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> SchedulerErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::SchedulerErrorUnion>,
            {
                SchedulerErrorBuilder((value,))
            }
        }

        impl<T0> SchedulerErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SchedulerError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<SchedulerError>
            where
                Self: ::planus::WriteAsOffset<SchedulerError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::SchedulerErrorUnion>>
            ::planus::WriteAs<::planus::Offset<SchedulerError>> for SchedulerErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<SchedulerError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SchedulerError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::SchedulerErrorUnion>>
            ::planus::WriteAsOptional<::planus::Offset<SchedulerError>>
            for SchedulerErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<SchedulerError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SchedulerError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::SchedulerErrorUnion>>
            ::planus::WriteAsOffset<SchedulerError> for SchedulerErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SchedulerError> {
                let (v0,) = &self.0;
                SchedulerError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [SchedulerError].
        #[derive(Copy, Clone)]
        pub struct SchedulerErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> SchedulerErrorRef<'a> {
            /// Getter for the [`error` field](SchedulerError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::SchedulerErrorUnionRef<'a>> {
                self.0.access_union_required(0, "SchedulerError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for SchedulerErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("SchedulerErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<SchedulerErrorRef<'a>> for SchedulerError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: SchedulerErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::core::convert::TryInto::try_into(value.error()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for SchedulerErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for SchedulerErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[SchedulerErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<SchedulerError>> for SchedulerError {
            type Value = ::planus::Offset<SchedulerError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<SchedulerError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for SchedulerErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[SchedulerErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `CommandErrorUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `CommandErrorUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:257`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum CommandErrorUnion {
            /// The variant of type `CouldNotParseCommand` in the union `CommandErrorUnion`
            CouldNotParseCommand(::planus::alloc::boxed::Box<self::CouldNotParseCommand>),

            /// The variant of type `NoObjectMatch` in the union `CommandErrorUnion`
            NoObjectMatch(::planus::alloc::boxed::Box<self::NoObjectMatch>),

            /// The variant of type `NoCommandMatch` in the union `CommandErrorUnion`
            NoCommandMatch(::planus::alloc::boxed::Box<self::NoCommandMatch>),

            /// The variant of type `DatabaseError` in the union `CommandErrorUnion`
            DatabaseError(::planus::alloc::boxed::Box<self::DatabaseError>),

            /// The variant of type `PermissionDenied` in the union `CommandErrorUnion`
            PermissionDenied(::planus::alloc::boxed::Box<self::PermissionDenied>),
        }

        impl CommandErrorUnion {
            /// Creates a [CommandErrorUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CommandErrorUnionBuilder<::planus::Uninitialized> {
                CommandErrorUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_could_not_parse_command(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::CouldNotParseCommand>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_no_object_match(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::NoObjectMatch>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_no_command_match(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::NoCommandMatch>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_database_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DatabaseError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_permission_denied(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PermissionDenied>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<CommandErrorUnion> for CommandErrorUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::CouldNotParseCommand(value) => {
                        Self::create_could_not_parse_command(builder, value)
                    }
                    Self::NoObjectMatch(value) => Self::create_no_object_match(builder, value),
                    Self::NoCommandMatch(value) => Self::create_no_command_match(builder, value),
                    Self::DatabaseError(value) => Self::create_database_error(builder, value),
                    Self::PermissionDenied(value) => Self::create_permission_denied(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<CommandErrorUnion> for CommandErrorUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [CommandErrorUnion] type.
        ///
        /// Can be created using the [CommandErrorUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CommandErrorUnionBuilder<T>(T);

        impl CommandErrorUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`CouldNotParseCommand` variant](CommandErrorUnion#variant.CouldNotParseCommand).
            #[inline]
            pub fn could_not_parse_command<T>(
                self,
                value: T,
            ) -> CommandErrorUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::CouldNotParseCommand>,
            {
                CommandErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`NoObjectMatch` variant](CommandErrorUnion#variant.NoObjectMatch).
            #[inline]
            pub fn no_object_match<T>(
                self,
                value: T,
            ) -> CommandErrorUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::NoObjectMatch>,
            {
                CommandErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`NoCommandMatch` variant](CommandErrorUnion#variant.NoCommandMatch).
            #[inline]
            pub fn no_command_match<T>(
                self,
                value: T,
            ) -> CommandErrorUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::NoCommandMatch>,
            {
                CommandErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DatabaseError` variant](CommandErrorUnion#variant.DatabaseError).
            #[inline]
            pub fn database_error<T>(
                self,
                value: T,
            ) -> CommandErrorUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::DatabaseError>,
            {
                CommandErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PermissionDenied` variant](CommandErrorUnion#variant.PermissionDenied).
            #[inline]
            pub fn permission_denied<T>(
                self,
                value: T,
            ) -> CommandErrorUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::PermissionDenied>,
            {
                CommandErrorUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> CommandErrorUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [CommandErrorUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CommandErrorUnion>
            where
                Self: ::planus::WriteAsUnion<CommandErrorUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<CommandErrorUnion>
            for CommandErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::CouldNotParseCommand>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CommandErrorUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CommandErrorUnion>
            for CommandErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::CouldNotParseCommand>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CommandErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CommandErrorUnion>
            for CommandErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::NoObjectMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CommandErrorUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CommandErrorUnion>
            for CommandErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::NoObjectMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CommandErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CommandErrorUnion>
            for CommandErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::NoCommandMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CommandErrorUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CommandErrorUnion>
            for CommandErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::NoCommandMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CommandErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CommandErrorUnion>
            for CommandErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::DatabaseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CommandErrorUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CommandErrorUnion>
            for CommandErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::DatabaseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CommandErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CommandErrorUnion>
            for CommandErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::PermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CommandErrorUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CommandErrorUnion>
            for CommandErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::PermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CommandErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [CommandErrorUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum CommandErrorUnionRef<'a> {
            CouldNotParseCommand(self::CouldNotParseCommandRef<'a>),
            NoObjectMatch(self::NoObjectMatchRef<'a>),
            NoCommandMatch(self::NoCommandMatchRef<'a>),
            DatabaseError(self::DatabaseErrorRef<'a>),
            PermissionDenied(self::PermissionDeniedRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<CommandErrorUnionRef<'a>> for CommandErrorUnion {
            type Error = ::planus::Error;

            fn try_from(value: CommandErrorUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    CommandErrorUnionRef::CouldNotParseCommand(value) => {
                        Self::CouldNotParseCommand(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CommandErrorUnionRef::NoObjectMatch(value) => {
                        Self::NoObjectMatch(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CommandErrorUnionRef::NoCommandMatch(value) => {
                        Self::NoCommandMatch(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CommandErrorUnionRef::DatabaseError(value) => {
                        Self::DatabaseError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CommandErrorUnionRef::PermissionDenied(value) => {
                        Self::PermissionDenied(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for CommandErrorUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::CouldNotParseCommand(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::NoObjectMatch(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::NoCommandMatch(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::DatabaseError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::PermissionDenied(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for CommandErrorUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[CommandErrorUnionRef]";
        }

        /// The table `CouldNotParseCommand` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `CouldNotParseCommand` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:265`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CouldNotParseCommand {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for CouldNotParseCommand {
            fn default() -> Self {
                Self {}
            }
        }

        impl CouldNotParseCommand {
            /// Creates a [CouldNotParseCommandBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CouldNotParseCommandBuilder<()> {
                CouldNotParseCommandBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CouldNotParseCommand>> for CouldNotParseCommand {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CouldNotParseCommand> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CouldNotParseCommand>> for CouldNotParseCommand {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CouldNotParseCommand>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CouldNotParseCommand> for CouldNotParseCommand {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CouldNotParseCommand> {
                CouldNotParseCommand::create(builder)
            }
        }

        /// Builder for serializing an instance of the [CouldNotParseCommand] type.
        ///
        /// Can be created using the [CouldNotParseCommand::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CouldNotParseCommandBuilder<State>(State);

        impl CouldNotParseCommandBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CouldNotParseCommand].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CouldNotParseCommand>
            where
                Self: ::planus::WriteAsOffset<CouldNotParseCommand>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CouldNotParseCommand>> for CouldNotParseCommandBuilder<()> {
            type Prepared = ::planus::Offset<CouldNotParseCommand>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CouldNotParseCommand> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CouldNotParseCommand>>
            for CouldNotParseCommandBuilder<()>
        {
            type Prepared = ::planus::Offset<CouldNotParseCommand>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CouldNotParseCommand>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CouldNotParseCommand> for CouldNotParseCommandBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CouldNotParseCommand> {
                CouldNotParseCommand::create(builder)
            }
        }

        /// Reference to a deserialized [CouldNotParseCommand].
        #[derive(Copy, Clone)]
        pub struct CouldNotParseCommandRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CouldNotParseCommandRef<'a> {}

        impl<'a> ::core::fmt::Debug for CouldNotParseCommandRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CouldNotParseCommandRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CouldNotParseCommandRef<'a>> for CouldNotParseCommand {
            type Error = ::planus::Error;

            fn try_from(_value: CouldNotParseCommandRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for CouldNotParseCommandRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CouldNotParseCommandRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CouldNotParseCommandRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CouldNotParseCommand>> for CouldNotParseCommand {
            type Value = ::planus::Offset<CouldNotParseCommand>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CouldNotParseCommand>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CouldNotParseCommandRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CouldNotParseCommandRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `NoObjectMatch` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `NoObjectMatch` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:268`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct NoObjectMatch {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for NoObjectMatch {
            fn default() -> Self {
                Self {}
            }
        }

        impl NoObjectMatch {
            /// Creates a [NoObjectMatchBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> NoObjectMatchBuilder<()> {
                NoObjectMatchBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NoObjectMatch>> for NoObjectMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NoObjectMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NoObjectMatch>> for NoObjectMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NoObjectMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NoObjectMatch> for NoObjectMatch {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NoObjectMatch> {
                NoObjectMatch::create(builder)
            }
        }

        /// Builder for serializing an instance of the [NoObjectMatch] type.
        ///
        /// Can be created using the [NoObjectMatch::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct NoObjectMatchBuilder<State>(State);

        impl NoObjectMatchBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NoObjectMatch].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<NoObjectMatch>
            where
                Self: ::planus::WriteAsOffset<NoObjectMatch>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NoObjectMatch>> for NoObjectMatchBuilder<()> {
            type Prepared = ::planus::Offset<NoObjectMatch>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NoObjectMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NoObjectMatch>> for NoObjectMatchBuilder<()> {
            type Prepared = ::planus::Offset<NoObjectMatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NoObjectMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NoObjectMatch> for NoObjectMatchBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NoObjectMatch> {
                NoObjectMatch::create(builder)
            }
        }

        /// Reference to a deserialized [NoObjectMatch].
        #[derive(Copy, Clone)]
        pub struct NoObjectMatchRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> NoObjectMatchRef<'a> {}

        impl<'a> ::core::fmt::Debug for NoObjectMatchRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("NoObjectMatchRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<NoObjectMatchRef<'a>> for NoObjectMatch {
            type Error = ::planus::Error;

            fn try_from(_value: NoObjectMatchRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for NoObjectMatchRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for NoObjectMatchRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[NoObjectMatchRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<NoObjectMatch>> for NoObjectMatch {
            type Value = ::planus::Offset<NoObjectMatch>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<NoObjectMatch>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for NoObjectMatchRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[NoObjectMatchRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `NoCommandMatch` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `NoCommandMatch` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:271`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct NoCommandMatch {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for NoCommandMatch {
            fn default() -> Self {
                Self {}
            }
        }

        impl NoCommandMatch {
            /// Creates a [NoCommandMatchBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> NoCommandMatchBuilder<()> {
                NoCommandMatchBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NoCommandMatch>> for NoCommandMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NoCommandMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NoCommandMatch>> for NoCommandMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NoCommandMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NoCommandMatch> for NoCommandMatch {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NoCommandMatch> {
                NoCommandMatch::create(builder)
            }
        }

        /// Builder for serializing an instance of the [NoCommandMatch] type.
        ///
        /// Can be created using the [NoCommandMatch::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct NoCommandMatchBuilder<State>(State);

        impl NoCommandMatchBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NoCommandMatch].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<NoCommandMatch>
            where
                Self: ::planus::WriteAsOffset<NoCommandMatch>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NoCommandMatch>> for NoCommandMatchBuilder<()> {
            type Prepared = ::planus::Offset<NoCommandMatch>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NoCommandMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NoCommandMatch>> for NoCommandMatchBuilder<()> {
            type Prepared = ::planus::Offset<NoCommandMatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NoCommandMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NoCommandMatch> for NoCommandMatchBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NoCommandMatch> {
                NoCommandMatch::create(builder)
            }
        }

        /// Reference to a deserialized [NoCommandMatch].
        #[derive(Copy, Clone)]
        pub struct NoCommandMatchRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> NoCommandMatchRef<'a> {}

        impl<'a> ::core::fmt::Debug for NoCommandMatchRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("NoCommandMatchRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<NoCommandMatchRef<'a>> for NoCommandMatch {
            type Error = ::planus::Error;

            fn try_from(_value: NoCommandMatchRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for NoCommandMatchRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for NoCommandMatchRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[NoCommandMatchRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<NoCommandMatch>> for NoCommandMatch {
            type Value = ::planus::Offset<NoCommandMatch>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<NoCommandMatch>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for NoCommandMatchRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[NoCommandMatchRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DatabaseError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DatabaseError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:274`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DatabaseError {
            /// The field `error` in the table `DatabaseError`
            pub error: ::planus::alloc::boxed::Box<self::WorldStateError>,
        }

        impl DatabaseError {
            /// Creates a [DatabaseErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DatabaseErrorBuilder<()> {
                DatabaseErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::WorldStateError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorldStateError>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DatabaseError>> for DatabaseError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DatabaseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DatabaseError>> for DatabaseError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DatabaseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DatabaseError> for DatabaseError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DatabaseError> {
                DatabaseError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [DatabaseError] type.
        ///
        /// Can be created using the [DatabaseError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DatabaseErrorBuilder<State>(State);

        impl DatabaseErrorBuilder<()> {
            /// Setter for the [`error` field](DatabaseError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> DatabaseErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>,
            {
                DatabaseErrorBuilder((value,))
            }
        }

        impl<T0> DatabaseErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DatabaseError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<DatabaseError>
            where
                Self: ::planus::WriteAsOffset<DatabaseError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAs<::planus::Offset<DatabaseError>> for DatabaseErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DatabaseError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DatabaseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAsOptional<::planus::Offset<DatabaseError>>
            for DatabaseErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DatabaseError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DatabaseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorldStateError>>>
            ::planus::WriteAsOffset<DatabaseError> for DatabaseErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DatabaseError> {
                let (v0,) = &self.0;
                DatabaseError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [DatabaseError].
        #[derive(Copy, Clone)]
        pub struct DatabaseErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DatabaseErrorRef<'a> {
            /// Getter for the [`error` field](DatabaseError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::WorldStateErrorRef<'a>> {
                self.0.access_required(0, "DatabaseError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for DatabaseErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DatabaseErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DatabaseErrorRef<'a>> for DatabaseError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DatabaseErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DatabaseErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DatabaseErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DatabaseErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DatabaseError>> for DatabaseError {
            type Value = ::planus::Offset<DatabaseError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DatabaseError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DatabaseErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DatabaseErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PermissionDenied` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PermissionDenied` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:278`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PermissionDenied {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PermissionDenied {
            fn default() -> Self {
                Self {}
            }
        }

        impl PermissionDenied {
            /// Creates a [PermissionDeniedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PermissionDeniedBuilder<()> {
                PermissionDeniedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PermissionDenied>> for PermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PermissionDenied>> for PermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PermissionDenied> for PermissionDenied {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PermissionDenied> {
                PermissionDenied::create(builder)
            }
        }

        /// Builder for serializing an instance of the [PermissionDenied] type.
        ///
        /// Can be created using the [PermissionDenied::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PermissionDeniedBuilder<State>(State);

        impl PermissionDeniedBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PermissionDenied].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PermissionDenied>
            where
                Self: ::planus::WriteAsOffset<PermissionDenied>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PermissionDenied>> for PermissionDeniedBuilder<()> {
            type Prepared = ::planus::Offset<PermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PermissionDenied>> for PermissionDeniedBuilder<()> {
            type Prepared = ::planus::Offset<PermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PermissionDenied> for PermissionDeniedBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PermissionDenied> {
                PermissionDenied::create(builder)
            }
        }

        /// Reference to a deserialized [PermissionDenied].
        #[derive(Copy, Clone)]
        pub struct PermissionDeniedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PermissionDeniedRef<'a> {}

        impl<'a> ::core::fmt::Debug for PermissionDeniedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PermissionDeniedRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PermissionDeniedRef<'a>> for PermissionDenied {
            type Error = ::planus::Error;

            fn try_from(_value: PermissionDeniedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for PermissionDeniedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PermissionDeniedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PermissionDeniedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PermissionDenied>> for PermissionDenied {
            type Value = ::planus::Offset<PermissionDenied>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PermissionDenied>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PermissionDeniedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PermissionDeniedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `CommandError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `CommandError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:281`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CommandError {
            /// The field `error` in the table `CommandError`
            pub error: self::CommandErrorUnion,
        }

        impl CommandError {
            /// Creates a [CommandErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CommandErrorBuilder<()> {
                CommandErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAsUnion<self::CommandErrorUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CommandErrorUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error.offset());
                        object_writer.write::<_, _, 1>(&prepared_error.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CommandError>> for CommandError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CommandError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CommandError>> for CommandError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CommandError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CommandError> for CommandError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CommandError> {
                CommandError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [CommandError] type.
        ///
        /// Can be created using the [CommandError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CommandErrorBuilder<State>(State);

        impl CommandErrorBuilder<()> {
            /// Setter for the [`error` field](CommandError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> CommandErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::CommandErrorUnion>,
            {
                CommandErrorBuilder((value,))
            }
        }

        impl<T0> CommandErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CommandError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<CommandError>
            where
                Self: ::planus::WriteAsOffset<CommandError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::CommandErrorUnion>>
            ::planus::WriteAs<::planus::Offset<CommandError>> for CommandErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CommandError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CommandError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::CommandErrorUnion>>
            ::planus::WriteAsOptional<::planus::Offset<CommandError>>
            for CommandErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CommandError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CommandError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::CommandErrorUnion>>
            ::planus::WriteAsOffset<CommandError> for CommandErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CommandError> {
                let (v0,) = &self.0;
                CommandError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [CommandError].
        #[derive(Copy, Clone)]
        pub struct CommandErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CommandErrorRef<'a> {
            /// Getter for the [`error` field](CommandError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::CommandErrorUnionRef<'a>> {
                self.0.access_union_required(0, "CommandError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for CommandErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CommandErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CommandErrorRef<'a>> for CommandError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CommandErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::core::convert::TryInto::try_into(value.error()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CommandErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CommandErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CommandErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CommandError>> for CommandError {
            type Value = ::planus::Offset<CommandError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CommandError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CommandErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CommandErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `VerbProgramErrorUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `VerbProgramErrorUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:286`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum VerbProgramErrorUnion {
            /// The variant of type `NoVerbToProgram` in the union `VerbProgramErrorUnion`
            NoVerbToProgram(::planus::alloc::boxed::Box<self::NoVerbToProgram>),

            /// The variant of type `VerbCompilationError` in the union `VerbProgramErrorUnion`
            VerbCompilationError(::planus::alloc::boxed::Box<self::VerbCompilationError>),

            /// The variant of type `VerbDatabaseError` in the union `VerbProgramErrorUnion`
            VerbDatabaseError(::planus::alloc::boxed::Box<self::VerbDatabaseError>),
        }

        impl VerbProgramErrorUnion {
            /// Creates a [VerbProgramErrorUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbProgramErrorUnionBuilder<::planus::Uninitialized> {
                VerbProgramErrorUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_no_verb_to_program(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::NoVerbToProgram>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_compilation_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbCompilationError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_database_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbDatabaseError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<VerbProgramErrorUnion> for VerbProgramErrorUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::NoVerbToProgram(value) => Self::create_no_verb_to_program(builder, value),
                    Self::VerbCompilationError(value) => {
                        Self::create_verb_compilation_error(builder, value)
                    }
                    Self::VerbDatabaseError(value) => {
                        Self::create_verb_database_error(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<VerbProgramErrorUnion> for VerbProgramErrorUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [VerbProgramErrorUnion] type.
        ///
        /// Can be created using the [VerbProgramErrorUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbProgramErrorUnionBuilder<T>(T);

        impl VerbProgramErrorUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`NoVerbToProgram` variant](VerbProgramErrorUnion#variant.NoVerbToProgram).
            #[inline]
            pub fn no_verb_to_program<T>(
                self,
                value: T,
            ) -> VerbProgramErrorUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::NoVerbToProgram>,
            {
                VerbProgramErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbCompilationError` variant](VerbProgramErrorUnion#variant.VerbCompilationError).
            #[inline]
            pub fn verb_compilation_error<T>(
                self,
                value: T,
            ) -> VerbProgramErrorUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbCompilationError>,
            {
                VerbProgramErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbDatabaseError` variant](VerbProgramErrorUnion#variant.VerbDatabaseError).
            #[inline]
            pub fn verb_database_error<T>(
                self,
                value: T,
            ) -> VerbProgramErrorUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbDatabaseError>,
            {
                VerbProgramErrorUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> VerbProgramErrorUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [VerbProgramErrorUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<VerbProgramErrorUnion>
            where
                Self: ::planus::WriteAsUnion<VerbProgramErrorUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<VerbProgramErrorUnion>
            for VerbProgramErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::NoVerbToProgram>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<VerbProgramErrorUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VerbProgramErrorUnion>
            for VerbProgramErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::NoVerbToProgram>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VerbProgramErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VerbProgramErrorUnion>
            for VerbProgramErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbCompilationError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<VerbProgramErrorUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VerbProgramErrorUnion>
            for VerbProgramErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbCompilationError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VerbProgramErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VerbProgramErrorUnion>
            for VerbProgramErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbDatabaseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<VerbProgramErrorUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VerbProgramErrorUnion>
            for VerbProgramErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbDatabaseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VerbProgramErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [VerbProgramErrorUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum VerbProgramErrorUnionRef<'a> {
            NoVerbToProgram(self::NoVerbToProgramRef<'a>),
            VerbCompilationError(self::VerbCompilationErrorRef<'a>),
            VerbDatabaseError(self::VerbDatabaseErrorRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<VerbProgramErrorUnionRef<'a>> for VerbProgramErrorUnion {
            type Error = ::planus::Error;

            fn try_from(value: VerbProgramErrorUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    VerbProgramErrorUnionRef::NoVerbToProgram(value) => {
                        Self::NoVerbToProgram(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    VerbProgramErrorUnionRef::VerbCompilationError(value) => {
                        Self::VerbCompilationError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    VerbProgramErrorUnionRef::VerbDatabaseError(value) => {
                        Self::VerbDatabaseError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for VerbProgramErrorUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::NoVerbToProgram(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::VerbCompilationError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::VerbDatabaseError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for VerbProgramErrorUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[VerbProgramErrorUnionRef]";
        }

        /// The table `NoVerbToProgram` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `NoVerbToProgram` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:292`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct NoVerbToProgram {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for NoVerbToProgram {
            fn default() -> Self {
                Self {}
            }
        }

        impl NoVerbToProgram {
            /// Creates a [NoVerbToProgramBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> NoVerbToProgramBuilder<()> {
                NoVerbToProgramBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NoVerbToProgram>> for NoVerbToProgram {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NoVerbToProgram> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NoVerbToProgram>> for NoVerbToProgram {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NoVerbToProgram>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NoVerbToProgram> for NoVerbToProgram {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NoVerbToProgram> {
                NoVerbToProgram::create(builder)
            }
        }

        /// Builder for serializing an instance of the [NoVerbToProgram] type.
        ///
        /// Can be created using the [NoVerbToProgram::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct NoVerbToProgramBuilder<State>(State);

        impl NoVerbToProgramBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NoVerbToProgram].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NoVerbToProgram>
            where
                Self: ::planus::WriteAsOffset<NoVerbToProgram>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NoVerbToProgram>> for NoVerbToProgramBuilder<()> {
            type Prepared = ::planus::Offset<NoVerbToProgram>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NoVerbToProgram> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NoVerbToProgram>> for NoVerbToProgramBuilder<()> {
            type Prepared = ::planus::Offset<NoVerbToProgram>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NoVerbToProgram>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NoVerbToProgram> for NoVerbToProgramBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NoVerbToProgram> {
                NoVerbToProgram::create(builder)
            }
        }

        /// Reference to a deserialized [NoVerbToProgram].
        #[derive(Copy, Clone)]
        pub struct NoVerbToProgramRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> NoVerbToProgramRef<'a> {}

        impl<'a> ::core::fmt::Debug for NoVerbToProgramRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("NoVerbToProgramRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<NoVerbToProgramRef<'a>> for NoVerbToProgram {
            type Error = ::planus::Error;

            fn try_from(_value: NoVerbToProgramRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for NoVerbToProgramRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for NoVerbToProgramRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[NoVerbToProgramRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<NoVerbToProgram>> for NoVerbToProgram {
            type Value = ::planus::Offset<NoVerbToProgram>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<NoVerbToProgram>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for NoVerbToProgramRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[NoVerbToProgramRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbCompilationError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbCompilationError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:295`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbCompilationError {
            /// The field `error` in the table `VerbCompilationError`
            pub error: ::planus::alloc::boxed::Box<self::CompileError>,
        }

        impl VerbCompilationError {
            /// Creates a [VerbCompilationErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbCompilationErrorBuilder<()> {
                VerbCompilationErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::CompileError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileError>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbCompilationError>> for VerbCompilationError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbCompilationError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbCompilationError>> for VerbCompilationError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbCompilationError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbCompilationError> for VerbCompilationError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbCompilationError> {
                VerbCompilationError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [VerbCompilationError] type.
        ///
        /// Can be created using the [VerbCompilationError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbCompilationErrorBuilder<State>(State);

        impl VerbCompilationErrorBuilder<()> {
            /// Setter for the [`error` field](VerbCompilationError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> VerbCompilationErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileError>>,
            {
                VerbCompilationErrorBuilder((value,))
            }
        }

        impl<T0> VerbCompilationErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbCompilationError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbCompilationError>
            where
                Self: ::planus::WriteAsOffset<VerbCompilationError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileError>>>
            ::planus::WriteAs<::planus::Offset<VerbCompilationError>>
            for VerbCompilationErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbCompilationError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbCompilationError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileError>>>
            ::planus::WriteAsOptional<::planus::Offset<VerbCompilationError>>
            for VerbCompilationErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbCompilationError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbCompilationError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileError>>>
            ::planus::WriteAsOffset<VerbCompilationError> for VerbCompilationErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbCompilationError> {
                let (v0,) = &self.0;
                VerbCompilationError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VerbCompilationError].
        #[derive(Copy, Clone)]
        pub struct VerbCompilationErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbCompilationErrorRef<'a> {
            /// Getter for the [`error` field](VerbCompilationError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::CompileErrorRef<'a>> {
                self.0.access_required(0, "VerbCompilationError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbCompilationErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbCompilationErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbCompilationErrorRef<'a>> for VerbCompilationError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbCompilationErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbCompilationErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbCompilationErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbCompilationErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbCompilationError>> for VerbCompilationError {
            type Value = ::planus::Offset<VerbCompilationError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbCompilationError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbCompilationErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbCompilationErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbDatabaseError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbDatabaseError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:299`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbDatabaseError {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VerbDatabaseError {
            fn default() -> Self {
                Self {}
            }
        }

        impl VerbDatabaseError {
            /// Creates a [VerbDatabaseErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbDatabaseErrorBuilder<()> {
                VerbDatabaseErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbDatabaseError>> for VerbDatabaseError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDatabaseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbDatabaseError>> for VerbDatabaseError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbDatabaseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbDatabaseError> for VerbDatabaseError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDatabaseError> {
                VerbDatabaseError::create(builder)
            }
        }

        /// Builder for serializing an instance of the [VerbDatabaseError] type.
        ///
        /// Can be created using the [VerbDatabaseError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbDatabaseErrorBuilder<State>(State);

        impl VerbDatabaseErrorBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbDatabaseError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDatabaseError>
            where
                Self: ::planus::WriteAsOffset<VerbDatabaseError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbDatabaseError>> for VerbDatabaseErrorBuilder<()> {
            type Prepared = ::planus::Offset<VerbDatabaseError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDatabaseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbDatabaseError>>
            for VerbDatabaseErrorBuilder<()>
        {
            type Prepared = ::planus::Offset<VerbDatabaseError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbDatabaseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbDatabaseError> for VerbDatabaseErrorBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDatabaseError> {
                VerbDatabaseError::create(builder)
            }
        }

        /// Reference to a deserialized [VerbDatabaseError].
        #[derive(Copy, Clone)]
        pub struct VerbDatabaseErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbDatabaseErrorRef<'a> {}

        impl<'a> ::core::fmt::Debug for VerbDatabaseErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbDatabaseErrorRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbDatabaseErrorRef<'a>> for VerbDatabaseError {
            type Error = ::planus::Error;

            fn try_from(_value: VerbDatabaseErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbDatabaseErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbDatabaseErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbDatabaseErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbDatabaseError>> for VerbDatabaseError {
            type Value = ::planus::Offset<VerbDatabaseError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbDatabaseError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbDatabaseErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbDatabaseErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbProgramError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbProgramError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:302`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbProgramError {
            /// The field `error` in the table `VerbProgramError`
            pub error: self::VerbProgramErrorUnion,
        }

        impl VerbProgramError {
            /// Creates a [VerbProgramErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbProgramErrorBuilder<()> {
                VerbProgramErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAsUnion<self::VerbProgramErrorUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::VerbProgramErrorUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error.offset());
                        object_writer.write::<_, _, 1>(&prepared_error.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbProgramError>> for VerbProgramError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbProgramError>> for VerbProgramError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbProgramError> for VerbProgramError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramError> {
                VerbProgramError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [VerbProgramError] type.
        ///
        /// Can be created using the [VerbProgramError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbProgramErrorBuilder<State>(State);

        impl VerbProgramErrorBuilder<()> {
            /// Setter for the [`error` field](VerbProgramError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> VerbProgramErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::VerbProgramErrorUnion>,
            {
                VerbProgramErrorBuilder((value,))
            }
        }

        impl<T0> VerbProgramErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbProgramError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramError>
            where
                Self: ::planus::WriteAsOffset<VerbProgramError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::VerbProgramErrorUnion>>
            ::planus::WriteAs<::planus::Offset<VerbProgramError>>
            for VerbProgramErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbProgramError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::VerbProgramErrorUnion>>
            ::planus::WriteAsOptional<::planus::Offset<VerbProgramError>>
            for VerbProgramErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbProgramError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::VerbProgramErrorUnion>>
            ::planus::WriteAsOffset<VerbProgramError> for VerbProgramErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramError> {
                let (v0,) = &self.0;
                VerbProgramError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VerbProgramError].
        #[derive(Copy, Clone)]
        pub struct VerbProgramErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbProgramErrorRef<'a> {
            /// Getter for the [`error` field](VerbProgramError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::VerbProgramErrorUnionRef<'a>> {
                self.0.access_union_required(0, "VerbProgramError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbProgramErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbProgramErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbProgramErrorRef<'a>> for VerbProgramError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbProgramErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::core::convert::TryInto::try_into(value.error()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbProgramErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbProgramErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbProgramErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbProgramError>> for VerbProgramError {
            type Value = ::planus::Offset<VerbProgramError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbProgramError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbProgramErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbProgramErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `WorkerErrorUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `WorkerErrorUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:307`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum WorkerErrorUnion {
            /// The variant of type `WorkerPermissionDenied` in the union `WorkerErrorUnion`
            WorkerPermissionDenied(::planus::alloc::boxed::Box<self::WorkerPermissionDenied>),

            /// The variant of type `WorkerInvalidRequest` in the union `WorkerErrorUnion`
            WorkerInvalidRequest(::planus::alloc::boxed::Box<self::WorkerInvalidRequest>),

            /// The variant of type `WorkerInternalError` in the union `WorkerErrorUnion`
            WorkerInternalError(::planus::alloc::boxed::Box<self::WorkerInternalError>),

            /// The variant of type `WorkerRequestTimedOut` in the union `WorkerErrorUnion`
            WorkerRequestTimedOut(::planus::alloc::boxed::Box<self::WorkerRequestTimedOut>),

            /// The variant of type `WorkerRequestError` in the union `WorkerErrorUnion`
            WorkerRequestError(::planus::alloc::boxed::Box<self::WorkerRequestError>),

            /// The variant of type `WorkerDetached` in the union `WorkerErrorUnion`
            WorkerDetached(::planus::alloc::boxed::Box<self::WorkerDetached>),

            /// The variant of type `NoWorkerAvailable` in the union `WorkerErrorUnion`
            NoWorkerAvailable(::planus::alloc::boxed::Box<self::NoWorkerAvailable>),
        }

        impl WorkerErrorUnion {
            /// Creates a [WorkerErrorUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerErrorUnionBuilder<::planus::Uninitialized> {
                WorkerErrorUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_worker_permission_denied(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerPermissionDenied>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_worker_invalid_request(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerInvalidRequest>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_worker_internal_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerInternalError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_worker_request_timed_out(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerRequestTimedOut>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_worker_request_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerRequestError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_worker_detached(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerDetached>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_no_worker_available(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::NoWorkerAvailable>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<WorkerErrorUnion> for WorkerErrorUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::WorkerPermissionDenied(value) => {
                        Self::create_worker_permission_denied(builder, value)
                    }
                    Self::WorkerInvalidRequest(value) => {
                        Self::create_worker_invalid_request(builder, value)
                    }
                    Self::WorkerInternalError(value) => {
                        Self::create_worker_internal_error(builder, value)
                    }
                    Self::WorkerRequestTimedOut(value) => {
                        Self::create_worker_request_timed_out(builder, value)
                    }
                    Self::WorkerRequestError(value) => {
                        Self::create_worker_request_error(builder, value)
                    }
                    Self::WorkerDetached(value) => Self::create_worker_detached(builder, value),
                    Self::NoWorkerAvailable(value) => {
                        Self::create_no_worker_available(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<WorkerErrorUnion> for WorkerErrorUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [WorkerErrorUnion] type.
        ///
        /// Can be created using the [WorkerErrorUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerErrorUnionBuilder<T>(T);

        impl WorkerErrorUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`WorkerPermissionDenied` variant](WorkerErrorUnion#variant.WorkerPermissionDenied).
            #[inline]
            pub fn worker_permission_denied<T>(
                self,
                value: T,
            ) -> WorkerErrorUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerPermissionDenied>,
            {
                WorkerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorkerInvalidRequest` variant](WorkerErrorUnion#variant.WorkerInvalidRequest).
            #[inline]
            pub fn worker_invalid_request<T>(
                self,
                value: T,
            ) -> WorkerErrorUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerInvalidRequest>,
            {
                WorkerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorkerInternalError` variant](WorkerErrorUnion#variant.WorkerInternalError).
            #[inline]
            pub fn worker_internal_error<T>(
                self,
                value: T,
            ) -> WorkerErrorUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerInternalError>,
            {
                WorkerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorkerRequestTimedOut` variant](WorkerErrorUnion#variant.WorkerRequestTimedOut).
            #[inline]
            pub fn worker_request_timed_out<T>(
                self,
                value: T,
            ) -> WorkerErrorUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerRequestTimedOut>,
            {
                WorkerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorkerRequestError` variant](WorkerErrorUnion#variant.WorkerRequestError).
            #[inline]
            pub fn worker_request_error<T>(
                self,
                value: T,
            ) -> WorkerErrorUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerRequestError>,
            {
                WorkerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorkerDetached` variant](WorkerErrorUnion#variant.WorkerDetached).
            #[inline]
            pub fn worker_detached<T>(
                self,
                value: T,
            ) -> WorkerErrorUnionBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerDetached>,
            {
                WorkerErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`NoWorkerAvailable` variant](WorkerErrorUnion#variant.NoWorkerAvailable).
            #[inline]
            pub fn no_worker_available<T>(
                self,
                value: T,
            ) -> WorkerErrorUnionBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<self::NoWorkerAvailable>,
            {
                WorkerErrorUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> WorkerErrorUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [WorkerErrorUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerErrorUnion>
            where
                Self: ::planus::WriteAsUnion<WorkerErrorUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerErrorUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerInvalidRequest>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerErrorUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerInvalidRequest>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerInternalError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerErrorUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerInternalError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerRequestTimedOut>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerErrorUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerRequestTimedOut>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerRequestError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerErrorUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerRequestError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerDetached>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerErrorUnion> {
                ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerDetached>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::NoWorkerAvailable>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerErrorUnion> {
                ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerErrorUnion>
            for WorkerErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::NoWorkerAvailable>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [WorkerErrorUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum WorkerErrorUnionRef<'a> {
            WorkerPermissionDenied(self::WorkerPermissionDeniedRef<'a>),
            WorkerInvalidRequest(self::WorkerInvalidRequestRef<'a>),
            WorkerInternalError(self::WorkerInternalErrorRef<'a>),
            WorkerRequestTimedOut(self::WorkerRequestTimedOutRef<'a>),
            WorkerRequestError(self::WorkerRequestErrorRef<'a>),
            WorkerDetached(self::WorkerDetachedRef<'a>),
            NoWorkerAvailable(self::NoWorkerAvailableRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<WorkerErrorUnionRef<'a>> for WorkerErrorUnion {
            type Error = ::planus::Error;

            fn try_from(value: WorkerErrorUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    WorkerErrorUnionRef::WorkerPermissionDenied(value) => {
                        Self::WorkerPermissionDenied(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorkerErrorUnionRef::WorkerInvalidRequest(value) => {
                        Self::WorkerInvalidRequest(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorkerErrorUnionRef::WorkerInternalError(value) => {
                        Self::WorkerInternalError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorkerErrorUnionRef::WorkerRequestTimedOut(value) => {
                        Self::WorkerRequestTimedOut(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorkerErrorUnionRef::WorkerRequestError(value) => {
                        Self::WorkerRequestError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorkerErrorUnionRef::WorkerDetached(value) => {
                        Self::WorkerDetached(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorkerErrorUnionRef::NoWorkerAvailable(value) => {
                        Self::NoWorkerAvailable(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for WorkerErrorUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::WorkerPermissionDenied(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::WorkerInvalidRequest(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::WorkerInternalError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::WorkerRequestTimedOut(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::WorkerRequestError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    6 => ::core::result::Result::Ok(Self::WorkerDetached(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    7 => ::core::result::Result::Ok(Self::NoWorkerAvailable(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for WorkerErrorUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[WorkerErrorUnionRef]";
        }

        /// The table `WorkerPermissionDenied` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerPermissionDenied` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:317`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerPermissionDenied {
            /// The field `message` in the table `WorkerPermissionDenied`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerPermissionDenied {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl WorkerPermissionDenied {
            /// Creates a [WorkerPermissionDeniedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerPermissionDeniedBuilder<()> {
                WorkerPermissionDeniedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerPermissionDenied>> for WorkerPermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerPermissionDenied>>
            for WorkerPermissionDenied
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerPermissionDenied> for WorkerPermissionDenied {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerPermissionDenied> {
                WorkerPermissionDenied::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [WorkerPermissionDenied] type.
        ///
        /// Can be created using the [WorkerPermissionDenied::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerPermissionDeniedBuilder<State>(State);

        impl WorkerPermissionDeniedBuilder<()> {
            /// Setter for the [`message` field](WorkerPermissionDenied#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> WorkerPermissionDeniedBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                WorkerPermissionDeniedBuilder((value,))
            }
        }

        impl<T0> WorkerPermissionDeniedBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerPermissionDenied].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerPermissionDenied>
            where
                Self: ::planus::WriteAsOffset<WorkerPermissionDenied>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<WorkerPermissionDenied>>
            for WorkerPermissionDeniedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<WorkerPermissionDenied>>
            for WorkerPermissionDeniedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOffset<WorkerPermissionDenied>
            for WorkerPermissionDeniedBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerPermissionDenied> {
                let (v0,) = &self.0;
                WorkerPermissionDenied::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorkerPermissionDenied].
        #[derive(Copy, Clone)]
        pub struct WorkerPermissionDeniedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerPermissionDeniedRef<'a> {
            /// Getter for the [`message` field](WorkerPermissionDenied#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(0, "WorkerPermissionDenied", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerPermissionDeniedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerPermissionDeniedRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerPermissionDeniedRef<'a>> for WorkerPermissionDenied {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerPermissionDeniedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerPermissionDeniedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerPermissionDeniedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerPermissionDeniedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerPermissionDenied>>
            for WorkerPermissionDenied
        {
            type Value = ::planus::Offset<WorkerPermissionDenied>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerPermissionDenied>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerPermissionDeniedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerPermissionDeniedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerInvalidRequest` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerInvalidRequest` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:321`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerInvalidRequest {
            /// The field `message` in the table `WorkerInvalidRequest`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerInvalidRequest {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl WorkerInvalidRequest {
            /// Creates a [WorkerInvalidRequestBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerInvalidRequestBuilder<()> {
                WorkerInvalidRequestBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerInvalidRequest>> for WorkerInvalidRequest {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerInvalidRequest> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerInvalidRequest>> for WorkerInvalidRequest {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerInvalidRequest>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerInvalidRequest> for WorkerInvalidRequest {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerInvalidRequest> {
                WorkerInvalidRequest::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [WorkerInvalidRequest] type.
        ///
        /// Can be created using the [WorkerInvalidRequest::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerInvalidRequestBuilder<State>(State);

        impl WorkerInvalidRequestBuilder<()> {
            /// Setter for the [`message` field](WorkerInvalidRequest#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> WorkerInvalidRequestBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                WorkerInvalidRequestBuilder((value,))
            }
        }

        impl<T0> WorkerInvalidRequestBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerInvalidRequest].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerInvalidRequest>
            where
                Self: ::planus::WriteAsOffset<WorkerInvalidRequest>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<WorkerInvalidRequest>>
            for WorkerInvalidRequestBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerInvalidRequest>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerInvalidRequest> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<WorkerInvalidRequest>>
            for WorkerInvalidRequestBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerInvalidRequest>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerInvalidRequest>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOffset<WorkerInvalidRequest> for WorkerInvalidRequestBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerInvalidRequest> {
                let (v0,) = &self.0;
                WorkerInvalidRequest::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorkerInvalidRequest].
        #[derive(Copy, Clone)]
        pub struct WorkerInvalidRequestRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerInvalidRequestRef<'a> {
            /// Getter for the [`message` field](WorkerInvalidRequest#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "WorkerInvalidRequest", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerInvalidRequestRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerInvalidRequestRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerInvalidRequestRef<'a>> for WorkerInvalidRequest {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerInvalidRequestRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerInvalidRequestRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerInvalidRequestRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerInvalidRequestRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerInvalidRequest>> for WorkerInvalidRequest {
            type Value = ::planus::Offset<WorkerInvalidRequest>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerInvalidRequest>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerInvalidRequestRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerInvalidRequestRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerInternalError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerInternalError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:325`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerInternalError {
            /// The field `message` in the table `WorkerInternalError`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerInternalError {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl WorkerInternalError {
            /// Creates a [WorkerInternalErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerInternalErrorBuilder<()> {
                WorkerInternalErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerInternalError>> for WorkerInternalError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerInternalError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerInternalError>> for WorkerInternalError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerInternalError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerInternalError> for WorkerInternalError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerInternalError> {
                WorkerInternalError::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [WorkerInternalError] type.
        ///
        /// Can be created using the [WorkerInternalError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerInternalErrorBuilder<State>(State);

        impl WorkerInternalErrorBuilder<()> {
            /// Setter for the [`message` field](WorkerInternalError#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> WorkerInternalErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                WorkerInternalErrorBuilder((value,))
            }
        }

        impl<T0> WorkerInternalErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerInternalError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerInternalError>
            where
                Self: ::planus::WriteAsOffset<WorkerInternalError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<WorkerInternalError>>
            for WorkerInternalErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerInternalError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerInternalError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<WorkerInternalError>>
            for WorkerInternalErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerInternalError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerInternalError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOffset<WorkerInternalError> for WorkerInternalErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerInternalError> {
                let (v0,) = &self.0;
                WorkerInternalError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorkerInternalError].
        #[derive(Copy, Clone)]
        pub struct WorkerInternalErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerInternalErrorRef<'a> {
            /// Getter for the [`message` field](WorkerInternalError#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "WorkerInternalError", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerInternalErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerInternalErrorRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerInternalErrorRef<'a>> for WorkerInternalError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerInternalErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerInternalErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerInternalErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerInternalErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerInternalError>> for WorkerInternalError {
            type Value = ::planus::Offset<WorkerInternalError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerInternalError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerInternalErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerInternalErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerRequestTimedOut` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerRequestTimedOut` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:329`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerRequestTimedOut {
            /// The field `message` in the table `WorkerRequestTimedOut`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerRequestTimedOut {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl WorkerRequestTimedOut {
            /// Creates a [WorkerRequestTimedOutBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerRequestTimedOutBuilder<()> {
                WorkerRequestTimedOutBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerRequestTimedOut>> for WorkerRequestTimedOut {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerRequestTimedOut> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerRequestTimedOut>> for WorkerRequestTimedOut {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerRequestTimedOut>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerRequestTimedOut> for WorkerRequestTimedOut {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerRequestTimedOut> {
                WorkerRequestTimedOut::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [WorkerRequestTimedOut] type.
        ///
        /// Can be created using the [WorkerRequestTimedOut::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerRequestTimedOutBuilder<State>(State);

        impl WorkerRequestTimedOutBuilder<()> {
            /// Setter for the [`message` field](WorkerRequestTimedOut#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> WorkerRequestTimedOutBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                WorkerRequestTimedOutBuilder((value,))
            }
        }

        impl<T0> WorkerRequestTimedOutBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerRequestTimedOut].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerRequestTimedOut>
            where
                Self: ::planus::WriteAsOffset<WorkerRequestTimedOut>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<WorkerRequestTimedOut>>
            for WorkerRequestTimedOutBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerRequestTimedOut>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerRequestTimedOut> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<WorkerRequestTimedOut>>
            for WorkerRequestTimedOutBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerRequestTimedOut>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerRequestTimedOut>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOffset<WorkerRequestTimedOut> for WorkerRequestTimedOutBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerRequestTimedOut> {
                let (v0,) = &self.0;
                WorkerRequestTimedOut::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorkerRequestTimedOut].
        #[derive(Copy, Clone)]
        pub struct WorkerRequestTimedOutRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerRequestTimedOutRef<'a> {
            /// Getter for the [`message` field](WorkerRequestTimedOut#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(0, "WorkerRequestTimedOut", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerRequestTimedOutRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerRequestTimedOutRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerRequestTimedOutRef<'a>> for WorkerRequestTimedOut {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerRequestTimedOutRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerRequestTimedOutRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerRequestTimedOutRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerRequestTimedOutRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerRequestTimedOut>>
            for WorkerRequestTimedOut
        {
            type Value = ::planus::Offset<WorkerRequestTimedOut>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerRequestTimedOut>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerRequestTimedOutRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerRequestTimedOutRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerRequestError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerRequestError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:333`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerRequestError {
            /// The field `message` in the table `WorkerRequestError`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerRequestError {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl WorkerRequestError {
            /// Creates a [WorkerRequestErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerRequestErrorBuilder<()> {
                WorkerRequestErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerRequestError>> for WorkerRequestError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerRequestError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerRequestError>> for WorkerRequestError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerRequestError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerRequestError> for WorkerRequestError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerRequestError> {
                WorkerRequestError::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [WorkerRequestError] type.
        ///
        /// Can be created using the [WorkerRequestError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerRequestErrorBuilder<State>(State);

        impl WorkerRequestErrorBuilder<()> {
            /// Setter for the [`message` field](WorkerRequestError#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> WorkerRequestErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                WorkerRequestErrorBuilder((value,))
            }
        }

        impl<T0> WorkerRequestErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerRequestError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerRequestError>
            where
                Self: ::planus::WriteAsOffset<WorkerRequestError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<WorkerRequestError>>
            for WorkerRequestErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerRequestError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerRequestError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<WorkerRequestError>>
            for WorkerRequestErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerRequestError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerRequestError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOffset<WorkerRequestError> for WorkerRequestErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerRequestError> {
                let (v0,) = &self.0;
                WorkerRequestError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorkerRequestError].
        #[derive(Copy, Clone)]
        pub struct WorkerRequestErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerRequestErrorRef<'a> {
            /// Getter for the [`message` field](WorkerRequestError#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "WorkerRequestError", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerRequestErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerRequestErrorRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerRequestErrorRef<'a>> for WorkerRequestError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerRequestErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerRequestErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerRequestErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerRequestErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerRequestError>> for WorkerRequestError {
            type Value = ::planus::Offset<WorkerRequestError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerRequestError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerRequestErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerRequestErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerDetached` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerDetached` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:337`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerDetached {
            /// The field `message` in the table `WorkerDetached`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerDetached {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl WorkerDetached {
            /// Creates a [WorkerDetachedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerDetachedBuilder<()> {
                WorkerDetachedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerDetached>> for WorkerDetached {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerDetached> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerDetached>> for WorkerDetached {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerDetached>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerDetached> for WorkerDetached {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerDetached> {
                WorkerDetached::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [WorkerDetached] type.
        ///
        /// Can be created using the [WorkerDetached::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerDetachedBuilder<State>(State);

        impl WorkerDetachedBuilder<()> {
            /// Setter for the [`message` field](WorkerDetached#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> WorkerDetachedBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                WorkerDetachedBuilder((value,))
            }
        }

        impl<T0> WorkerDetachedBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerDetached].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerDetached>
            where
                Self: ::planus::WriteAsOffset<WorkerDetached>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<WorkerDetached>> for WorkerDetachedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerDetached>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerDetached> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<WorkerDetached>>
            for WorkerDetachedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerDetached>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerDetached>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<WorkerDetached>
            for WorkerDetachedBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerDetached> {
                let (v0,) = &self.0;
                WorkerDetached::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorkerDetached].
        #[derive(Copy, Clone)]
        pub struct WorkerDetachedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerDetachedRef<'a> {
            /// Getter for the [`message` field](WorkerDetached#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "WorkerDetached", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerDetachedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerDetachedRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerDetachedRef<'a>> for WorkerDetached {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerDetachedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerDetachedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerDetachedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerDetachedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerDetached>> for WorkerDetached {
            type Value = ::planus::Offset<WorkerDetached>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerDetached>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerDetachedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerDetachedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `NoWorkerAvailable` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `NoWorkerAvailable` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:341`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct NoWorkerAvailable {
            /// The field `worker_type` in the table `NoWorkerAvailable`
            pub worker_type: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for NoWorkerAvailable {
            fn default() -> Self {
                Self {
                    worker_type: ::core::default::Default::default(),
                }
            }
        }

        impl NoWorkerAvailable {
            /// Creates a [NoWorkerAvailableBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> NoWorkerAvailableBuilder<()> {
                NoWorkerAvailableBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_worker_type: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_worker_type = field_worker_type.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_worker_type);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NoWorkerAvailable>> for NoWorkerAvailable {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NoWorkerAvailable> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NoWorkerAvailable>> for NoWorkerAvailable {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NoWorkerAvailable>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NoWorkerAvailable> for NoWorkerAvailable {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NoWorkerAvailable> {
                NoWorkerAvailable::create(builder, &self.worker_type)
            }
        }

        /// Builder for serializing an instance of the [NoWorkerAvailable] type.
        ///
        /// Can be created using the [NoWorkerAvailable::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct NoWorkerAvailableBuilder<State>(State);

        impl NoWorkerAvailableBuilder<()> {
            /// Setter for the [`worker_type` field](NoWorkerAvailable#structfield.worker_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn worker_type<T0>(self, value: T0) -> NoWorkerAvailableBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                NoWorkerAvailableBuilder((value,))
            }
        }

        impl<T0> NoWorkerAvailableBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NoWorkerAvailable].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NoWorkerAvailable>
            where
                Self: ::planus::WriteAsOffset<NoWorkerAvailable>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>>
            ::planus::WriteAs<::planus::Offset<NoWorkerAvailable>>
            for NoWorkerAvailableBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<NoWorkerAvailable>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NoWorkerAvailable> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>>
            ::planus::WriteAsOptional<::planus::Offset<NoWorkerAvailable>>
            for NoWorkerAvailableBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<NoWorkerAvailable>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NoWorkerAvailable>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>>
            ::planus::WriteAsOffset<NoWorkerAvailable> for NoWorkerAvailableBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NoWorkerAvailable> {
                let (v0,) = &self.0;
                NoWorkerAvailable::create(builder, v0)
            }
        }

        /// Reference to a deserialized [NoWorkerAvailable].
        #[derive(Copy, Clone)]
        pub struct NoWorkerAvailableRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> NoWorkerAvailableRef<'a> {
            /// Getter for the [`worker_type` field](NoWorkerAvailable#structfield.worker_type).
            #[inline]
            pub fn worker_type(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0
                    .access_required(0, "NoWorkerAvailable", "worker_type")
            }
        }

        impl<'a> ::core::fmt::Debug for NoWorkerAvailableRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("NoWorkerAvailableRef");
                f.field("worker_type", &self.worker_type());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<NoWorkerAvailableRef<'a>> for NoWorkerAvailable {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: NoWorkerAvailableRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    worker_type: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.worker_type()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for NoWorkerAvailableRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for NoWorkerAvailableRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[NoWorkerAvailableRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<NoWorkerAvailable>> for NoWorkerAvailable {
            type Value = ::planus::Offset<NoWorkerAvailable>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<NoWorkerAvailable>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for NoWorkerAvailableRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[NoWorkerAvailableRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:345`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerError {
            /// The field `error` in the table `WorkerError`
            pub error: self::WorkerErrorUnion,
        }

        impl WorkerError {
            /// Creates a [WorkerErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerErrorBuilder<()> {
                WorkerErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAsUnion<self::WorkerErrorUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorkerErrorUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error.offset());
                        object_writer.write::<_, _, 1>(&prepared_error.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerError>> for WorkerError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerError>> for WorkerError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerError> for WorkerError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerError> {
                WorkerError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [WorkerError] type.
        ///
        /// Can be created using the [WorkerError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerErrorBuilder<State>(State);

        impl WorkerErrorBuilder<()> {
            /// Setter for the [`error` field](WorkerError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> WorkerErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::WorkerErrorUnion>,
            {
                WorkerErrorBuilder((value,))
            }
        }

        impl<T0> WorkerErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerError>
            where
                Self: ::planus::WriteAsOffset<WorkerError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorkerErrorUnion>>
            ::planus::WriteAs<::planus::Offset<WorkerError>> for WorkerErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorkerErrorUnion>>
            ::planus::WriteAsOptional<::planus::Offset<WorkerError>> for WorkerErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorkerErrorUnion>>
            ::planus::WriteAsOffset<WorkerError> for WorkerErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerError> {
                let (v0,) = &self.0;
                WorkerError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorkerError].
        #[derive(Copy, Clone)]
        pub struct WorkerErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerErrorRef<'a> {
            /// Getter for the [`error` field](WorkerError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::WorkerErrorUnionRef<'a>> {
                self.0.access_union_required(0, "WorkerError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerErrorRef<'a>> for WorkerError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::core::convert::TryInto::try_into(value.error()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerError>> for WorkerError {
            type Value = ::planus::Offset<WorkerError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `CompileContext` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `CompileContext` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:350`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CompileContext {
            /// The field `line` in the table `CompileContext`
            pub line: u64,
            /// The field `col` in the table `CompileContext`
            pub col: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for CompileContext {
            fn default() -> Self {
                Self { line: 0, col: 0 }
            }
        }

        impl CompileContext {
            /// Creates a [CompileContextBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CompileContextBuilder<()> {
                CompileContextBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_line: impl ::planus::WriteAsDefault<u64, u64>,
                field_col: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_line = field_line.prepare(builder, &0);
                let prepared_col = field_col.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_line.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                if prepared_col.is_some() {
                    table_writer.write_entry::<u64>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_line) = prepared_line {
                            object_writer.write::<_, _, 8>(&prepared_line);
                        }
                        if let ::core::option::Option::Some(prepared_col) = prepared_col {
                            object_writer.write::<_, _, 8>(&prepared_col);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CompileContext>> for CompileContext {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileContext> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CompileContext>> for CompileContext {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CompileContext>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CompileContext> for CompileContext {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileContext> {
                CompileContext::create(builder, self.line, self.col)
            }
        }

        /// Builder for serializing an instance of the [CompileContext] type.
        ///
        /// Can be created using the [CompileContext::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CompileContextBuilder<State>(State);

        impl CompileContextBuilder<()> {
            /// Setter for the [`line` field](CompileContext#structfield.line).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn line<T0>(self, value: T0) -> CompileContextBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                CompileContextBuilder((value,))
            }

            /// Sets the [`line` field](CompileContext#structfield.line) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn line_as_default(self) -> CompileContextBuilder<(::planus::DefaultValue,)> {
                self.line(::planus::DefaultValue)
            }
        }

        impl<T0> CompileContextBuilder<(T0,)> {
            /// Setter for the [`col` field](CompileContext#structfield.col).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn col<T1>(self, value: T1) -> CompileContextBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                CompileContextBuilder((v0, value))
            }

            /// Sets the [`col` field](CompileContext#structfield.col) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn col_as_default(self) -> CompileContextBuilder<(T0, ::planus::DefaultValue)> {
                self.col(::planus::DefaultValue)
            }
        }

        impl<T0, T1> CompileContextBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CompileContext].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileContext>
            where
                Self: ::planus::WriteAsOffset<CompileContext>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAs<::planus::Offset<CompileContext>>
            for CompileContextBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<CompileContext>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileContext> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<CompileContext>>
            for CompileContextBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<CompileContext>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CompileContext>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOffset<CompileContext> for CompileContextBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileContext> {
                let (v0, v1) = &self.0;
                CompileContext::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [CompileContext].
        #[derive(Copy, Clone)]
        pub struct CompileContextRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CompileContextRef<'a> {
            /// Getter for the [`line` field](CompileContext#structfield.line).
            #[inline]
            pub fn line(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(0, "CompileContext", "line")?.unwrap_or(0))
            }

            /// Getter for the [`col` field](CompileContext#structfield.col).
            #[inline]
            pub fn col(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(1, "CompileContext", "col")?.unwrap_or(0))
            }
        }

        impl<'a> ::core::fmt::Debug for CompileContextRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CompileContextRef");
                f.field("line", &self.line());
                f.field("col", &self.col());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CompileContextRef<'a>> for CompileContext {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CompileContextRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    line: ::core::convert::TryInto::try_into(value.line()?)?,
                    col: ::core::convert::TryInto::try_into(value.col()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CompileContextRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CompileContextRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CompileContextRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CompileContext>> for CompileContext {
            type Value = ::planus::Offset<CompileContext>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CompileContext>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CompileContextRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CompileContextRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `StringLexError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `StringLexError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:355`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct StringLexError {
            /// The field `context` in the table `StringLexError`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `message` in the table `StringLexError`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for StringLexError {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl StringLexError {
            /// Creates a [StringLexErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> StringLexErrorBuilder<()> {
                StringLexErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<StringLexError>> for StringLexError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StringLexError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<StringLexError>> for StringLexError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StringLexError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<StringLexError> for StringLexError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StringLexError> {
                StringLexError::create(builder, &self.context, &self.message)
            }
        }

        /// Builder for serializing an instance of the [StringLexError] type.
        ///
        /// Can be created using the [StringLexError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct StringLexErrorBuilder<State>(State);

        impl StringLexErrorBuilder<()> {
            /// Setter for the [`context` field](StringLexError#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> StringLexErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                StringLexErrorBuilder((value,))
            }
        }

        impl<T0> StringLexErrorBuilder<(T0,)> {
            /// Setter for the [`message` field](StringLexError#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T1>(self, value: T1) -> StringLexErrorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                StringLexErrorBuilder((v0, value))
            }
        }

        impl<T0, T1> StringLexErrorBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StringLexError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<StringLexError>
            where
                Self: ::planus::WriteAsOffset<StringLexError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<StringLexError>> for StringLexErrorBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<StringLexError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StringLexError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<StringLexError>>
            for StringLexErrorBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<StringLexError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<StringLexError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<StringLexError> for StringLexErrorBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<StringLexError> {
                let (v0, v1) = &self.0;
                StringLexError::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [StringLexError].
        #[derive(Copy, Clone)]
        pub struct StringLexErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> StringLexErrorRef<'a> {
            /// Getter for the [`context` field](StringLexError#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "StringLexError", "context")
            }

            /// Getter for the [`message` field](StringLexError#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "StringLexError", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for StringLexErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("StringLexErrorRef");
                f.field("context", &self.context());
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<StringLexErrorRef<'a>> for StringLexError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: StringLexErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for StringLexErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for StringLexErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[StringLexErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<StringLexError>> for StringLexError {
            type Value = ::planus::Offset<StringLexError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<StringLexError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for StringLexErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[StringLexErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ParseError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ParseError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:360`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ParseError {
            /// The field `error_position` in the table `ParseError`
            pub error_position: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `context` in the table `ParseError`
            pub context: ::planus::alloc::string::String,
            /// The field `end_line` in the table `ParseError`
            pub end_line: u64,
            /// The field `end_col` in the table `ParseError`
            pub end_col: u64,
            /// The field `has_end` in the table `ParseError`
            pub has_end: bool,
            /// The field `message` in the table `ParseError`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ParseError {
            fn default() -> Self {
                Self {
                    error_position: ::core::default::Default::default(),
                    context: ::core::default::Default::default(),
                    end_line: 0,
                    end_col: 0,
                    has_end: false,
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl ParseError {
            /// Creates a [ParseErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ParseErrorBuilder<()> {
                ParseErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error_position: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_context: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_end_line: impl ::planus::WriteAsDefault<u64, u64>,
                field_end_col: impl ::planus::WriteAsDefault<u64, u64>,
                field_has_end: impl ::planus::WriteAsDefault<bool, bool>,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error_position = field_error_position.prepare(builder);
                let prepared_context = field_context.prepare(builder);
                let prepared_end_line = field_end_line.prepare(builder, &0);
                let prepared_end_col = field_end_col.prepare(builder, &0);
                let prepared_has_end = field_has_end.prepare(builder, &false);
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<16> =
                    ::core::default::Default::default();
                if prepared_end_line.is_some() {
                    table_writer.write_entry::<u64>(2);
                }
                if prepared_end_col.is_some() {
                    table_writer.write_entry::<u64>(3);
                }
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);
                table_writer.write_entry::<::planus::Offset<str>>(5);
                if prepared_has_end.is_some() {
                    table_writer.write_entry::<bool>(4);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_end_line) = prepared_end_line {
                            object_writer.write::<_, _, 8>(&prepared_end_line);
                        }
                        if let ::core::option::Option::Some(prepared_end_col) = prepared_end_col {
                            object_writer.write::<_, _, 8>(&prepared_end_col);
                        }
                        object_writer.write::<_, _, 4>(&prepared_error_position);
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_message);
                        if let ::core::option::Option::Some(prepared_has_end) = prepared_has_end {
                            object_writer.write::<_, _, 1>(&prepared_has_end);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ParseError>> for ParseError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ParseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ParseError>> for ParseError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ParseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ParseError> for ParseError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ParseError> {
                ParseError::create(
                    builder,
                    &self.error_position,
                    &self.context,
                    self.end_line,
                    self.end_col,
                    self.has_end,
                    &self.message,
                )
            }
        }

        /// Builder for serializing an instance of the [ParseError] type.
        ///
        /// Can be created using the [ParseError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ParseErrorBuilder<State>(State);

        impl ParseErrorBuilder<()> {
            /// Setter for the [`error_position` field](ParseError#structfield.error_position).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error_position<T0>(self, value: T0) -> ParseErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                ParseErrorBuilder((value,))
            }
        }

        impl<T0> ParseErrorBuilder<(T0,)> {
            /// Setter for the [`context` field](ParseError#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T1>(self, value: T1) -> ParseErrorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                ParseErrorBuilder((v0, value))
            }
        }

        impl<T0, T1> ParseErrorBuilder<(T0, T1)> {
            /// Setter for the [`end_line` field](ParseError#structfield.end_line).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_line<T2>(self, value: T2) -> ParseErrorBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1) = self.0;
                ParseErrorBuilder((v0, v1, value))
            }

            /// Sets the [`end_line` field](ParseError#structfield.end_line) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_line_as_default(
                self,
            ) -> ParseErrorBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.end_line(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> ParseErrorBuilder<(T0, T1, T2)> {
            /// Setter for the [`end_col` field](ParseError#structfield.end_col).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_col<T3>(self, value: T3) -> ParseErrorBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1, v2) = self.0;
                ParseErrorBuilder((v0, v1, v2, value))
            }

            /// Sets the [`end_col` field](ParseError#structfield.end_col) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn end_col_as_default(
                self,
            ) -> ParseErrorBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.end_col(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> ParseErrorBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`has_end` field](ParseError#structfield.has_end).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn has_end<T4>(self, value: T4) -> ParseErrorBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3) = self.0;
                ParseErrorBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`has_end` field](ParseError#structfield.has_end) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn has_end_as_default(
                self,
            ) -> ParseErrorBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.has_end(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> ParseErrorBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`message` field](ParseError#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T5>(self, value: T5) -> ParseErrorBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                ParseErrorBuilder((v0, v1, v2, v3, v4, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5> ParseErrorBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ParseError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ParseError>
            where
                Self: ::planus::WriteAsOffset<ParseError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u64, u64>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<ParseError>>
            for ParseErrorBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            type Prepared = ::planus::Offset<ParseError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ParseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u64, u64>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<ParseError>>
            for ParseErrorBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            type Prepared = ::planus::Offset<ParseError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ParseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u64, u64>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<ParseError> for ParseErrorBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ParseError> {
                let (v0, v1, v2, v3, v4, v5) = &self.0;
                ParseError::create(builder, v0, v1, v2, v3, v4, v5)
            }
        }

        /// Reference to a deserialized [ParseError].
        #[derive(Copy, Clone)]
        pub struct ParseErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ParseErrorRef<'a> {
            /// Getter for the [`error_position` field](ParseError#structfield.error_position).
            #[inline]
            pub fn error_position(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "ParseError", "error_position")
            }

            /// Getter for the [`context` field](ParseError#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "ParseError", "context")
            }

            /// Getter for the [`end_line` field](ParseError#structfield.end_line).
            #[inline]
            pub fn end_line(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(2, "ParseError", "end_line")?.unwrap_or(0))
            }

            /// Getter for the [`end_col` field](ParseError#structfield.end_col).
            #[inline]
            pub fn end_col(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(3, "ParseError", "end_col")?.unwrap_or(0))
            }

            /// Getter for the [`has_end` field](ParseError#structfield.has_end).
            #[inline]
            pub fn has_end(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0.access(4, "ParseError", "has_end")?.unwrap_or(false),
                )
            }

            /// Getter for the [`message` field](ParseError#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(5, "ParseError", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for ParseErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ParseErrorRef");
                f.field("error_position", &self.error_position());
                f.field("context", &self.context());
                f.field("end_line", &self.end_line());
                f.field("end_col", &self.end_col());
                f.field("has_end", &self.has_end());
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ParseErrorRef<'a>> for ParseError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ParseErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error_position: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.error_position()?)?,
                    ),
                    context: ::core::convert::Into::into(value.context()?),
                    end_line: ::core::convert::TryInto::try_into(value.end_line()?)?,
                    end_col: ::core::convert::TryInto::try_into(value.end_col()?)?,
                    has_end: ::core::convert::TryInto::try_into(value.has_end()?)?,
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ParseErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ParseErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ParseErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ParseError>> for ParseError {
            type Value = ::planus::Offset<ParseError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ParseError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ParseErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ParseErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `UnknownBuiltinFunction` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `UnknownBuiltinFunction` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:369`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct UnknownBuiltinFunction {
            /// The field `context` in the table `UnknownBuiltinFunction`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `name` in the table `UnknownBuiltinFunction`
            pub name: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for UnknownBuiltinFunction {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                }
            }
        }

        impl UnknownBuiltinFunction {
            /// Creates a [UnknownBuiltinFunctionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UnknownBuiltinFunctionBuilder<()> {
                UnknownBuiltinFunctionBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_name: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_name = field_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<UnknownBuiltinFunction>> for UnknownBuiltinFunction {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownBuiltinFunction> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<UnknownBuiltinFunction>>
            for UnknownBuiltinFunction
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownBuiltinFunction>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<UnknownBuiltinFunction> for UnknownBuiltinFunction {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownBuiltinFunction> {
                UnknownBuiltinFunction::create(builder, &self.context, &self.name)
            }
        }

        /// Builder for serializing an instance of the [UnknownBuiltinFunction] type.
        ///
        /// Can be created using the [UnknownBuiltinFunction::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UnknownBuiltinFunctionBuilder<State>(State);

        impl UnknownBuiltinFunctionBuilder<()> {
            /// Setter for the [`context` field](UnknownBuiltinFunction#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> UnknownBuiltinFunctionBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                UnknownBuiltinFunctionBuilder((value,))
            }
        }

        impl<T0> UnknownBuiltinFunctionBuilder<(T0,)> {
            /// Setter for the [`name` field](UnknownBuiltinFunction#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T1>(self, value: T1) -> UnknownBuiltinFunctionBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                UnknownBuiltinFunctionBuilder((v0, value))
            }
        }

        impl<T0, T1> UnknownBuiltinFunctionBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UnknownBuiltinFunction].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownBuiltinFunction>
            where
                Self: ::planus::WriteAsOffset<UnknownBuiltinFunction>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<UnknownBuiltinFunction>>
            for UnknownBuiltinFunctionBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownBuiltinFunction>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownBuiltinFunction> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<UnknownBuiltinFunction>>
            for UnknownBuiltinFunctionBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownBuiltinFunction>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownBuiltinFunction>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<UnknownBuiltinFunction>
            for UnknownBuiltinFunctionBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownBuiltinFunction> {
                let (v0, v1) = &self.0;
                UnknownBuiltinFunction::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [UnknownBuiltinFunction].
        #[derive(Copy, Clone)]
        pub struct UnknownBuiltinFunctionRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UnknownBuiltinFunctionRef<'a> {
            /// Getter for the [`context` field](UnknownBuiltinFunction#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0
                    .access_required(0, "UnknownBuiltinFunction", "context")
            }

            /// Getter for the [`name` field](UnknownBuiltinFunction#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "UnknownBuiltinFunction", "name")
            }
        }

        impl<'a> ::core::fmt::Debug for UnknownBuiltinFunctionRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UnknownBuiltinFunctionRef");
                f.field("context", &self.context());
                f.field("name", &self.name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UnknownBuiltinFunctionRef<'a>> for UnknownBuiltinFunction {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UnknownBuiltinFunctionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    name: ::core::convert::Into::into(value.name()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UnknownBuiltinFunctionRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UnknownBuiltinFunctionRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[UnknownBuiltinFunctionRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<UnknownBuiltinFunction>>
            for UnknownBuiltinFunction
        {
            type Value = ::planus::Offset<UnknownBuiltinFunction>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<UnknownBuiltinFunction>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UnknownBuiltinFunctionRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UnknownBuiltinFunctionRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `UnknownTypeConstant` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `UnknownTypeConstant` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:374`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct UnknownTypeConstant {
            /// The field `context` in the table `UnknownTypeConstant`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `name` in the table `UnknownTypeConstant`
            pub name: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for UnknownTypeConstant {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                }
            }
        }

        impl UnknownTypeConstant {
            /// Creates a [UnknownTypeConstantBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UnknownTypeConstantBuilder<()> {
                UnknownTypeConstantBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_name: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_name = field_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<UnknownTypeConstant>> for UnknownTypeConstant {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownTypeConstant> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<UnknownTypeConstant>> for UnknownTypeConstant {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownTypeConstant>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<UnknownTypeConstant> for UnknownTypeConstant {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownTypeConstant> {
                UnknownTypeConstant::create(builder, &self.context, &self.name)
            }
        }

        /// Builder for serializing an instance of the [UnknownTypeConstant] type.
        ///
        /// Can be created using the [UnknownTypeConstant::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UnknownTypeConstantBuilder<State>(State);

        impl UnknownTypeConstantBuilder<()> {
            /// Setter for the [`context` field](UnknownTypeConstant#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> UnknownTypeConstantBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                UnknownTypeConstantBuilder((value,))
            }
        }

        impl<T0> UnknownTypeConstantBuilder<(T0,)> {
            /// Setter for the [`name` field](UnknownTypeConstant#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T1>(self, value: T1) -> UnknownTypeConstantBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                UnknownTypeConstantBuilder((v0, value))
            }
        }

        impl<T0, T1> UnknownTypeConstantBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UnknownTypeConstant].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownTypeConstant>
            where
                Self: ::planus::WriteAsOffset<UnknownTypeConstant>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<UnknownTypeConstant>>
            for UnknownTypeConstantBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownTypeConstant>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownTypeConstant> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<UnknownTypeConstant>>
            for UnknownTypeConstantBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownTypeConstant>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownTypeConstant>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<UnknownTypeConstant> for UnknownTypeConstantBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownTypeConstant> {
                let (v0, v1) = &self.0;
                UnknownTypeConstant::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [UnknownTypeConstant].
        #[derive(Copy, Clone)]
        pub struct UnknownTypeConstantRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UnknownTypeConstantRef<'a> {
            /// Getter for the [`context` field](UnknownTypeConstant#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "UnknownTypeConstant", "context")
            }

            /// Getter for the [`name` field](UnknownTypeConstant#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "UnknownTypeConstant", "name")
            }
        }

        impl<'a> ::core::fmt::Debug for UnknownTypeConstantRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UnknownTypeConstantRef");
                f.field("context", &self.context());
                f.field("name", &self.name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UnknownTypeConstantRef<'a>> for UnknownTypeConstant {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UnknownTypeConstantRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    name: ::core::convert::Into::into(value.name()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UnknownTypeConstantRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UnknownTypeConstantRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[UnknownTypeConstantRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<UnknownTypeConstant>> for UnknownTypeConstant {
            type Value = ::planus::Offset<UnknownTypeConstant>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<UnknownTypeConstant>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UnknownTypeConstantRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UnknownTypeConstantRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `UnknownLoopLabel` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `UnknownLoopLabel` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:379`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct UnknownLoopLabel {
            /// The field `context` in the table `UnknownLoopLabel`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `label` in the table `UnknownLoopLabel`
            pub label: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for UnknownLoopLabel {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    label: ::core::default::Default::default(),
                }
            }
        }

        impl UnknownLoopLabel {
            /// Creates a [UnknownLoopLabelBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> UnknownLoopLabelBuilder<()> {
                UnknownLoopLabelBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_label: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_label = field_label.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_label);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<UnknownLoopLabel>> for UnknownLoopLabel {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownLoopLabel> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<UnknownLoopLabel>> for UnknownLoopLabel {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownLoopLabel>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<UnknownLoopLabel> for UnknownLoopLabel {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownLoopLabel> {
                UnknownLoopLabel::create(builder, &self.context, &self.label)
            }
        }

        /// Builder for serializing an instance of the [UnknownLoopLabel] type.
        ///
        /// Can be created using the [UnknownLoopLabel::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct UnknownLoopLabelBuilder<State>(State);

        impl UnknownLoopLabelBuilder<()> {
            /// Setter for the [`context` field](UnknownLoopLabel#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> UnknownLoopLabelBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                UnknownLoopLabelBuilder((value,))
            }
        }

        impl<T0> UnknownLoopLabelBuilder<(T0,)> {
            /// Setter for the [`label` field](UnknownLoopLabel#structfield.label).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn label<T1>(self, value: T1) -> UnknownLoopLabelBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                UnknownLoopLabelBuilder((v0, value))
            }
        }

        impl<T0, T1> UnknownLoopLabelBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UnknownLoopLabel].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownLoopLabel>
            where
                Self: ::planus::WriteAsOffset<UnknownLoopLabel>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<UnknownLoopLabel>>
            for UnknownLoopLabelBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownLoopLabel>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownLoopLabel> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<UnknownLoopLabel>>
            for UnknownLoopLabelBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<UnknownLoopLabel>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<UnknownLoopLabel>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<UnknownLoopLabel> for UnknownLoopLabelBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<UnknownLoopLabel> {
                let (v0, v1) = &self.0;
                UnknownLoopLabel::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [UnknownLoopLabel].
        #[derive(Copy, Clone)]
        pub struct UnknownLoopLabelRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> UnknownLoopLabelRef<'a> {
            /// Getter for the [`context` field](UnknownLoopLabel#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "UnknownLoopLabel", "context")
            }

            /// Getter for the [`label` field](UnknownLoopLabel#structfield.label).
            #[inline]
            pub fn label(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "UnknownLoopLabel", "label")
            }
        }

        impl<'a> ::core::fmt::Debug for UnknownLoopLabelRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("UnknownLoopLabelRef");
                f.field("context", &self.context());
                f.field("label", &self.label());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<UnknownLoopLabelRef<'a>> for UnknownLoopLabel {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: UnknownLoopLabelRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    label: ::core::convert::Into::into(value.label()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for UnknownLoopLabelRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for UnknownLoopLabelRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[UnknownLoopLabelRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<UnknownLoopLabel>> for UnknownLoopLabel {
            type Value = ::planus::Offset<UnknownLoopLabel>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<UnknownLoopLabel>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for UnknownLoopLabelRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[UnknownLoopLabelRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DuplicateVariable` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DuplicateVariable` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:384`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DuplicateVariable {
            /// The field `context` in the table `DuplicateVariable`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `var_name` in the table `DuplicateVariable`
            pub var_name: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DuplicateVariable {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    var_name: ::core::default::Default::default(),
                }
            }
        }

        impl DuplicateVariable {
            /// Creates a [DuplicateVariableBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DuplicateVariableBuilder<()> {
                DuplicateVariableBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_var_name: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_var_name = field_var_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_var_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DuplicateVariable>> for DuplicateVariable {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicateVariable> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DuplicateVariable>> for DuplicateVariable {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicateVariable>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DuplicateVariable> for DuplicateVariable {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicateVariable> {
                DuplicateVariable::create(builder, &self.context, &self.var_name)
            }
        }

        /// Builder for serializing an instance of the [DuplicateVariable] type.
        ///
        /// Can be created using the [DuplicateVariable::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DuplicateVariableBuilder<State>(State);

        impl DuplicateVariableBuilder<()> {
            /// Setter for the [`context` field](DuplicateVariable#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> DuplicateVariableBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                DuplicateVariableBuilder((value,))
            }
        }

        impl<T0> DuplicateVariableBuilder<(T0,)> {
            /// Setter for the [`var_name` field](DuplicateVariable#structfield.var_name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn var_name<T1>(self, value: T1) -> DuplicateVariableBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                DuplicateVariableBuilder((v0, value))
            }
        }

        impl<T0, T1> DuplicateVariableBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DuplicateVariable].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicateVariable>
            where
                Self: ::planus::WriteAsOffset<DuplicateVariable>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<DuplicateVariable>>
            for DuplicateVariableBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicateVariable>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicateVariable> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<DuplicateVariable>>
            for DuplicateVariableBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicateVariable>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicateVariable>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<DuplicateVariable> for DuplicateVariableBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicateVariable> {
                let (v0, v1) = &self.0;
                DuplicateVariable::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [DuplicateVariable].
        #[derive(Copy, Clone)]
        pub struct DuplicateVariableRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DuplicateVariableRef<'a> {
            /// Getter for the [`context` field](DuplicateVariable#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "DuplicateVariable", "context")
            }

            /// Getter for the [`var_name` field](DuplicateVariable#structfield.var_name).
            #[inline]
            pub fn var_name(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(1, "DuplicateVariable", "var_name")
            }
        }

        impl<'a> ::core::fmt::Debug for DuplicateVariableRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DuplicateVariableRef");
                f.field("context", &self.context());
                f.field("var_name", &self.var_name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DuplicateVariableRef<'a>> for DuplicateVariable {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DuplicateVariableRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    var_name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.var_name()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DuplicateVariableRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DuplicateVariableRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DuplicateVariableRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DuplicateVariable>> for DuplicateVariable {
            type Value = ::planus::Offset<DuplicateVariable>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DuplicateVariable>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DuplicateVariableRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DuplicateVariableRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `AssignToConst` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `AssignToConst` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:389`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct AssignToConst {
            /// The field `context` in the table `AssignToConst`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `var_name` in the table `AssignToConst`
            pub var_name: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for AssignToConst {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    var_name: ::core::default::Default::default(),
                }
            }
        }

        impl AssignToConst {
            /// Creates a [AssignToConstBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AssignToConstBuilder<()> {
                AssignToConstBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_var_name: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_var_name = field_var_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_var_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<AssignToConst>> for AssignToConst {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AssignToConst> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<AssignToConst>> for AssignToConst {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AssignToConst>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<AssignToConst> for AssignToConst {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AssignToConst> {
                AssignToConst::create(builder, &self.context, &self.var_name)
            }
        }

        /// Builder for serializing an instance of the [AssignToConst] type.
        ///
        /// Can be created using the [AssignToConst::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AssignToConstBuilder<State>(State);

        impl AssignToConstBuilder<()> {
            /// Setter for the [`context` field](AssignToConst#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> AssignToConstBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                AssignToConstBuilder((value,))
            }
        }

        impl<T0> AssignToConstBuilder<(T0,)> {
            /// Setter for the [`var_name` field](AssignToConst#structfield.var_name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn var_name<T1>(self, value: T1) -> AssignToConstBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                AssignToConstBuilder((v0, value))
            }
        }

        impl<T0, T1> AssignToConstBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AssignToConst].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<AssignToConst>
            where
                Self: ::planus::WriteAsOffset<AssignToConst>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<AssignToConst>> for AssignToConstBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<AssignToConst>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AssignToConst> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<AssignToConst>>
            for AssignToConstBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<AssignToConst>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AssignToConst>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<AssignToConst> for AssignToConstBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AssignToConst> {
                let (v0, v1) = &self.0;
                AssignToConst::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [AssignToConst].
        #[derive(Copy, Clone)]
        pub struct AssignToConstRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AssignToConstRef<'a> {
            /// Getter for the [`context` field](AssignToConst#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "AssignToConst", "context")
            }

            /// Getter for the [`var_name` field](AssignToConst#structfield.var_name).
            #[inline]
            pub fn var_name(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(1, "AssignToConst", "var_name")
            }
        }

        impl<'a> ::core::fmt::Debug for AssignToConstRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AssignToConstRef");
                f.field("context", &self.context());
                f.field("var_name", &self.var_name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AssignToConstRef<'a>> for AssignToConst {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AssignToConstRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    var_name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.var_name()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AssignToConstRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AssignToConstRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[AssignToConstRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<AssignToConst>> for AssignToConst {
            type Value = ::planus::Offset<AssignToConst>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<AssignToConst>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AssignToConstRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AssignToConstRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DisabledFeature` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DisabledFeature` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:394`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DisabledFeature {
            /// The field `context` in the table `DisabledFeature`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `feature` in the table `DisabledFeature`
            pub feature: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DisabledFeature {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    feature: ::core::default::Default::default(),
                }
            }
        }

        impl DisabledFeature {
            /// Creates a [DisabledFeatureBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DisabledFeatureBuilder<()> {
                DisabledFeatureBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_feature: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_feature = field_feature.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_feature);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DisabledFeature>> for DisabledFeature {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisabledFeature> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DisabledFeature>> for DisabledFeature {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DisabledFeature>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DisabledFeature> for DisabledFeature {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisabledFeature> {
                DisabledFeature::create(builder, &self.context, &self.feature)
            }
        }

        /// Builder for serializing an instance of the [DisabledFeature] type.
        ///
        /// Can be created using the [DisabledFeature::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DisabledFeatureBuilder<State>(State);

        impl DisabledFeatureBuilder<()> {
            /// Setter for the [`context` field](DisabledFeature#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> DisabledFeatureBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                DisabledFeatureBuilder((value,))
            }
        }

        impl<T0> DisabledFeatureBuilder<(T0,)> {
            /// Setter for the [`feature` field](DisabledFeature#structfield.feature).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn feature<T1>(self, value: T1) -> DisabledFeatureBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                DisabledFeatureBuilder((v0, value))
            }
        }

        impl<T0, T1> DisabledFeatureBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DisabledFeature].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisabledFeature>
            where
                Self: ::planus::WriteAsOffset<DisabledFeature>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<DisabledFeature>>
            for DisabledFeatureBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DisabledFeature>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisabledFeature> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<DisabledFeature>>
            for DisabledFeatureBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DisabledFeature>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DisabledFeature>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<DisabledFeature> for DisabledFeatureBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisabledFeature> {
                let (v0, v1) = &self.0;
                DisabledFeature::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [DisabledFeature].
        #[derive(Copy, Clone)]
        pub struct DisabledFeatureRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DisabledFeatureRef<'a> {
            /// Getter for the [`context` field](DisabledFeature#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "DisabledFeature", "context")
            }

            /// Getter for the [`feature` field](DisabledFeature#structfield.feature).
            #[inline]
            pub fn feature(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "DisabledFeature", "feature")
            }
        }

        impl<'a> ::core::fmt::Debug for DisabledFeatureRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DisabledFeatureRef");
                f.field("context", &self.context());
                f.field("feature", &self.feature());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DisabledFeatureRef<'a>> for DisabledFeature {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DisabledFeatureRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    feature: ::core::convert::Into::into(value.feature()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DisabledFeatureRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DisabledFeatureRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DisabledFeatureRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DisabledFeature>> for DisabledFeature {
            type Value = ::planus::Offset<DisabledFeature>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DisabledFeature>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DisabledFeatureRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DisabledFeatureRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `BadSlotName` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `BadSlotName` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:399`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct BadSlotName {
            /// The field `context` in the table `BadSlotName`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
            /// The field `slot` in the table `BadSlotName`
            pub slot: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for BadSlotName {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                    slot: ::core::default::Default::default(),
                }
            }
        }

        impl BadSlotName {
            /// Creates a [BadSlotNameBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> BadSlotNameBuilder<()> {
                BadSlotNameBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
                field_slot: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);
                let prepared_slot = field_slot.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                        object_writer.write::<_, _, 4>(&prepared_slot);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<BadSlotName>> for BadSlotName {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BadSlotName> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<BadSlotName>> for BadSlotName {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<BadSlotName>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<BadSlotName> for BadSlotName {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BadSlotName> {
                BadSlotName::create(builder, &self.context, &self.slot)
            }
        }

        /// Builder for serializing an instance of the [BadSlotName] type.
        ///
        /// Can be created using the [BadSlotName::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct BadSlotNameBuilder<State>(State);

        impl BadSlotNameBuilder<()> {
            /// Setter for the [`context` field](BadSlotName#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> BadSlotNameBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                BadSlotNameBuilder((value,))
            }
        }

        impl<T0> BadSlotNameBuilder<(T0,)> {
            /// Setter for the [`slot` field](BadSlotName#structfield.slot).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn slot<T1>(self, value: T1) -> BadSlotNameBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                BadSlotNameBuilder((v0, value))
            }
        }

        impl<T0, T1> BadSlotNameBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BadSlotName].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<BadSlotName>
            where
                Self: ::planus::WriteAsOffset<BadSlotName>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<BadSlotName>> for BadSlotNameBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<BadSlotName>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BadSlotName> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<BadSlotName>>
            for BadSlotNameBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<BadSlotName>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<BadSlotName>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<BadSlotName> for BadSlotNameBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BadSlotName> {
                let (v0, v1) = &self.0;
                BadSlotName::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [BadSlotName].
        #[derive(Copy, Clone)]
        pub struct BadSlotNameRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> BadSlotNameRef<'a> {
            /// Getter for the [`context` field](BadSlotName#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "BadSlotName", "context")
            }

            /// Getter for the [`slot` field](BadSlotName#structfield.slot).
            #[inline]
            pub fn slot(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "BadSlotName", "slot")
            }
        }

        impl<'a> ::core::fmt::Debug for BadSlotNameRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("BadSlotNameRef");
                f.field("context", &self.context());
                f.field("slot", &self.slot());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<BadSlotNameRef<'a>> for BadSlotName {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: BadSlotNameRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                    slot: ::core::convert::Into::into(value.slot()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for BadSlotNameRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for BadSlotNameRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[BadSlotNameRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<BadSlotName>> for BadSlotName {
            type Value = ::planus::Offset<BadSlotName>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<BadSlotName>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for BadSlotNameRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[BadSlotNameRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `InvalidAssignment` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `InvalidAssignment` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:404`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct InvalidAssignment {
            /// The field `context` in the table `InvalidAssignment`
            pub context: ::planus::alloc::boxed::Box<self::CompileContext>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for InvalidAssignment {
            fn default() -> Self {
                Self {
                    context: ::core::default::Default::default(),
                }
            }
        }

        impl InvalidAssignment {
            /// Creates a [InvalidAssignmentBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> InvalidAssignmentBuilder<()> {
                InvalidAssignmentBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_context: impl ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            ) -> ::planus::Offset<Self> {
                let prepared_context = field_context.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileContext>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_context);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<InvalidAssignment>> for InvalidAssignment {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidAssignment> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<InvalidAssignment>> for InvalidAssignment {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidAssignment>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<InvalidAssignment> for InvalidAssignment {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidAssignment> {
                InvalidAssignment::create(builder, &self.context)
            }
        }

        /// Builder for serializing an instance of the [InvalidAssignment] type.
        ///
        /// Can be created using the [InvalidAssignment::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct InvalidAssignmentBuilder<State>(State);

        impl InvalidAssignmentBuilder<()> {
            /// Setter for the [`context` field](InvalidAssignment#structfield.context).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn context<T0>(self, value: T0) -> InvalidAssignmentBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>,
            {
                InvalidAssignmentBuilder((value,))
            }
        }

        impl<T0> InvalidAssignmentBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [InvalidAssignment].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidAssignment>
            where
                Self: ::planus::WriteAsOffset<InvalidAssignment>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>>
            ::planus::WriteAs<::planus::Offset<InvalidAssignment>>
            for InvalidAssignmentBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidAssignment>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidAssignment> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>>
            ::planus::WriteAsOptional<::planus::Offset<InvalidAssignment>>
            for InvalidAssignmentBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidAssignment>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidAssignment>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::CompileContext>>>
            ::planus::WriteAsOffset<InvalidAssignment> for InvalidAssignmentBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidAssignment> {
                let (v0,) = &self.0;
                InvalidAssignment::create(builder, v0)
            }
        }

        /// Reference to a deserialized [InvalidAssignment].
        #[derive(Copy, Clone)]
        pub struct InvalidAssignmentRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> InvalidAssignmentRef<'a> {
            /// Getter for the [`context` field](InvalidAssignment#structfield.context).
            #[inline]
            pub fn context(&self) -> ::planus::Result<self::CompileContextRef<'a>> {
                self.0.access_required(0, "InvalidAssignment", "context")
            }
        }

        impl<'a> ::core::fmt::Debug for InvalidAssignmentRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("InvalidAssignmentRef");
                f.field("context", &self.context());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<InvalidAssignmentRef<'a>> for InvalidAssignment {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: InvalidAssignmentRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    context: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.context()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for InvalidAssignmentRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for InvalidAssignmentRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[InvalidAssignmentRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<InvalidAssignment>> for InvalidAssignment {
            type Value = ::planus::Offset<InvalidAssignment>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<InvalidAssignment>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for InvalidAssignmentRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[InvalidAssignmentRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `CompileErrorUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `CompileErrorUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:408`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum CompileErrorUnion {
            /// The variant of type `StringLexError` in the union `CompileErrorUnion`
            StringLexError(::planus::alloc::boxed::Box<self::StringLexError>),

            /// The variant of type `ParseError` in the union `CompileErrorUnion`
            ParseError(::planus::alloc::boxed::Box<self::ParseError>),

            /// The variant of type `UnknownBuiltinFunction` in the union `CompileErrorUnion`
            UnknownBuiltinFunction(::planus::alloc::boxed::Box<self::UnknownBuiltinFunction>),

            /// The variant of type `UnknownTypeConstant` in the union `CompileErrorUnion`
            UnknownTypeConstant(::planus::alloc::boxed::Box<self::UnknownTypeConstant>),

            /// The variant of type `UnknownLoopLabel` in the union `CompileErrorUnion`
            UnknownLoopLabel(::planus::alloc::boxed::Box<self::UnknownLoopLabel>),

            /// The variant of type `DuplicateVariable` in the union `CompileErrorUnion`
            DuplicateVariable(::planus::alloc::boxed::Box<self::DuplicateVariable>),

            /// The variant of type `AssignToConst` in the union `CompileErrorUnion`
            AssignToConst(::planus::alloc::boxed::Box<self::AssignToConst>),

            /// The variant of type `DisabledFeature` in the union `CompileErrorUnion`
            DisabledFeature(::planus::alloc::boxed::Box<self::DisabledFeature>),

            /// The variant of type `BadSlotName` in the union `CompileErrorUnion`
            BadSlotName(::planus::alloc::boxed::Box<self::BadSlotName>),

            /// The variant of type `InvalidAssignment` in the union `CompileErrorUnion`
            InvalidAssignment(::planus::alloc::boxed::Box<self::InvalidAssignment>),
        }

        impl CompileErrorUnion {
            /// Creates a [CompileErrorUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CompileErrorUnionBuilder<::planus::Uninitialized> {
                CompileErrorUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_string_lex_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::StringLexError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_parse_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ParseError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_unknown_builtin_function(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::UnknownBuiltinFunction>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_unknown_type_constant(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::UnknownTypeConstant>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_unknown_loop_label(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::UnknownLoopLabel>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_duplicate_variable(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DuplicateVariable>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_assign_to_const(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::AssignToConst>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_disabled_feature(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DisabledFeature>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_bad_slot_name(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::BadSlotName>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_invalid_assignment(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::InvalidAssignment>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<CompileErrorUnion> for CompileErrorUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::StringLexError(value) => Self::create_string_lex_error(builder, value),
                    Self::ParseError(value) => Self::create_parse_error(builder, value),
                    Self::UnknownBuiltinFunction(value) => {
                        Self::create_unknown_builtin_function(builder, value)
                    }
                    Self::UnknownTypeConstant(value) => {
                        Self::create_unknown_type_constant(builder, value)
                    }
                    Self::UnknownLoopLabel(value) => {
                        Self::create_unknown_loop_label(builder, value)
                    }
                    Self::DuplicateVariable(value) => {
                        Self::create_duplicate_variable(builder, value)
                    }
                    Self::AssignToConst(value) => Self::create_assign_to_const(builder, value),
                    Self::DisabledFeature(value) => Self::create_disabled_feature(builder, value),
                    Self::BadSlotName(value) => Self::create_bad_slot_name(builder, value),
                    Self::InvalidAssignment(value) => {
                        Self::create_invalid_assignment(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<CompileErrorUnion> for CompileErrorUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [CompileErrorUnion] type.
        ///
        /// Can be created using the [CompileErrorUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CompileErrorUnionBuilder<T>(T);

        impl CompileErrorUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`StringLexError` variant](CompileErrorUnion#variant.StringLexError).
            #[inline]
            pub fn string_lex_error<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::StringLexError>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ParseError` variant](CompileErrorUnion#variant.ParseError).
            #[inline]
            pub fn parse_error<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::ParseError>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`UnknownBuiltinFunction` variant](CompileErrorUnion#variant.UnknownBuiltinFunction).
            #[inline]
            pub fn unknown_builtin_function<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::UnknownBuiltinFunction>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`UnknownTypeConstant` variant](CompileErrorUnion#variant.UnknownTypeConstant).
            #[inline]
            pub fn unknown_type_constant<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::UnknownTypeConstant>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`UnknownLoopLabel` variant](CompileErrorUnion#variant.UnknownLoopLabel).
            #[inline]
            pub fn unknown_loop_label<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::UnknownLoopLabel>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DuplicateVariable` variant](CompileErrorUnion#variant.DuplicateVariable).
            #[inline]
            pub fn duplicate_variable<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::DuplicateVariable>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`AssignToConst` variant](CompileErrorUnion#variant.AssignToConst).
            #[inline]
            pub fn assign_to_const<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<self::AssignToConst>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DisabledFeature` variant](CompileErrorUnion#variant.DisabledFeature).
            #[inline]
            pub fn disabled_feature<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<self::DisabledFeature>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`BadSlotName` variant](CompileErrorUnion#variant.BadSlotName).
            #[inline]
            pub fn bad_slot_name<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<self::BadSlotName>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`InvalidAssignment` variant](CompileErrorUnion#variant.InvalidAssignment).
            #[inline]
            pub fn invalid_assignment<T>(
                self,
                value: T,
            ) -> CompileErrorUnionBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<self::InvalidAssignment>,
            {
                CompileErrorUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> CompileErrorUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [CompileErrorUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion>
            where
                Self: ::planus::WriteAsUnion<CompileErrorUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::StringLexError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::StringLexError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ParseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ParseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownBuiltinFunction>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownBuiltinFunction>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownTypeConstant>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownTypeConstant>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownLoopLabel>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::UnknownLoopLabel>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicateVariable>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicateVariable>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::AssignToConst>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::AssignToConst>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::DisabledFeature>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::DisabledFeature>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::BadSlotName>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::BadSlotName>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidAssignment>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<CompileErrorUnion> {
                ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<CompileErrorUnion>
            for CompileErrorUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidAssignment>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<CompileErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [CompileErrorUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum CompileErrorUnionRef<'a> {
            StringLexError(self::StringLexErrorRef<'a>),
            ParseError(self::ParseErrorRef<'a>),
            UnknownBuiltinFunction(self::UnknownBuiltinFunctionRef<'a>),
            UnknownTypeConstant(self::UnknownTypeConstantRef<'a>),
            UnknownLoopLabel(self::UnknownLoopLabelRef<'a>),
            DuplicateVariable(self::DuplicateVariableRef<'a>),
            AssignToConst(self::AssignToConstRef<'a>),
            DisabledFeature(self::DisabledFeatureRef<'a>),
            BadSlotName(self::BadSlotNameRef<'a>),
            InvalidAssignment(self::InvalidAssignmentRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<CompileErrorUnionRef<'a>> for CompileErrorUnion {
            type Error = ::planus::Error;

            fn try_from(value: CompileErrorUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    CompileErrorUnionRef::StringLexError(value) => {
                        Self::StringLexError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::ParseError(value) => {
                        Self::ParseError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::UnknownBuiltinFunction(value) => {
                        Self::UnknownBuiltinFunction(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::UnknownTypeConstant(value) => {
                        Self::UnknownTypeConstant(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::UnknownLoopLabel(value) => {
                        Self::UnknownLoopLabel(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::DuplicateVariable(value) => {
                        Self::DuplicateVariable(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::AssignToConst(value) => {
                        Self::AssignToConst(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::DisabledFeature(value) => {
                        Self::DisabledFeature(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::BadSlotName(value) => {
                        Self::BadSlotName(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    CompileErrorUnionRef::InvalidAssignment(value) => {
                        Self::InvalidAssignment(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for CompileErrorUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::StringLexError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::ParseError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::UnknownBuiltinFunction(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::UnknownTypeConstant(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::UnknownLoopLabel(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    6 => ::core::result::Result::Ok(Self::DuplicateVariable(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    7 => ::core::result::Result::Ok(Self::AssignToConst(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    8 => ::core::result::Result::Ok(Self::DisabledFeature(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    9 => ::core::result::Result::Ok(Self::BadSlotName(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    10 => ::core::result::Result::Ok(Self::InvalidAssignment(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for CompileErrorUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[CompileErrorUnionRef]";
        }

        /// The table `CompileError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `CompileError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:421`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CompileError {
            /// The field `error` in the table `CompileError`
            pub error: self::CompileErrorUnion,
        }

        impl CompileError {
            /// Creates a [CompileErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CompileErrorBuilder<()> {
                CompileErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAsUnion<self::CompileErrorUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::CompileErrorUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error.offset());
                        object_writer.write::<_, _, 1>(&prepared_error.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CompileError>> for CompileError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CompileError>> for CompileError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CompileError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CompileError> for CompileError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileError> {
                CompileError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [CompileError] type.
        ///
        /// Can be created using the [CompileError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CompileErrorBuilder<State>(State);

        impl CompileErrorBuilder<()> {
            /// Setter for the [`error` field](CompileError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> CompileErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::CompileErrorUnion>,
            {
                CompileErrorBuilder((value,))
            }
        }

        impl<T0> CompileErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CompileError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileError>
            where
                Self: ::planus::WriteAsOffset<CompileError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::CompileErrorUnion>>
            ::planus::WriteAs<::planus::Offset<CompileError>> for CompileErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CompileError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::CompileErrorUnion>>
            ::planus::WriteAsOptional<::planus::Offset<CompileError>>
            for CompileErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CompileError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CompileError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::CompileErrorUnion>>
            ::planus::WriteAsOffset<CompileError> for CompileErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CompileError> {
                let (v0,) = &self.0;
                CompileError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [CompileError].
        #[derive(Copy, Clone)]
        pub struct CompileErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CompileErrorRef<'a> {
            /// Getter for the [`error` field](CompileError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::CompileErrorUnionRef<'a>> {
                self.0.access_union_required(0, "CompileError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for CompileErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CompileErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CompileErrorRef<'a>> for CompileError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CompileErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::core::convert::TryInto::try_into(value.error()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CompileErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CompileErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CompileErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CompileError>> for CompileError {
            type Value = ::planus::Offset<CompileError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CompileError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CompileErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CompileErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `WorldStateErrorUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `WorldStateErrorUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:429`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum WorldStateErrorUnion {
            /// The variant of type `ObjectNotFound` in the union `WorldStateErrorUnion`
            ObjectNotFound(::planus::alloc::boxed::Box<self::ObjectNotFound>),

            /// The variant of type `ObjectAlreadyExists` in the union `WorldStateErrorUnion`
            ObjectAlreadyExists(::planus::alloc::boxed::Box<self::ObjectAlreadyExists>),

            /// The variant of type `RecursiveMove` in the union `WorldStateErrorUnion`
            RecursiveMove(::planus::alloc::boxed::Box<self::RecursiveMove>),

            /// The variant of type `ObjectPermissionDenied` in the union `WorldStateErrorUnion`
            ObjectPermissionDenied(::planus::alloc::boxed::Box<self::ObjectPermissionDenied>),

            /// The variant of type `PropertyNotFound` in the union `WorldStateErrorUnion`
            PropertyNotFound(::planus::alloc::boxed::Box<self::PropertyNotFound>),

            /// The variant of type `PropertyPermissionDenied` in the union `WorldStateErrorUnion`
            PropertyPermissionDenied(::planus::alloc::boxed::Box<self::PropertyPermissionDenied>),

            /// The variant of type `PropertyDefinitionNotFound` in the union `WorldStateErrorUnion`
            PropertyDefinitionNotFound(
                ::planus::alloc::boxed::Box<self::PropertyDefinitionNotFound>,
            ),

            /// The variant of type `DuplicatePropertyDefinition` in the union `WorldStateErrorUnion`
            DuplicatePropertyDefinition(
                ::planus::alloc::boxed::Box<self::DuplicatePropertyDefinition>,
            ),

            /// The variant of type `ChparentPropertyNameConflict` in the union `WorldStateErrorUnion`
            ChparentPropertyNameConflict(
                ::planus::alloc::boxed::Box<self::ChparentPropertyNameConflict>,
            ),

            /// The variant of type `PropertyTypeMismatch` in the union `WorldStateErrorUnion`
            PropertyTypeMismatch(::planus::alloc::boxed::Box<self::PropertyTypeMismatch>),

            /// The variant of type `VerbNotFound` in the union `WorldStateErrorUnion`
            VerbNotFound(::planus::alloc::boxed::Box<self::VerbNotFound>),

            /// The variant of type `InvalidVerb` in the union `WorldStateErrorUnion`
            InvalidVerb(::planus::alloc::boxed::Box<self::InvalidVerb>),

            /// The variant of type `VerbDecodeError` in the union `WorldStateErrorUnion`
            VerbDecodeError(::planus::alloc::boxed::Box<self::VerbDecodeError>),

            /// The variant of type `VerbPermissionDenied` in the union `WorldStateErrorUnion`
            VerbPermissionDenied(::planus::alloc::boxed::Box<self::VerbPermissionDenied>),

            /// The variant of type `DuplicateVerb` in the union `WorldStateErrorUnion`
            DuplicateVerb(::planus::alloc::boxed::Box<self::DuplicateVerb>),

            /// The variant of type `FailedMatch` in the union `WorldStateErrorUnion`
            FailedMatch(::planus::alloc::boxed::Box<self::FailedMatch>),

            /// The variant of type `AmbiguousMatch` in the union `WorldStateErrorUnion`
            AmbiguousMatch(::planus::alloc::boxed::Box<self::AmbiguousMatch>),

            /// The variant of type `InvalidRenumber` in the union `WorldStateErrorUnion`
            InvalidRenumber(::planus::alloc::boxed::Box<self::InvalidRenumber>),

            /// The variant of type `WorldStateDatabaseError` in the union `WorldStateErrorUnion`
            WorldStateDatabaseError(::planus::alloc::boxed::Box<self::WorldStateDatabaseError>),

            /// The variant of type `RollbackRetry` in the union `WorldStateErrorUnion`
            RollbackRetry(::planus::alloc::boxed::Box<self::RollbackRetry>),
        }

        impl WorldStateErrorUnion {
            /// Creates a [WorldStateErrorUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorldStateErrorUnionBuilder<::planus::Uninitialized> {
                WorldStateErrorUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_object_not_found(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectNotFound>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_object_already_exists(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectAlreadyExists>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_recursive_move(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RecursiveMove>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_object_permission_denied(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectPermissionDenied>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_property_not_found(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertyNotFound>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_property_permission_denied(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertyPermissionDenied>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_property_definition_not_found(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertyDefinitionNotFound>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_duplicate_property_definition(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DuplicatePropertyDefinition>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_chparent_property_name_conflict(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ChparentPropertyNameConflict>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_property_type_mismatch(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertyTypeMismatch>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_not_found(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbNotFound>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_invalid_verb(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::InvalidVerb>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_decode_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbDecodeError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_permission_denied(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbPermissionDenied>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(14, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_duplicate_verb(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DuplicateVerb>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(15, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_failed_match(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::FailedMatch>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(16, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_ambiguous_match(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::AmbiguousMatch>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(17, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_invalid_renumber(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::InvalidRenumber>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(18, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_world_state_database_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorldStateDatabaseError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(19, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_rollback_retry(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RollbackRetry>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(20, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<WorldStateErrorUnion> for WorldStateErrorUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::ObjectNotFound(value) => Self::create_object_not_found(builder, value),
                    Self::ObjectAlreadyExists(value) => {
                        Self::create_object_already_exists(builder, value)
                    }
                    Self::RecursiveMove(value) => Self::create_recursive_move(builder, value),
                    Self::ObjectPermissionDenied(value) => {
                        Self::create_object_permission_denied(builder, value)
                    }
                    Self::PropertyNotFound(value) => {
                        Self::create_property_not_found(builder, value)
                    }
                    Self::PropertyPermissionDenied(value) => {
                        Self::create_property_permission_denied(builder, value)
                    }
                    Self::PropertyDefinitionNotFound(value) => {
                        Self::create_property_definition_not_found(builder, value)
                    }
                    Self::DuplicatePropertyDefinition(value) => {
                        Self::create_duplicate_property_definition(builder, value)
                    }
                    Self::ChparentPropertyNameConflict(value) => {
                        Self::create_chparent_property_name_conflict(builder, value)
                    }
                    Self::PropertyTypeMismatch(value) => {
                        Self::create_property_type_mismatch(builder, value)
                    }
                    Self::VerbNotFound(value) => Self::create_verb_not_found(builder, value),
                    Self::InvalidVerb(value) => Self::create_invalid_verb(builder, value),
                    Self::VerbDecodeError(value) => Self::create_verb_decode_error(builder, value),
                    Self::VerbPermissionDenied(value) => {
                        Self::create_verb_permission_denied(builder, value)
                    }
                    Self::DuplicateVerb(value) => Self::create_duplicate_verb(builder, value),
                    Self::FailedMatch(value) => Self::create_failed_match(builder, value),
                    Self::AmbiguousMatch(value) => Self::create_ambiguous_match(builder, value),
                    Self::InvalidRenumber(value) => Self::create_invalid_renumber(builder, value),
                    Self::WorldStateDatabaseError(value) => {
                        Self::create_world_state_database_error(builder, value)
                    }
                    Self::RollbackRetry(value) => Self::create_rollback_retry(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<WorldStateErrorUnion> for WorldStateErrorUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [WorldStateErrorUnion] type.
        ///
        /// Can be created using the [WorldStateErrorUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorldStateErrorUnionBuilder<T>(T);

        impl WorldStateErrorUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`ObjectNotFound` variant](WorldStateErrorUnion#variant.ObjectNotFound).
            #[inline]
            pub fn object_not_found<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectNotFound>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ObjectAlreadyExists` variant](WorldStateErrorUnion#variant.ObjectAlreadyExists).
            #[inline]
            pub fn object_already_exists<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectAlreadyExists>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RecursiveMove` variant](WorldStateErrorUnion#variant.RecursiveMove).
            #[inline]
            pub fn recursive_move<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::RecursiveMove>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ObjectPermissionDenied` variant](WorldStateErrorUnion#variant.ObjectPermissionDenied).
            #[inline]
            pub fn object_permission_denied<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectPermissionDenied>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertyNotFound` variant](WorldStateErrorUnion#variant.PropertyNotFound).
            #[inline]
            pub fn property_not_found<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertyNotFound>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertyPermissionDenied` variant](WorldStateErrorUnion#variant.PropertyPermissionDenied).
            #[inline]
            pub fn property_permission_denied<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertyPermissionDenied>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertyDefinitionNotFound` variant](WorldStateErrorUnion#variant.PropertyDefinitionNotFound).
            #[inline]
            pub fn property_definition_not_found<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertyDefinitionNotFound>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DuplicatePropertyDefinition` variant](WorldStateErrorUnion#variant.DuplicatePropertyDefinition).
            #[inline]
            pub fn duplicate_property_definition<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<self::DuplicatePropertyDefinition>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ChparentPropertyNameConflict` variant](WorldStateErrorUnion#variant.ChparentPropertyNameConflict).
            #[inline]
            pub fn chparent_property_name_conflict<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<self::ChparentPropertyNameConflict>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertyTypeMismatch` variant](WorldStateErrorUnion#variant.PropertyTypeMismatch).
            #[inline]
            pub fn property_type_mismatch<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertyTypeMismatch>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbNotFound` variant](WorldStateErrorUnion#variant.VerbNotFound).
            #[inline]
            pub fn verb_not_found<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbNotFound>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`InvalidVerb` variant](WorldStateErrorUnion#variant.InvalidVerb).
            #[inline]
            pub fn invalid_verb<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<self::InvalidVerb>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbDecodeError` variant](WorldStateErrorUnion#variant.VerbDecodeError).
            #[inline]
            pub fn verb_decode_error<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbDecodeError>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbPermissionDenied` variant](WorldStateErrorUnion#variant.VerbPermissionDenied).
            #[inline]
            pub fn verb_permission_denied<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbPermissionDenied>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DuplicateVerb` variant](WorldStateErrorUnion#variant.DuplicateVerb).
            #[inline]
            pub fn duplicate_verb<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<self::DuplicateVerb>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`FailedMatch` variant](WorldStateErrorUnion#variant.FailedMatch).
            #[inline]
            pub fn failed_match<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<16, T>>
            where
                T: ::planus::WriteAsOffset<self::FailedMatch>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`AmbiguousMatch` variant](WorldStateErrorUnion#variant.AmbiguousMatch).
            #[inline]
            pub fn ambiguous_match<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<17, T>>
            where
                T: ::planus::WriteAsOffset<self::AmbiguousMatch>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`InvalidRenumber` variant](WorldStateErrorUnion#variant.InvalidRenumber).
            #[inline]
            pub fn invalid_renumber<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<18, T>>
            where
                T: ::planus::WriteAsOffset<self::InvalidRenumber>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorldStateDatabaseError` variant](WorldStateErrorUnion#variant.WorldStateDatabaseError).
            #[inline]
            pub fn world_state_database_error<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<19, T>>
            where
                T: ::planus::WriteAsOffset<self::WorldStateDatabaseError>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RollbackRetry` variant](WorldStateErrorUnion#variant.RollbackRetry).
            #[inline]
            pub fn rollback_retry<T>(
                self,
                value: T,
            ) -> WorldStateErrorUnionBuilder<::planus::Initialized<20, T>>
            where
                T: ::planus::WriteAsOffset<self::RollbackRetry>,
            {
                WorldStateErrorUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> WorldStateErrorUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [WorldStateErrorUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion>
            where
                Self: ::planus::WriteAsUnion<WorldStateErrorUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectAlreadyExists>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectAlreadyExists>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::RecursiveMove>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::RecursiveMove>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyDefinitionNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyDefinitionNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicatePropertyDefinition>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicatePropertyDefinition>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::ChparentPropertyNameConflict>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::ChparentPropertyNameConflict>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyTypeMismatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyTypeMismatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(11, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbNotFound>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidVerb>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(12, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidVerb>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbDecodeError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(13, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbDecodeError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<14, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(14, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<14, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbPermissionDenied>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<15, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicateVerb>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(15, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<15, T>>
        where
            T: ::planus::WriteAsOffset<self::DuplicateVerb>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<16, T>>
        where
            T: ::planus::WriteAsOffset<self::FailedMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(16, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<16, T>>
        where
            T: ::planus::WriteAsOffset<self::FailedMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<17, T>>
        where
            T: ::planus::WriteAsOffset<self::AmbiguousMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(17, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<17, T>>
        where
            T: ::planus::WriteAsOffset<self::AmbiguousMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<18, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidRenumber>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(18, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<18, T>>
        where
            T: ::planus::WriteAsOffset<self::InvalidRenumber>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<19, T>>
        where
            T: ::planus::WriteAsOffset<self::WorldStateDatabaseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(19, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<19, T>>
        where
            T: ::planus::WriteAsOffset<self::WorldStateDatabaseError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<20, T>>
        where
            T: ::planus::WriteAsOffset<self::RollbackRetry>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorldStateErrorUnion> {
                ::planus::UnionOffset::new(20, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorldStateErrorUnion>
            for WorldStateErrorUnionBuilder<::planus::Initialized<20, T>>
        where
            T: ::planus::WriteAsOffset<self::RollbackRetry>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorldStateErrorUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [WorldStateErrorUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum WorldStateErrorUnionRef<'a> {
            ObjectNotFound(self::ObjectNotFoundRef<'a>),
            ObjectAlreadyExists(self::ObjectAlreadyExistsRef<'a>),
            RecursiveMove(self::RecursiveMoveRef<'a>),
            ObjectPermissionDenied(self::ObjectPermissionDeniedRef<'a>),
            PropertyNotFound(self::PropertyNotFoundRef<'a>),
            PropertyPermissionDenied(self::PropertyPermissionDeniedRef<'a>),
            PropertyDefinitionNotFound(self::PropertyDefinitionNotFoundRef<'a>),
            DuplicatePropertyDefinition(self::DuplicatePropertyDefinitionRef<'a>),
            ChparentPropertyNameConflict(self::ChparentPropertyNameConflictRef<'a>),
            PropertyTypeMismatch(self::PropertyTypeMismatchRef<'a>),
            VerbNotFound(self::VerbNotFoundRef<'a>),
            InvalidVerb(self::InvalidVerbRef<'a>),
            VerbDecodeError(self::VerbDecodeErrorRef<'a>),
            VerbPermissionDenied(self::VerbPermissionDeniedRef<'a>),
            DuplicateVerb(self::DuplicateVerbRef<'a>),
            FailedMatch(self::FailedMatchRef<'a>),
            AmbiguousMatch(self::AmbiguousMatchRef<'a>),
            InvalidRenumber(self::InvalidRenumberRef<'a>),
            WorldStateDatabaseError(self::WorldStateDatabaseErrorRef<'a>),
            RollbackRetry(self::RollbackRetryRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<WorldStateErrorUnionRef<'a>> for WorldStateErrorUnion {
            type Error = ::planus::Error;

            fn try_from(value: WorldStateErrorUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    WorldStateErrorUnionRef::ObjectNotFound(value) => {
                        Self::ObjectNotFound(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::ObjectAlreadyExists(value) => {
                        Self::ObjectAlreadyExists(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::RecursiveMove(value) => {
                        Self::RecursiveMove(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::ObjectPermissionDenied(value) => {
                        Self::ObjectPermissionDenied(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::PropertyNotFound(value) => {
                        Self::PropertyNotFound(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::PropertyPermissionDenied(value) => {
                        Self::PropertyPermissionDenied(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::PropertyDefinitionNotFound(value) => {
                        Self::PropertyDefinitionNotFound(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::DuplicatePropertyDefinition(value) => {
                        Self::DuplicatePropertyDefinition(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::ChparentPropertyNameConflict(value) => {
                        Self::ChparentPropertyNameConflict(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::PropertyTypeMismatch(value) => {
                        Self::PropertyTypeMismatch(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::VerbNotFound(value) => {
                        Self::VerbNotFound(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::InvalidVerb(value) => {
                        Self::InvalidVerb(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::VerbDecodeError(value) => {
                        Self::VerbDecodeError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::VerbPermissionDenied(value) => {
                        Self::VerbPermissionDenied(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::DuplicateVerb(value) => {
                        Self::DuplicateVerb(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::FailedMatch(value) => {
                        Self::FailedMatch(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::AmbiguousMatch(value) => {
                        Self::AmbiguousMatch(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::InvalidRenumber(value) => {
                        Self::InvalidRenumber(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::WorldStateDatabaseError(value) => {
                        Self::WorldStateDatabaseError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorldStateErrorUnionRef::RollbackRetry(value) => {
                        Self::RollbackRetry(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for WorldStateErrorUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::ObjectNotFound(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::ObjectAlreadyExists(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::RecursiveMove(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::ObjectPermissionDenied(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::PropertyNotFound(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    6 => ::core::result::Result::Ok(Self::PropertyPermissionDenied(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    7 => ::core::result::Result::Ok(Self::PropertyDefinitionNotFound(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    8 => ::core::result::Result::Ok(Self::DuplicatePropertyDefinition(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    9 => ::core::result::Result::Ok(Self::ChparentPropertyNameConflict(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    10 => ::core::result::Result::Ok(Self::PropertyTypeMismatch(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    11 => ::core::result::Result::Ok(Self::VerbNotFound(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    12 => ::core::result::Result::Ok(Self::InvalidVerb(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    13 => ::core::result::Result::Ok(Self::VerbDecodeError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    14 => ::core::result::Result::Ok(Self::VerbPermissionDenied(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    15 => ::core::result::Result::Ok(Self::DuplicateVerb(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    16 => ::core::result::Result::Ok(Self::FailedMatch(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    17 => ::core::result::Result::Ok(Self::AmbiguousMatch(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    18 => ::core::result::Result::Ok(Self::InvalidRenumber(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    19 => ::core::result::Result::Ok(Self::WorldStateDatabaseError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    20 => ::core::result::Result::Ok(Self::RollbackRetry(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for WorldStateErrorUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[WorldStateErrorUnionRef]";
        }

        /// The table `ObjectNotFound` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ObjectNotFound` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:452`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectNotFound {
            /// The field `object_ref` in the table `ObjectNotFound`
            pub object_ref: ::planus::alloc::boxed::Box<self::ObjectRef>,
        }

        impl ObjectNotFound {
            /// Creates a [ObjectNotFoundBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectNotFoundBuilder<()> {
                ObjectNotFoundBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_object_ref: impl ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            ) -> ::planus::Offset<Self> {
                let prepared_object_ref = field_object_ref.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ObjectRef>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_object_ref);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectNotFound>> for ObjectNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectNotFound>> for ObjectNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectNotFound> for ObjectNotFound {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectNotFound> {
                ObjectNotFound::create(builder, &self.object_ref)
            }
        }

        /// Builder for serializing an instance of the [ObjectNotFound] type.
        ///
        /// Can be created using the [ObjectNotFound::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectNotFoundBuilder<State>(State);

        impl ObjectNotFoundBuilder<()> {
            /// Setter for the [`object_ref` field](ObjectNotFound#structfield.object_ref).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn object_ref<T0>(self, value: T0) -> ObjectNotFoundBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            {
                ObjectNotFoundBuilder((value,))
            }
        }

        impl<T0> ObjectNotFoundBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectNotFound].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectNotFound>
            where
                Self: ::planus::WriteAsOffset<ObjectNotFound>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>>
            ::planus::WriteAs<::planus::Offset<ObjectNotFound>> for ObjectNotFoundBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectNotFound>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectNotFound>>
            for ObjectNotFoundBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>>
            ::planus::WriteAsOffset<ObjectNotFound> for ObjectNotFoundBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectNotFound> {
                let (v0,) = &self.0;
                ObjectNotFound::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectNotFound].
        #[derive(Copy, Clone)]
        pub struct ObjectNotFoundRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectNotFoundRef<'a> {
            /// Getter for the [`object_ref` field](ObjectNotFound#structfield.object_ref).
            #[inline]
            pub fn object_ref(&self) -> ::planus::Result<self::ObjectRefRef<'a>> {
                self.0.access_required(0, "ObjectNotFound", "object_ref")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectNotFoundRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectNotFoundRef");
                f.field("object_ref", &self.object_ref());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectNotFoundRef<'a>> for ObjectNotFound {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectNotFoundRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    object_ref: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.object_ref()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectNotFoundRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectNotFoundRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectNotFoundRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectNotFound>> for ObjectNotFound {
            type Value = ::planus::Offset<ObjectNotFound>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectNotFound>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectNotFoundRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectNotFoundRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectAlreadyExists` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ObjectAlreadyExists` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:456`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectAlreadyExists {
            /// The field `obj` in the table `ObjectAlreadyExists`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
        }

        impl ObjectAlreadyExists {
            /// Creates a [ObjectAlreadyExistsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectAlreadyExistsBuilder<()> {
                ObjectAlreadyExistsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectAlreadyExists>> for ObjectAlreadyExists {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectAlreadyExists> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectAlreadyExists>> for ObjectAlreadyExists {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectAlreadyExists>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectAlreadyExists> for ObjectAlreadyExists {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectAlreadyExists> {
                ObjectAlreadyExists::create(builder, &self.obj)
            }
        }

        /// Builder for serializing an instance of the [ObjectAlreadyExists] type.
        ///
        /// Can be created using the [ObjectAlreadyExists::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectAlreadyExistsBuilder<State>(State);

        impl ObjectAlreadyExistsBuilder<()> {
            /// Setter for the [`obj` field](ObjectAlreadyExists#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> ObjectAlreadyExistsBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                ObjectAlreadyExistsBuilder((value,))
            }
        }

        impl<T0> ObjectAlreadyExistsBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectAlreadyExists].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectAlreadyExists>
            where
                Self: ::planus::WriteAsOffset<ObjectAlreadyExists>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAs<::planus::Offset<ObjectAlreadyExists>>
            for ObjectAlreadyExistsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectAlreadyExists>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectAlreadyExists> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectAlreadyExists>>
            for ObjectAlreadyExistsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectAlreadyExists>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectAlreadyExists>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAsOffset<ObjectAlreadyExists> for ObjectAlreadyExistsBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectAlreadyExists> {
                let (v0,) = &self.0;
                ObjectAlreadyExists::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectAlreadyExists].
        #[derive(Copy, Clone)]
        pub struct ObjectAlreadyExistsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectAlreadyExistsRef<'a> {
            /// Getter for the [`obj` field](ObjectAlreadyExists#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "ObjectAlreadyExists", "obj")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectAlreadyExistsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectAlreadyExistsRef");
                f.field("obj", &self.obj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectAlreadyExistsRef<'a>> for ObjectAlreadyExists {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectAlreadyExistsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectAlreadyExistsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectAlreadyExistsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectAlreadyExistsRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectAlreadyExists>> for ObjectAlreadyExists {
            type Value = ::planus::Offset<ObjectAlreadyExists>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectAlreadyExists>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectAlreadyExistsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectAlreadyExistsRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `RecursiveMove` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RecursiveMove` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:460`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RecursiveMove {
            /// The field `from_obj` in the table `RecursiveMove`
            pub from_obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `to_obj` in the table `RecursiveMove`
            pub to_obj: ::planus::alloc::boxed::Box<self::Obj>,
        }

        impl RecursiveMove {
            /// Creates a [RecursiveMoveBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RecursiveMoveBuilder<()> {
                RecursiveMoveBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_from_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_to_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_from_obj = field_from_obj.prepare(builder);
                let prepared_to_obj = field_to_obj.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_from_obj);
                        object_writer.write::<_, _, 4>(&prepared_to_obj);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RecursiveMove>> for RecursiveMove {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecursiveMove> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RecursiveMove>> for RecursiveMove {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RecursiveMove>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RecursiveMove> for RecursiveMove {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecursiveMove> {
                RecursiveMove::create(builder, &self.from_obj, &self.to_obj)
            }
        }

        /// Builder for serializing an instance of the [RecursiveMove] type.
        ///
        /// Can be created using the [RecursiveMove::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RecursiveMoveBuilder<State>(State);

        impl RecursiveMoveBuilder<()> {
            /// Setter for the [`from_obj` field](RecursiveMove#structfield.from_obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn from_obj<T0>(self, value: T0) -> RecursiveMoveBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                RecursiveMoveBuilder((value,))
            }
        }

        impl<T0> RecursiveMoveBuilder<(T0,)> {
            /// Setter for the [`to_obj` field](RecursiveMove#structfield.to_obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn to_obj<T1>(self, value: T1) -> RecursiveMoveBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                RecursiveMoveBuilder((v0, value))
            }
        }

        impl<T0, T1> RecursiveMoveBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RecursiveMove].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecursiveMove>
            where
                Self: ::planus::WriteAsOffset<RecursiveMove>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAs<::planus::Offset<RecursiveMove>> for RecursiveMoveBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<RecursiveMove>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecursiveMove> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOptional<::planus::Offset<RecursiveMove>>
            for RecursiveMoveBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<RecursiveMove>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RecursiveMove>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOffset<RecursiveMove> for RecursiveMoveBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecursiveMove> {
                let (v0, v1) = &self.0;
                RecursiveMove::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [RecursiveMove].
        #[derive(Copy, Clone)]
        pub struct RecursiveMoveRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RecursiveMoveRef<'a> {
            /// Getter for the [`from_obj` field](RecursiveMove#structfield.from_obj).
            #[inline]
            pub fn from_obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "RecursiveMove", "from_obj")
            }

            /// Getter for the [`to_obj` field](RecursiveMove#structfield.to_obj).
            #[inline]
            pub fn to_obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "RecursiveMove", "to_obj")
            }
        }

        impl<'a> ::core::fmt::Debug for RecursiveMoveRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RecursiveMoveRef");
                f.field("from_obj", &self.from_obj());
                f.field("to_obj", &self.to_obj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RecursiveMoveRef<'a>> for RecursiveMove {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RecursiveMoveRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    from_obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.from_obj()?,
                    )?),
                    to_obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.to_obj()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RecursiveMoveRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RecursiveMoveRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RecursiveMoveRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RecursiveMove>> for RecursiveMove {
            type Value = ::planus::Offset<RecursiveMove>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RecursiveMove>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RecursiveMoveRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RecursiveMoveRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectPermissionDenied` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ObjectPermissionDenied` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:465`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectPermissionDenied {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ObjectPermissionDenied {
            fn default() -> Self {
                Self {}
            }
        }

        impl ObjectPermissionDenied {
            /// Creates a [ObjectPermissionDeniedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectPermissionDeniedBuilder<()> {
                ObjectPermissionDeniedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectPermissionDenied>> for ObjectPermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectPermissionDenied>>
            for ObjectPermissionDenied
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectPermissionDenied> for ObjectPermissionDenied {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectPermissionDenied> {
                ObjectPermissionDenied::create(builder)
            }
        }

        /// Builder for serializing an instance of the [ObjectPermissionDenied] type.
        ///
        /// Can be created using the [ObjectPermissionDenied::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectPermissionDeniedBuilder<State>(State);

        impl ObjectPermissionDeniedBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectPermissionDenied].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectPermissionDenied>
            where
                Self: ::planus::WriteAsOffset<ObjectPermissionDenied>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectPermissionDenied>>
            for ObjectPermissionDeniedBuilder<()>
        {
            type Prepared = ::planus::Offset<ObjectPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectPermissionDenied>>
            for ObjectPermissionDeniedBuilder<()>
        {
            type Prepared = ::planus::Offset<ObjectPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectPermissionDenied> for ObjectPermissionDeniedBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectPermissionDenied> {
                ObjectPermissionDenied::create(builder)
            }
        }

        /// Reference to a deserialized [ObjectPermissionDenied].
        #[derive(Copy, Clone)]
        pub struct ObjectPermissionDeniedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectPermissionDeniedRef<'a> {}

        impl<'a> ::core::fmt::Debug for ObjectPermissionDeniedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectPermissionDeniedRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectPermissionDeniedRef<'a>> for ObjectPermissionDenied {
            type Error = ::planus::Error;

            fn try_from(_value: ObjectPermissionDeniedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectPermissionDeniedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectPermissionDeniedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectPermissionDeniedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectPermissionDenied>>
            for ObjectPermissionDenied
        {
            type Value = ::planus::Offset<ObjectPermissionDenied>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectPermissionDenied>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectPermissionDeniedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectPermissionDeniedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PropertyNotFound` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PropertyNotFound` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:468`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertyNotFound {
            /// The field `obj` in the table `PropertyNotFound`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `property` in the table `PropertyNotFound`
            pub property: ::planus::alloc::string::String,
        }

        impl PropertyNotFound {
            /// Creates a [PropertyNotFoundBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertyNotFoundBuilder<()> {
                PropertyNotFoundBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_property: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_property = field_property.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_property);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyNotFound>> for PropertyNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyNotFound>> for PropertyNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyNotFound> for PropertyNotFound {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyNotFound> {
                PropertyNotFound::create(builder, &self.obj, &self.property)
            }
        }

        /// Builder for serializing an instance of the [PropertyNotFound] type.
        ///
        /// Can be created using the [PropertyNotFound::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertyNotFoundBuilder<State>(State);

        impl PropertyNotFoundBuilder<()> {
            /// Setter for the [`obj` field](PropertyNotFound#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> PropertyNotFoundBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                PropertyNotFoundBuilder((value,))
            }
        }

        impl<T0> PropertyNotFoundBuilder<(T0,)> {
            /// Setter for the [`property` field](PropertyNotFound#structfield.property).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn property<T1>(self, value: T1) -> PropertyNotFoundBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                PropertyNotFoundBuilder((v0, value))
            }
        }

        impl<T0, T1> PropertyNotFoundBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertyNotFound].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyNotFound>
            where
                Self: ::planus::WriteAsOffset<PropertyNotFound>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<PropertyNotFound>>
            for PropertyNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PropertyNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<PropertyNotFound>>
            for PropertyNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PropertyNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<PropertyNotFound> for PropertyNotFoundBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyNotFound> {
                let (v0, v1) = &self.0;
                PropertyNotFound::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [PropertyNotFound].
        #[derive(Copy, Clone)]
        pub struct PropertyNotFoundRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertyNotFoundRef<'a> {
            /// Getter for the [`obj` field](PropertyNotFound#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "PropertyNotFound", "obj")
            }

            /// Getter for the [`property` field](PropertyNotFound#structfield.property).
            #[inline]
            pub fn property(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "PropertyNotFound", "property")
            }
        }

        impl<'a> ::core::fmt::Debug for PropertyNotFoundRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertyNotFoundRef");
                f.field("obj", &self.obj());
                f.field("property", &self.property());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertyNotFoundRef<'a>> for PropertyNotFound {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropertyNotFoundRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    property: ::core::convert::Into::into(value.property()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertyNotFoundRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertyNotFoundRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyNotFoundRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertyNotFound>> for PropertyNotFound {
            type Value = ::planus::Offset<PropertyNotFound>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertyNotFound>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertyNotFoundRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropertyNotFoundRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PropertyPermissionDenied` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PropertyPermissionDenied` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:473`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertyPermissionDenied {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PropertyPermissionDenied {
            fn default() -> Self {
                Self {}
            }
        }

        impl PropertyPermissionDenied {
            /// Creates a [PropertyPermissionDeniedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertyPermissionDeniedBuilder<()> {
                PropertyPermissionDeniedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyPermissionDenied>> for PropertyPermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyPermissionDenied>>
            for PropertyPermissionDenied
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyPermissionDenied> for PropertyPermissionDenied {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyPermissionDenied> {
                PropertyPermissionDenied::create(builder)
            }
        }

        /// Builder for serializing an instance of the [PropertyPermissionDenied] type.
        ///
        /// Can be created using the [PropertyPermissionDenied::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertyPermissionDeniedBuilder<State>(State);

        impl PropertyPermissionDeniedBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertyPermissionDenied].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyPermissionDenied>
            where
                Self: ::planus::WriteAsOffset<PropertyPermissionDenied>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyPermissionDenied>>
            for PropertyPermissionDeniedBuilder<()>
        {
            type Prepared = ::planus::Offset<PropertyPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyPermissionDenied>>
            for PropertyPermissionDeniedBuilder<()>
        {
            type Prepared = ::planus::Offset<PropertyPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyPermissionDenied> for PropertyPermissionDeniedBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyPermissionDenied> {
                PropertyPermissionDenied::create(builder)
            }
        }

        /// Reference to a deserialized [PropertyPermissionDenied].
        #[derive(Copy, Clone)]
        pub struct PropertyPermissionDeniedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertyPermissionDeniedRef<'a> {}

        impl<'a> ::core::fmt::Debug for PropertyPermissionDeniedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertyPermissionDeniedRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertyPermissionDeniedRef<'a>> for PropertyPermissionDenied {
            type Error = ::planus::Error;

            fn try_from(_value: PropertyPermissionDeniedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertyPermissionDeniedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertyPermissionDeniedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyPermissionDeniedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertyPermissionDenied>>
            for PropertyPermissionDenied
        {
            type Value = ::planus::Offset<PropertyPermissionDenied>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertyPermissionDenied>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertyPermissionDeniedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyPermissionDeniedRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `PropertyDefinitionNotFound` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PropertyDefinitionNotFound` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:476`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertyDefinitionNotFound {
            /// The field `obj` in the table `PropertyDefinitionNotFound`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `property` in the table `PropertyDefinitionNotFound`
            pub property: ::planus::alloc::string::String,
        }

        impl PropertyDefinitionNotFound {
            /// Creates a [PropertyDefinitionNotFoundBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertyDefinitionNotFoundBuilder<()> {
                PropertyDefinitionNotFoundBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_property: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_property = field_property.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_property);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyDefinitionNotFound>>
            for PropertyDefinitionNotFound
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyDefinitionNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyDefinitionNotFound>>
            for PropertyDefinitionNotFound
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyDefinitionNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyDefinitionNotFound> for PropertyDefinitionNotFound {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyDefinitionNotFound> {
                PropertyDefinitionNotFound::create(builder, &self.obj, &self.property)
            }
        }

        /// Builder for serializing an instance of the [PropertyDefinitionNotFound] type.
        ///
        /// Can be created using the [PropertyDefinitionNotFound::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertyDefinitionNotFoundBuilder<State>(State);

        impl PropertyDefinitionNotFoundBuilder<()> {
            /// Setter for the [`obj` field](PropertyDefinitionNotFound#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> PropertyDefinitionNotFoundBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                PropertyDefinitionNotFoundBuilder((value,))
            }
        }

        impl<T0> PropertyDefinitionNotFoundBuilder<(T0,)> {
            /// Setter for the [`property` field](PropertyDefinitionNotFound#structfield.property).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn property<T1>(self, value: T1) -> PropertyDefinitionNotFoundBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                PropertyDefinitionNotFoundBuilder((v0, value))
            }
        }

        impl<T0, T1> PropertyDefinitionNotFoundBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertyDefinitionNotFound].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyDefinitionNotFound>
            where
                Self: ::planus::WriteAsOffset<PropertyDefinitionNotFound>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<PropertyDefinitionNotFound>>
            for PropertyDefinitionNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PropertyDefinitionNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyDefinitionNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<PropertyDefinitionNotFound>>
            for PropertyDefinitionNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PropertyDefinitionNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyDefinitionNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<PropertyDefinitionNotFound>
            for PropertyDefinitionNotFoundBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyDefinitionNotFound> {
                let (v0, v1) = &self.0;
                PropertyDefinitionNotFound::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [PropertyDefinitionNotFound].
        #[derive(Copy, Clone)]
        pub struct PropertyDefinitionNotFoundRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertyDefinitionNotFoundRef<'a> {
            /// Getter for the [`obj` field](PropertyDefinitionNotFound#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(0, "PropertyDefinitionNotFound", "obj")
            }

            /// Getter for the [`property` field](PropertyDefinitionNotFound#structfield.property).
            #[inline]
            pub fn property(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(1, "PropertyDefinitionNotFound", "property")
            }
        }

        impl<'a> ::core::fmt::Debug for PropertyDefinitionNotFoundRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertyDefinitionNotFoundRef");
                f.field("obj", &self.obj());
                f.field("property", &self.property());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertyDefinitionNotFoundRef<'a>>
            for PropertyDefinitionNotFound
        {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropertyDefinitionNotFoundRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    property: ::core::convert::Into::into(value.property()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertyDefinitionNotFoundRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertyDefinitionNotFoundRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyDefinitionNotFoundRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertyDefinitionNotFound>>
            for PropertyDefinitionNotFound
        {
            type Value = ::planus::Offset<PropertyDefinitionNotFound>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertyDefinitionNotFound>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertyDefinitionNotFoundRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyDefinitionNotFoundRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `DuplicatePropertyDefinition` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DuplicatePropertyDefinition` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:481`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DuplicatePropertyDefinition {
            /// The field `obj` in the table `DuplicatePropertyDefinition`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `property` in the table `DuplicatePropertyDefinition`
            pub property: ::planus::alloc::string::String,
        }

        impl DuplicatePropertyDefinition {
            /// Creates a [DuplicatePropertyDefinitionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DuplicatePropertyDefinitionBuilder<()> {
                DuplicatePropertyDefinitionBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_property: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_property = field_property.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_property);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DuplicatePropertyDefinition>>
            for DuplicatePropertyDefinition
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicatePropertyDefinition> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DuplicatePropertyDefinition>>
            for DuplicatePropertyDefinition
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicatePropertyDefinition>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DuplicatePropertyDefinition> for DuplicatePropertyDefinition {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicatePropertyDefinition> {
                DuplicatePropertyDefinition::create(builder, &self.obj, &self.property)
            }
        }

        /// Builder for serializing an instance of the [DuplicatePropertyDefinition] type.
        ///
        /// Can be created using the [DuplicatePropertyDefinition::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DuplicatePropertyDefinitionBuilder<State>(State);

        impl DuplicatePropertyDefinitionBuilder<()> {
            /// Setter for the [`obj` field](DuplicatePropertyDefinition#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> DuplicatePropertyDefinitionBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                DuplicatePropertyDefinitionBuilder((value,))
            }
        }

        impl<T0> DuplicatePropertyDefinitionBuilder<(T0,)> {
            /// Setter for the [`property` field](DuplicatePropertyDefinition#structfield.property).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn property<T1>(self, value: T1) -> DuplicatePropertyDefinitionBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                DuplicatePropertyDefinitionBuilder((v0, value))
            }
        }

        impl<T0, T1> DuplicatePropertyDefinitionBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DuplicatePropertyDefinition].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicatePropertyDefinition>
            where
                Self: ::planus::WriteAsOffset<DuplicatePropertyDefinition>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<DuplicatePropertyDefinition>>
            for DuplicatePropertyDefinitionBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicatePropertyDefinition>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicatePropertyDefinition> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<DuplicatePropertyDefinition>>
            for DuplicatePropertyDefinitionBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicatePropertyDefinition>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicatePropertyDefinition>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<DuplicatePropertyDefinition>
            for DuplicatePropertyDefinitionBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DuplicatePropertyDefinition> {
                let (v0, v1) = &self.0;
                DuplicatePropertyDefinition::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [DuplicatePropertyDefinition].
        #[derive(Copy, Clone)]
        pub struct DuplicatePropertyDefinitionRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DuplicatePropertyDefinitionRef<'a> {
            /// Getter for the [`obj` field](DuplicatePropertyDefinition#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(0, "DuplicatePropertyDefinition", "obj")
            }

            /// Getter for the [`property` field](DuplicatePropertyDefinition#structfield.property).
            #[inline]
            pub fn property(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(1, "DuplicatePropertyDefinition", "property")
            }
        }

        impl<'a> ::core::fmt::Debug for DuplicatePropertyDefinitionRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DuplicatePropertyDefinitionRef");
                f.field("obj", &self.obj());
                f.field("property", &self.property());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DuplicatePropertyDefinitionRef<'a>>
            for DuplicatePropertyDefinition
        {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DuplicatePropertyDefinitionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    property: ::core::convert::Into::into(value.property()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DuplicatePropertyDefinitionRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DuplicatePropertyDefinitionRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DuplicatePropertyDefinitionRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DuplicatePropertyDefinition>>
            for DuplicatePropertyDefinition
        {
            type Value = ::planus::Offset<DuplicatePropertyDefinition>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DuplicatePropertyDefinition>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DuplicatePropertyDefinitionRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DuplicatePropertyDefinitionRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `ChparentPropertyNameConflict` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ChparentPropertyNameConflict` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:486`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ChparentPropertyNameConflict {
            /// The field `descendant` in the table `ChparentPropertyNameConflict`
            pub descendant: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `ancestor` in the table `ChparentPropertyNameConflict`
            pub ancestor: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `property` in the table `ChparentPropertyNameConflict`
            pub property: ::planus::alloc::string::String,
        }

        impl ChparentPropertyNameConflict {
            /// Creates a [ChparentPropertyNameConflictBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ChparentPropertyNameConflictBuilder<()> {
                ChparentPropertyNameConflictBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_descendant: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_ancestor: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_property: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_descendant = field_descendant.prepare(builder);
                let prepared_ancestor = field_ancestor.prepare(builder);
                let prepared_property = field_property.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);
                table_writer.write_entry::<::planus::Offset<str>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_descendant);
                        object_writer.write::<_, _, 4>(&prepared_ancestor);
                        object_writer.write::<_, _, 4>(&prepared_property);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ChparentPropertyNameConflict>>
            for ChparentPropertyNameConflict
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ChparentPropertyNameConflict> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ChparentPropertyNameConflict>>
            for ChparentPropertyNameConflict
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ChparentPropertyNameConflict>>
            {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ChparentPropertyNameConflict> for ChparentPropertyNameConflict {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ChparentPropertyNameConflict> {
                ChparentPropertyNameConflict::create(
                    builder,
                    &self.descendant,
                    &self.ancestor,
                    &self.property,
                )
            }
        }

        /// Builder for serializing an instance of the [ChparentPropertyNameConflict] type.
        ///
        /// Can be created using the [ChparentPropertyNameConflict::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ChparentPropertyNameConflictBuilder<State>(State);

        impl ChparentPropertyNameConflictBuilder<()> {
            /// Setter for the [`descendant` field](ChparentPropertyNameConflict#structfield.descendant).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn descendant<T0>(self, value: T0) -> ChparentPropertyNameConflictBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                ChparentPropertyNameConflictBuilder((value,))
            }
        }

        impl<T0> ChparentPropertyNameConflictBuilder<(T0,)> {
            /// Setter for the [`ancestor` field](ChparentPropertyNameConflict#structfield.ancestor).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn ancestor<T1>(self, value: T1) -> ChparentPropertyNameConflictBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                ChparentPropertyNameConflictBuilder((v0, value))
            }
        }

        impl<T0, T1> ChparentPropertyNameConflictBuilder<(T0, T1)> {
            /// Setter for the [`property` field](ChparentPropertyNameConflict#structfield.property).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn property<T2>(
                self,
                value: T2,
            ) -> ChparentPropertyNameConflictBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1) = self.0;
                ChparentPropertyNameConflictBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> ChparentPropertyNameConflictBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ChparentPropertyNameConflict].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ChparentPropertyNameConflict>
            where
                Self: ::planus::WriteAsOffset<ChparentPropertyNameConflict>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<ChparentPropertyNameConflict>>
            for ChparentPropertyNameConflictBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<ChparentPropertyNameConflict>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ChparentPropertyNameConflict> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<ChparentPropertyNameConflict>>
            for ChparentPropertyNameConflictBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<ChparentPropertyNameConflict>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ChparentPropertyNameConflict>>
            {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<ChparentPropertyNameConflict>
            for ChparentPropertyNameConflictBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ChparentPropertyNameConflict> {
                let (v0, v1, v2) = &self.0;
                ChparentPropertyNameConflict::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [ChparentPropertyNameConflict].
        #[derive(Copy, Clone)]
        pub struct ChparentPropertyNameConflictRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ChparentPropertyNameConflictRef<'a> {
            /// Getter for the [`descendant` field](ChparentPropertyNameConflict#structfield.descendant).
            #[inline]
            pub fn descendant(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(0, "ChparentPropertyNameConflict", "descendant")
            }

            /// Getter for the [`ancestor` field](ChparentPropertyNameConflict#structfield.ancestor).
            #[inline]
            pub fn ancestor(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(1, "ChparentPropertyNameConflict", "ancestor")
            }

            /// Getter for the [`property` field](ChparentPropertyNameConflict#structfield.property).
            #[inline]
            pub fn property(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(2, "ChparentPropertyNameConflict", "property")
            }
        }

        impl<'a> ::core::fmt::Debug for ChparentPropertyNameConflictRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ChparentPropertyNameConflictRef");
                f.field("descendant", &self.descendant());
                f.field("ancestor", &self.ancestor());
                f.field("property", &self.property());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ChparentPropertyNameConflictRef<'a>>
            for ChparentPropertyNameConflict
        {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ChparentPropertyNameConflictRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    descendant: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.descendant()?)?,
                    ),
                    ancestor: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.ancestor()?,
                    )?),
                    property: ::core::convert::Into::into(value.property()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ChparentPropertyNameConflictRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ChparentPropertyNameConflictRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ChparentPropertyNameConflictRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ChparentPropertyNameConflict>>
            for ChparentPropertyNameConflict
        {
            type Value = ::planus::Offset<ChparentPropertyNameConflict>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ChparentPropertyNameConflict>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ChparentPropertyNameConflictRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ChparentPropertyNameConflictRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `PropertyTypeMismatch` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PropertyTypeMismatch` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:492`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertyTypeMismatch {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PropertyTypeMismatch {
            fn default() -> Self {
                Self {}
            }
        }

        impl PropertyTypeMismatch {
            /// Creates a [PropertyTypeMismatchBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertyTypeMismatchBuilder<()> {
                PropertyTypeMismatchBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyTypeMismatch>> for PropertyTypeMismatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyTypeMismatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyTypeMismatch>> for PropertyTypeMismatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyTypeMismatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyTypeMismatch> for PropertyTypeMismatch {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyTypeMismatch> {
                PropertyTypeMismatch::create(builder)
            }
        }

        /// Builder for serializing an instance of the [PropertyTypeMismatch] type.
        ///
        /// Can be created using the [PropertyTypeMismatch::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertyTypeMismatchBuilder<State>(State);

        impl PropertyTypeMismatchBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertyTypeMismatch].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyTypeMismatch>
            where
                Self: ::planus::WriteAsOffset<PropertyTypeMismatch>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyTypeMismatch>> for PropertyTypeMismatchBuilder<()> {
            type Prepared = ::planus::Offset<PropertyTypeMismatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyTypeMismatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyTypeMismatch>>
            for PropertyTypeMismatchBuilder<()>
        {
            type Prepared = ::planus::Offset<PropertyTypeMismatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyTypeMismatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyTypeMismatch> for PropertyTypeMismatchBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertyTypeMismatch> {
                PropertyTypeMismatch::create(builder)
            }
        }

        /// Reference to a deserialized [PropertyTypeMismatch].
        #[derive(Copy, Clone)]
        pub struct PropertyTypeMismatchRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertyTypeMismatchRef<'a> {}

        impl<'a> ::core::fmt::Debug for PropertyTypeMismatchRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertyTypeMismatchRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertyTypeMismatchRef<'a>> for PropertyTypeMismatch {
            type Error = ::planus::Error;

            fn try_from(_value: PropertyTypeMismatchRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertyTypeMismatchRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertyTypeMismatchRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyTypeMismatchRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertyTypeMismatch>> for PropertyTypeMismatch {
            type Value = ::planus::Offset<PropertyTypeMismatch>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertyTypeMismatch>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertyTypeMismatchRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropertyTypeMismatchRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbNotFound` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbNotFound` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:495`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbNotFound {
            /// The field `obj` in the table `VerbNotFound`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `verb` in the table `VerbNotFound`
            pub verb: ::planus::alloc::string::String,
        }

        impl VerbNotFound {
            /// Creates a [VerbNotFoundBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbNotFoundBuilder<()> {
                VerbNotFoundBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_verb: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_verb = field_verb.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_verb);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbNotFound>> for VerbNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbNotFound>> for VerbNotFound {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbNotFound> for VerbNotFound {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbNotFound> {
                VerbNotFound::create(builder, &self.obj, &self.verb)
            }
        }

        /// Builder for serializing an instance of the [VerbNotFound] type.
        ///
        /// Can be created using the [VerbNotFound::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbNotFoundBuilder<State>(State);

        impl VerbNotFoundBuilder<()> {
            /// Setter for the [`obj` field](VerbNotFound#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> VerbNotFoundBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                VerbNotFoundBuilder((value,))
            }
        }

        impl<T0> VerbNotFoundBuilder<(T0,)> {
            /// Setter for the [`verb` field](VerbNotFound#structfield.verb).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verb<T1>(self, value: T1) -> VerbNotFoundBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                VerbNotFoundBuilder((v0, value))
            }
        }

        impl<T0, T1> VerbNotFoundBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbNotFound].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbNotFound>
            where
                Self: ::planus::WriteAsOffset<VerbNotFound>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<VerbNotFound>> for VerbNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbNotFound>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbNotFound> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<VerbNotFound>>
            for VerbNotFoundBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbNotFound>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbNotFound>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<VerbNotFound> for VerbNotFoundBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbNotFound> {
                let (v0, v1) = &self.0;
                VerbNotFound::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [VerbNotFound].
        #[derive(Copy, Clone)]
        pub struct VerbNotFoundRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbNotFoundRef<'a> {
            /// Getter for the [`obj` field](VerbNotFound#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "VerbNotFound", "obj")
            }

            /// Getter for the [`verb` field](VerbNotFound#structfield.verb).
            #[inline]
            pub fn verb(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "VerbNotFound", "verb")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbNotFoundRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbNotFoundRef");
                f.field("obj", &self.obj());
                f.field("verb", &self.verb());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbNotFoundRef<'a>> for VerbNotFound {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbNotFoundRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    verb: ::core::convert::Into::into(value.verb()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbNotFoundRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbNotFoundRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbNotFoundRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbNotFound>> for VerbNotFound {
            type Value = ::planus::Offset<VerbNotFound>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbNotFound>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbNotFoundRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbNotFoundRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `InvalidVerb` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `InvalidVerb` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:500`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct InvalidVerb {
            /// The field `vid` in the table `InvalidVerb`
            pub vid: i64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for InvalidVerb {
            fn default() -> Self {
                Self { vid: 0 }
            }
        }

        impl InvalidVerb {
            /// Creates a [InvalidVerbBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> InvalidVerbBuilder<()> {
                InvalidVerbBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_vid: impl ::planus::WriteAsDefault<i64, i64>,
            ) -> ::planus::Offset<Self> {
                let prepared_vid = field_vid.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_vid.is_some() {
                    table_writer.write_entry::<i64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_vid) = prepared_vid {
                            object_writer.write::<_, _, 8>(&prepared_vid);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<InvalidVerb>> for InvalidVerb {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvalidVerb> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<InvalidVerb>> for InvalidVerb {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidVerb>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<InvalidVerb> for InvalidVerb {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvalidVerb> {
                InvalidVerb::create(builder, self.vid)
            }
        }

        /// Builder for serializing an instance of the [InvalidVerb] type.
        ///
        /// Can be created using the [InvalidVerb::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct InvalidVerbBuilder<State>(State);

        impl InvalidVerbBuilder<()> {
            /// Setter for the [`vid` field](InvalidVerb#structfield.vid).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn vid<T0>(self, value: T0) -> InvalidVerbBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<i64, i64>,
            {
                InvalidVerbBuilder((value,))
            }

            /// Sets the [`vid` field](InvalidVerb#structfield.vid) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn vid_as_default(self) -> InvalidVerbBuilder<(::planus::DefaultValue,)> {
                self.vid(::planus::DefaultValue)
            }
        }

        impl<T0> InvalidVerbBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [InvalidVerb].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvalidVerb>
            where
                Self: ::planus::WriteAsOffset<InvalidVerb>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i64, i64>>
            ::planus::WriteAs<::planus::Offset<InvalidVerb>> for InvalidVerbBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidVerb>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvalidVerb> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<i64, i64>>
            ::planus::WriteAsOptional<::planus::Offset<InvalidVerb>> for InvalidVerbBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidVerb>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidVerb>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<i64, i64>> ::planus::WriteAsOffset<InvalidVerb>
            for InvalidVerbBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvalidVerb> {
                let (v0,) = &self.0;
                InvalidVerb::create(builder, v0)
            }
        }

        /// Reference to a deserialized [InvalidVerb].
        #[derive(Copy, Clone)]
        pub struct InvalidVerbRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> InvalidVerbRef<'a> {
            /// Getter for the [`vid` field](InvalidVerb#structfield.vid).
            #[inline]
            pub fn vid(&self) -> ::planus::Result<i64> {
                ::core::result::Result::Ok(self.0.access(0, "InvalidVerb", "vid")?.unwrap_or(0))
            }
        }

        impl<'a> ::core::fmt::Debug for InvalidVerbRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("InvalidVerbRef");
                f.field("vid", &self.vid());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<InvalidVerbRef<'a>> for InvalidVerb {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: InvalidVerbRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    vid: ::core::convert::TryInto::try_into(value.vid()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for InvalidVerbRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for InvalidVerbRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[InvalidVerbRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<InvalidVerb>> for InvalidVerb {
            type Value = ::planus::Offset<InvalidVerb>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<InvalidVerb>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for InvalidVerbRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[InvalidVerbRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbDecodeError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbDecodeError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:504`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbDecodeError {
            /// The field `obj` in the table `VerbDecodeError`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `verb` in the table `VerbDecodeError`
            pub verb: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        impl VerbDecodeError {
            /// Creates a [VerbDecodeErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbDecodeErrorBuilder<()> {
                VerbDecodeErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_verb: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_verb = field_verb.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_verb);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbDecodeError>> for VerbDecodeError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDecodeError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbDecodeError>> for VerbDecodeError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbDecodeError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbDecodeError> for VerbDecodeError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDecodeError> {
                VerbDecodeError::create(builder, &self.obj, &self.verb)
            }
        }

        /// Builder for serializing an instance of the [VerbDecodeError] type.
        ///
        /// Can be created using the [VerbDecodeError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbDecodeErrorBuilder<State>(State);

        impl VerbDecodeErrorBuilder<()> {
            /// Setter for the [`obj` field](VerbDecodeError#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> VerbDecodeErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                VerbDecodeErrorBuilder((value,))
            }
        }

        impl<T0> VerbDecodeErrorBuilder<(T0,)> {
            /// Setter for the [`verb` field](VerbDecodeError#structfield.verb).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verb<T1>(self, value: T1) -> VerbDecodeErrorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                VerbDecodeErrorBuilder((v0, value))
            }
        }

        impl<T0, T1> VerbDecodeErrorBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbDecodeError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDecodeError>
            where
                Self: ::planus::WriteAsOffset<VerbDecodeError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<VerbDecodeError>>
            for VerbDecodeErrorBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbDecodeError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDecodeError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<VerbDecodeError>>
            for VerbDecodeErrorBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbDecodeError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbDecodeError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<VerbDecodeError> for VerbDecodeErrorBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbDecodeError> {
                let (v0, v1) = &self.0;
                VerbDecodeError::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [VerbDecodeError].
        #[derive(Copy, Clone)]
        pub struct VerbDecodeErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbDecodeErrorRef<'a> {
            /// Getter for the [`obj` field](VerbDecodeError#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "VerbDecodeError", "obj")
            }

            /// Getter for the [`verb` field](VerbDecodeError#structfield.verb).
            #[inline]
            pub fn verb(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(1, "VerbDecodeError", "verb")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbDecodeErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbDecodeErrorRef");
                f.field("obj", &self.obj());
                f.field("verb", &self.verb());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbDecodeErrorRef<'a>> for VerbDecodeError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbDecodeErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    verb: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.verb()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbDecodeErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbDecodeErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbDecodeErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbDecodeError>> for VerbDecodeError {
            type Value = ::planus::Offset<VerbDecodeError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbDecodeError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbDecodeErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbDecodeErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbPermissionDenied` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbPermissionDenied` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:509`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbPermissionDenied {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VerbPermissionDenied {
            fn default() -> Self {
                Self {}
            }
        }

        impl VerbPermissionDenied {
            /// Creates a [VerbPermissionDeniedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbPermissionDeniedBuilder<()> {
                VerbPermissionDeniedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbPermissionDenied>> for VerbPermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbPermissionDenied>> for VerbPermissionDenied {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbPermissionDenied> for VerbPermissionDenied {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbPermissionDenied> {
                VerbPermissionDenied::create(builder)
            }
        }

        /// Builder for serializing an instance of the [VerbPermissionDenied] type.
        ///
        /// Can be created using the [VerbPermissionDenied::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbPermissionDeniedBuilder<State>(State);

        impl VerbPermissionDeniedBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbPermissionDenied].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbPermissionDenied>
            where
                Self: ::planus::WriteAsOffset<VerbPermissionDenied>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbPermissionDenied>> for VerbPermissionDeniedBuilder<()> {
            type Prepared = ::planus::Offset<VerbPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbPermissionDenied> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbPermissionDenied>>
            for VerbPermissionDeniedBuilder<()>
        {
            type Prepared = ::planus::Offset<VerbPermissionDenied>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbPermissionDenied>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbPermissionDenied> for VerbPermissionDeniedBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbPermissionDenied> {
                VerbPermissionDenied::create(builder)
            }
        }

        /// Reference to a deserialized [VerbPermissionDenied].
        #[derive(Copy, Clone)]
        pub struct VerbPermissionDeniedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbPermissionDeniedRef<'a> {}

        impl<'a> ::core::fmt::Debug for VerbPermissionDeniedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbPermissionDeniedRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbPermissionDeniedRef<'a>> for VerbPermissionDenied {
            type Error = ::planus::Error;

            fn try_from(_value: VerbPermissionDeniedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbPermissionDeniedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbPermissionDeniedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbPermissionDeniedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbPermissionDenied>> for VerbPermissionDenied {
            type Value = ::planus::Offset<VerbPermissionDenied>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbPermissionDenied>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbPermissionDeniedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbPermissionDeniedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DuplicateVerb` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DuplicateVerb` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:512`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DuplicateVerb {
            /// The field `obj` in the table `DuplicateVerb`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `verb` in the table `DuplicateVerb`
            pub verb: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        impl DuplicateVerb {
            /// Creates a [DuplicateVerbBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DuplicateVerbBuilder<()> {
                DuplicateVerbBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_verb: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_verb = field_verb.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_verb);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DuplicateVerb>> for DuplicateVerb {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DuplicateVerb> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DuplicateVerb>> for DuplicateVerb {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicateVerb>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DuplicateVerb> for DuplicateVerb {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DuplicateVerb> {
                DuplicateVerb::create(builder, &self.obj, &self.verb)
            }
        }

        /// Builder for serializing an instance of the [DuplicateVerb] type.
        ///
        /// Can be created using the [DuplicateVerb::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DuplicateVerbBuilder<State>(State);

        impl DuplicateVerbBuilder<()> {
            /// Setter for the [`obj` field](DuplicateVerb#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> DuplicateVerbBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                DuplicateVerbBuilder((value,))
            }
        }

        impl<T0> DuplicateVerbBuilder<(T0,)> {
            /// Setter for the [`verb` field](DuplicateVerb#structfield.verb).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verb<T1>(self, value: T1) -> DuplicateVerbBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                DuplicateVerbBuilder((v0, value))
            }
        }

        impl<T0, T1> DuplicateVerbBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DuplicateVerb].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<DuplicateVerb>
            where
                Self: ::planus::WriteAsOffset<DuplicateVerb>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<DuplicateVerb>> for DuplicateVerbBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicateVerb>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DuplicateVerb> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<DuplicateVerb>>
            for DuplicateVerbBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DuplicateVerb>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DuplicateVerb>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<DuplicateVerb> for DuplicateVerbBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DuplicateVerb> {
                let (v0, v1) = &self.0;
                DuplicateVerb::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [DuplicateVerb].
        #[derive(Copy, Clone)]
        pub struct DuplicateVerbRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DuplicateVerbRef<'a> {
            /// Getter for the [`obj` field](DuplicateVerb#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "DuplicateVerb", "obj")
            }

            /// Getter for the [`verb` field](DuplicateVerb#structfield.verb).
            #[inline]
            pub fn verb(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(1, "DuplicateVerb", "verb")
            }
        }

        impl<'a> ::core::fmt::Debug for DuplicateVerbRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DuplicateVerbRef");
                f.field("obj", &self.obj());
                f.field("verb", &self.verb());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DuplicateVerbRef<'a>> for DuplicateVerb {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DuplicateVerbRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    verb: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.verb()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DuplicateVerbRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DuplicateVerbRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DuplicateVerbRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DuplicateVerb>> for DuplicateVerb {
            type Value = ::planus::Offset<DuplicateVerb>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DuplicateVerb>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DuplicateVerbRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DuplicateVerbRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `FailedMatch` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `FailedMatch` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:517`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct FailedMatch {
            /// The field `match_string` in the table `FailedMatch`
            pub match_string: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for FailedMatch {
            fn default() -> Self {
                Self {
                    match_string: ::core::default::Default::default(),
                }
            }
        }

        impl FailedMatch {
            /// Creates a [FailedMatchBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> FailedMatchBuilder<()> {
                FailedMatchBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_match_string: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_match_string = field_match_string.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_match_string);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<FailedMatch>> for FailedMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FailedMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<FailedMatch>> for FailedMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<FailedMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<FailedMatch> for FailedMatch {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FailedMatch> {
                FailedMatch::create(builder, &self.match_string)
            }
        }

        /// Builder for serializing an instance of the [FailedMatch] type.
        ///
        /// Can be created using the [FailedMatch::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct FailedMatchBuilder<State>(State);

        impl FailedMatchBuilder<()> {
            /// Setter for the [`match_string` field](FailedMatch#structfield.match_string).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn match_string<T0>(self, value: T0) -> FailedMatchBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                FailedMatchBuilder((value,))
            }
        }

        impl<T0> FailedMatchBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [FailedMatch].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<FailedMatch>
            where
                Self: ::planus::WriteAsOffset<FailedMatch>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<FailedMatch>> for FailedMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<FailedMatch>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FailedMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<FailedMatch>> for FailedMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<FailedMatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<FailedMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<FailedMatch>
            for FailedMatchBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FailedMatch> {
                let (v0,) = &self.0;
                FailedMatch::create(builder, v0)
            }
        }

        /// Reference to a deserialized [FailedMatch].
        #[derive(Copy, Clone)]
        pub struct FailedMatchRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> FailedMatchRef<'a> {
            /// Getter for the [`match_string` field](FailedMatch#structfield.match_string).
            #[inline]
            pub fn match_string(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "FailedMatch", "match_string")
            }
        }

        impl<'a> ::core::fmt::Debug for FailedMatchRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("FailedMatchRef");
                f.field("match_string", &self.match_string());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<FailedMatchRef<'a>> for FailedMatch {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: FailedMatchRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    match_string: ::core::convert::Into::into(value.match_string()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for FailedMatchRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for FailedMatchRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[FailedMatchRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<FailedMatch>> for FailedMatch {
            type Value = ::planus::Offset<FailedMatch>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<FailedMatch>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for FailedMatchRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[FailedMatchRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `AmbiguousMatch` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `AmbiguousMatch` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:521`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct AmbiguousMatch {
            /// The field `match_string` in the table `AmbiguousMatch`
            pub match_string: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for AmbiguousMatch {
            fn default() -> Self {
                Self {
                    match_string: ::core::default::Default::default(),
                }
            }
        }

        impl AmbiguousMatch {
            /// Creates a [AmbiguousMatchBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AmbiguousMatchBuilder<()> {
                AmbiguousMatchBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_match_string: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_match_string = field_match_string.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_match_string);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<AmbiguousMatch>> for AmbiguousMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AmbiguousMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<AmbiguousMatch>> for AmbiguousMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AmbiguousMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<AmbiguousMatch> for AmbiguousMatch {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AmbiguousMatch> {
                AmbiguousMatch::create(builder, &self.match_string)
            }
        }

        /// Builder for serializing an instance of the [AmbiguousMatch] type.
        ///
        /// Can be created using the [AmbiguousMatch::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AmbiguousMatchBuilder<State>(State);

        impl AmbiguousMatchBuilder<()> {
            /// Setter for the [`match_string` field](AmbiguousMatch#structfield.match_string).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn match_string<T0>(self, value: T0) -> AmbiguousMatchBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                AmbiguousMatchBuilder((value,))
            }
        }

        impl<T0> AmbiguousMatchBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AmbiguousMatch].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<AmbiguousMatch>
            where
                Self: ::planus::WriteAsOffset<AmbiguousMatch>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<AmbiguousMatch>> for AmbiguousMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<AmbiguousMatch>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AmbiguousMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<AmbiguousMatch>>
            for AmbiguousMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<AmbiguousMatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AmbiguousMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<AmbiguousMatch>
            for AmbiguousMatchBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AmbiguousMatch> {
                let (v0,) = &self.0;
                AmbiguousMatch::create(builder, v0)
            }
        }

        /// Reference to a deserialized [AmbiguousMatch].
        #[derive(Copy, Clone)]
        pub struct AmbiguousMatchRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AmbiguousMatchRef<'a> {
            /// Getter for the [`match_string` field](AmbiguousMatch#structfield.match_string).
            #[inline]
            pub fn match_string(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "AmbiguousMatch", "match_string")
            }
        }

        impl<'a> ::core::fmt::Debug for AmbiguousMatchRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AmbiguousMatchRef");
                f.field("match_string", &self.match_string());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AmbiguousMatchRef<'a>> for AmbiguousMatch {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AmbiguousMatchRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    match_string: ::core::convert::Into::into(value.match_string()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AmbiguousMatchRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AmbiguousMatchRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[AmbiguousMatchRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<AmbiguousMatch>> for AmbiguousMatch {
            type Value = ::planus::Offset<AmbiguousMatch>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<AmbiguousMatch>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AmbiguousMatchRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AmbiguousMatchRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `InvalidRenumber` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `InvalidRenumber` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:525`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct InvalidRenumber {
            /// The field `message` in the table `InvalidRenumber`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for InvalidRenumber {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl InvalidRenumber {
            /// Creates a [InvalidRenumberBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> InvalidRenumberBuilder<()> {
                InvalidRenumberBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<InvalidRenumber>> for InvalidRenumber {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidRenumber> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<InvalidRenumber>> for InvalidRenumber {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidRenumber>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<InvalidRenumber> for InvalidRenumber {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidRenumber> {
                InvalidRenumber::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [InvalidRenumber] type.
        ///
        /// Can be created using the [InvalidRenumber::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct InvalidRenumberBuilder<State>(State);

        impl InvalidRenumberBuilder<()> {
            /// Setter for the [`message` field](InvalidRenumber#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> InvalidRenumberBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                InvalidRenumberBuilder((value,))
            }
        }

        impl<T0> InvalidRenumberBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [InvalidRenumber].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidRenumber>
            where
                Self: ::planus::WriteAsOffset<InvalidRenumber>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<InvalidRenumber>> for InvalidRenumberBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidRenumber>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidRenumber> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<InvalidRenumber>>
            for InvalidRenumberBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<InvalidRenumber>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvalidRenumber>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<InvalidRenumber>
            for InvalidRenumberBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<InvalidRenumber> {
                let (v0,) = &self.0;
                InvalidRenumber::create(builder, v0)
            }
        }

        /// Reference to a deserialized [InvalidRenumber].
        #[derive(Copy, Clone)]
        pub struct InvalidRenumberRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> InvalidRenumberRef<'a> {
            /// Getter for the [`message` field](InvalidRenumber#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "InvalidRenumber", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for InvalidRenumberRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("InvalidRenumberRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<InvalidRenumberRef<'a>> for InvalidRenumber {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: InvalidRenumberRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for InvalidRenumberRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for InvalidRenumberRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[InvalidRenumberRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<InvalidRenumber>> for InvalidRenumber {
            type Value = ::planus::Offset<InvalidRenumber>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<InvalidRenumber>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for InvalidRenumberRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[InvalidRenumberRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorldStateDatabaseError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorldStateDatabaseError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:529`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorldStateDatabaseError {
            /// The field `message` in the table `WorldStateDatabaseError`
            pub message: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorldStateDatabaseError {
            fn default() -> Self {
                Self {
                    message: ::core::default::Default::default(),
                }
            }
        }

        impl WorldStateDatabaseError {
            /// Creates a [WorldStateDatabaseErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorldStateDatabaseErrorBuilder<()> {
                WorldStateDatabaseErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorldStateDatabaseError>> for WorldStateDatabaseError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateDatabaseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorldStateDatabaseError>>
            for WorldStateDatabaseError
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorldStateDatabaseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorldStateDatabaseError> for WorldStateDatabaseError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateDatabaseError> {
                WorldStateDatabaseError::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [WorldStateDatabaseError] type.
        ///
        /// Can be created using the [WorldStateDatabaseError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorldStateDatabaseErrorBuilder<State>(State);

        impl WorldStateDatabaseErrorBuilder<()> {
            /// Setter for the [`message` field](WorldStateDatabaseError#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> WorldStateDatabaseErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                WorldStateDatabaseErrorBuilder((value,))
            }
        }

        impl<T0> WorldStateDatabaseErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorldStateDatabaseError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateDatabaseError>
            where
                Self: ::planus::WriteAsOffset<WorldStateDatabaseError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<WorldStateDatabaseError>>
            for WorldStateDatabaseErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorldStateDatabaseError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateDatabaseError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<WorldStateDatabaseError>>
            for WorldStateDatabaseErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorldStateDatabaseError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorldStateDatabaseError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOffset<WorldStateDatabaseError>
            for WorldStateDatabaseErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateDatabaseError> {
                let (v0,) = &self.0;
                WorldStateDatabaseError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorldStateDatabaseError].
        #[derive(Copy, Clone)]
        pub struct WorldStateDatabaseErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorldStateDatabaseErrorRef<'a> {
            /// Getter for the [`message` field](WorldStateDatabaseError#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(0, "WorldStateDatabaseError", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for WorldStateDatabaseErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorldStateDatabaseErrorRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorldStateDatabaseErrorRef<'a>> for WorldStateDatabaseError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorldStateDatabaseErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorldStateDatabaseErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorldStateDatabaseErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorldStateDatabaseErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorldStateDatabaseError>>
            for WorldStateDatabaseError
        {
            type Value = ::planus::Offset<WorldStateDatabaseError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorldStateDatabaseError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorldStateDatabaseErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorldStateDatabaseErrorRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `RollbackRetry` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RollbackRetry` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:533`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RollbackRetry {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for RollbackRetry {
            fn default() -> Self {
                Self {}
            }
        }

        impl RollbackRetry {
            /// Creates a [RollbackRetryBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RollbackRetryBuilder<()> {
                RollbackRetryBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RollbackRetry>> for RollbackRetry {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RollbackRetry> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RollbackRetry>> for RollbackRetry {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RollbackRetry>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RollbackRetry> for RollbackRetry {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RollbackRetry> {
                RollbackRetry::create(builder)
            }
        }

        /// Builder for serializing an instance of the [RollbackRetry] type.
        ///
        /// Can be created using the [RollbackRetry::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RollbackRetryBuilder<State>(State);

        impl RollbackRetryBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RollbackRetry].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RollbackRetry>
            where
                Self: ::planus::WriteAsOffset<RollbackRetry>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RollbackRetry>> for RollbackRetryBuilder<()> {
            type Prepared = ::planus::Offset<RollbackRetry>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RollbackRetry> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RollbackRetry>> for RollbackRetryBuilder<()> {
            type Prepared = ::planus::Offset<RollbackRetry>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RollbackRetry>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RollbackRetry> for RollbackRetryBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RollbackRetry> {
                RollbackRetry::create(builder)
            }
        }

        /// Reference to a deserialized [RollbackRetry].
        #[derive(Copy, Clone)]
        pub struct RollbackRetryRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RollbackRetryRef<'a> {}

        impl<'a> ::core::fmt::Debug for RollbackRetryRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RollbackRetryRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RollbackRetryRef<'a>> for RollbackRetry {
            type Error = ::planus::Error;

            fn try_from(_value: RollbackRetryRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for RollbackRetryRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RollbackRetryRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RollbackRetryRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RollbackRetry>> for RollbackRetry {
            type Value = ::planus::Offset<RollbackRetry>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RollbackRetry>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RollbackRetryRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RollbackRetryRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorldStateError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorldStateError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:536`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorldStateError {
            /// The field `error` in the table `WorldStateError`
            pub error: self::WorldStateErrorUnion,
        }

        impl WorldStateError {
            /// Creates a [WorldStateErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorldStateErrorBuilder<()> {
                WorldStateErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAsUnion<self::WorldStateErrorUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorldStateErrorUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error.offset());
                        object_writer.write::<_, _, 1>(&prepared_error.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorldStateError>> for WorldStateError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorldStateError>> for WorldStateError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorldStateError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorldStateError> for WorldStateError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateError> {
                WorldStateError::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [WorldStateError] type.
        ///
        /// Can be created using the [WorldStateError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorldStateErrorBuilder<State>(State);

        impl WorldStateErrorBuilder<()> {
            /// Setter for the [`error` field](WorldStateError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> WorldStateErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::WorldStateErrorUnion>,
            {
                WorldStateErrorBuilder((value,))
            }
        }

        impl<T0> WorldStateErrorBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorldStateError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateError>
            where
                Self: ::planus::WriteAsOffset<WorldStateError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorldStateErrorUnion>>
            ::planus::WriteAs<::planus::Offset<WorldStateError>> for WorldStateErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorldStateError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorldStateErrorUnion>>
            ::planus::WriteAsOptional<::planus::Offset<WorldStateError>>
            for WorldStateErrorBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorldStateError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorldStateError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorldStateErrorUnion>>
            ::planus::WriteAsOffset<WorldStateError> for WorldStateErrorBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorldStateError> {
                let (v0,) = &self.0;
                WorldStateError::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorldStateError].
        #[derive(Copy, Clone)]
        pub struct WorldStateErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorldStateErrorRef<'a> {
            /// Getter for the [`error` field](WorldStateError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::WorldStateErrorUnionRef<'a>> {
                self.0.access_union_required(0, "WorldStateError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for WorldStateErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorldStateErrorRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorldStateErrorRef<'a>> for WorldStateError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorldStateErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::core::convert::TryInto::try_into(value.error()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorldStateErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorldStateErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorldStateErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorldStateError>> for WorldStateError {
            type Value = ::planus::Offset<WorldStateError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorldStateError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorldStateErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorldStateErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The enum `HostType` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Enum `HostType` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:544`
        #[derive(
            Copy,
            Clone,
            Debug,
            PartialEq,
            Eq,
            PartialOrd,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        #[repr(u8)]
        pub enum HostType {
            /// The variant `TCP` in the enum `HostType`
            Tcp = 0,

            /// The variant `WebSocket` in the enum `HostType`
            WebSocket = 1,
        }

        impl HostType {
            /// Array containing all valid variants of HostType
            pub const ENUM_VALUES: [Self; 2] = [Self::Tcp, Self::WebSocket];
        }

        impl ::core::convert::TryFrom<u8> for HostType {
            type Error = ::planus::errors::UnknownEnumTagKind;
            #[inline]
            fn try_from(
                value: u8,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind> {
                #[allow(clippy::match_single_binding)]
                match value {
                    0 => ::core::result::Result::Ok(HostType::Tcp),
                    1 => ::core::result::Result::Ok(HostType::WebSocket),

                    _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                        tag: value as i128,
                    }),
                }
            }
        }

        impl ::core::convert::From<HostType> for u8 {
            #[inline]
            fn from(value: HostType) -> Self {
                value as u8
            }
        }

        /// # Safety
        /// The Planus compiler correctly calculates `ALIGNMENT` and `SIZE`.
        unsafe impl ::planus::Primitive for HostType {
            const ALIGNMENT: usize = 1;
            const SIZE: usize = 1;
        }

        impl ::planus::WriteAsPrimitive<HostType> for HostType {
            #[inline]
            fn write<const N: usize>(&self, cursor: ::planus::Cursor<'_, N>, buffer_position: u32) {
                (*self as u8).write(cursor, buffer_position);
            }
        }

        impl ::planus::WriteAs<HostType> for HostType {
            type Prepared = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> HostType {
                *self
            }
        }

        impl ::planus::WriteAsDefault<HostType, HostType> for HostType {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
                default: &HostType,
            ) -> ::core::option::Option<HostType> {
                if self == default {
                    ::core::option::Option::None
                } else {
                    ::core::option::Option::Some(*self)
                }
            }
        }

        impl ::planus::WriteAsOptional<HostType> for HostType {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<HostType> {
                ::core::option::Option::Some(*self)
            }
        }

        impl<'buf> ::planus::TableRead<'buf> for HostType {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
            }
        }

        impl<'buf> ::planus::VectorReadInner<'buf> for HostType {
            type Error = ::planus::errors::UnknownEnumTag;
            const STRIDE: usize = 1;
            #[inline]
            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag> {
                let value = unsafe { *buffer.buffer.get_unchecked(offset) };
                let value: ::core::result::Result<Self, _> =
                    ::core::convert::TryInto::try_into(value);
                value.map_err(|error_kind| {
                    error_kind.with_error_location(
                        "HostType",
                        "VectorRead::from_buffer",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<HostType> for HostType {
            const STRIDE: usize = 1;

            type Value = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                *self
            }

            #[inline]
            unsafe fn write_values(
                values: &[Self],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - i as u32,
                    );
                }
            }
        }

        /// The enum `ConnectType` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Enum `ConnectType` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:549`
        #[derive(
            Copy,
            Clone,
            Debug,
            PartialEq,
            Eq,
            PartialOrd,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        #[repr(u8)]
        pub enum ConnectType {
            /// The variant `Connected` in the enum `ConnectType`
            Connected = 0,

            /// The variant `Reconnected` in the enum `ConnectType`
            Reconnected = 1,

            /// The variant `Created` in the enum `ConnectType`
            Created = 2,
        }

        impl ConnectType {
            /// Array containing all valid variants of ConnectType
            pub const ENUM_VALUES: [Self; 3] = [Self::Connected, Self::Reconnected, Self::Created];
        }

        impl ::core::convert::TryFrom<u8> for ConnectType {
            type Error = ::planus::errors::UnknownEnumTagKind;
            #[inline]
            fn try_from(
                value: u8,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind> {
                #[allow(clippy::match_single_binding)]
                match value {
                    0 => ::core::result::Result::Ok(ConnectType::Connected),
                    1 => ::core::result::Result::Ok(ConnectType::Reconnected),
                    2 => ::core::result::Result::Ok(ConnectType::Created),

                    _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                        tag: value as i128,
                    }),
                }
            }
        }

        impl ::core::convert::From<ConnectType> for u8 {
            #[inline]
            fn from(value: ConnectType) -> Self {
                value as u8
            }
        }

        /// # Safety
        /// The Planus compiler correctly calculates `ALIGNMENT` and `SIZE`.
        unsafe impl ::planus::Primitive for ConnectType {
            const ALIGNMENT: usize = 1;
            const SIZE: usize = 1;
        }

        impl ::planus::WriteAsPrimitive<ConnectType> for ConnectType {
            #[inline]
            fn write<const N: usize>(&self, cursor: ::planus::Cursor<'_, N>, buffer_position: u32) {
                (*self as u8).write(cursor, buffer_position);
            }
        }

        impl ::planus::WriteAs<ConnectType> for ConnectType {
            type Prepared = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> ConnectType {
                *self
            }
        }

        impl ::planus::WriteAsDefault<ConnectType, ConnectType> for ConnectType {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
                default: &ConnectType,
            ) -> ::core::option::Option<ConnectType> {
                if self == default {
                    ::core::option::Option::None
                } else {
                    ::core::option::Option::Some(*self)
                }
            }
        }

        impl ::planus::WriteAsOptional<ConnectType> for ConnectType {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<ConnectType> {
                ::core::option::Option::Some(*self)
            }
        }

        impl<'buf> ::planus::TableRead<'buf> for ConnectType {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
            }
        }

        impl<'buf> ::planus::VectorReadInner<'buf> for ConnectType {
            type Error = ::planus::errors::UnknownEnumTag;
            const STRIDE: usize = 1;
            #[inline]
            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag> {
                let value = unsafe { *buffer.buffer.get_unchecked(offset) };
                let value: ::core::result::Result<Self, _> =
                    ::core::convert::TryInto::try_into(value);
                value.map_err(|error_kind| {
                    error_kind.with_error_location(
                        "ConnectType",
                        "VectorRead::from_buffer",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<ConnectType> for ConnectType {
            const STRIDE: usize = 1;

            type Value = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                *self
            }

            #[inline]
            unsafe fn write_values(
                values: &[Self],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - i as u32,
                    );
                }
            }
        }

        /// The enum `EntityType` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Enum `EntityType` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:555`
        #[derive(
            Copy,
            Clone,
            Debug,
            PartialEq,
            Eq,
            PartialOrd,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        #[repr(u8)]
        pub enum EntityType {
            /// The variant `Property` in the enum `EntityType`
            Property = 0,

            /// The variant `Verb` in the enum `EntityType`
            Verb = 1,
        }

        impl EntityType {
            /// Array containing all valid variants of EntityType
            pub const ENUM_VALUES: [Self; 2] = [Self::Property, Self::Verb];
        }

        impl ::core::convert::TryFrom<u8> for EntityType {
            type Error = ::planus::errors::UnknownEnumTagKind;
            #[inline]
            fn try_from(
                value: u8,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind> {
                #[allow(clippy::match_single_binding)]
                match value {
                    0 => ::core::result::Result::Ok(EntityType::Property),
                    1 => ::core::result::Result::Ok(EntityType::Verb),

                    _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                        tag: value as i128,
                    }),
                }
            }
        }

        impl ::core::convert::From<EntityType> for u8 {
            #[inline]
            fn from(value: EntityType) -> Self {
                value as u8
            }
        }

        /// # Safety
        /// The Planus compiler correctly calculates `ALIGNMENT` and `SIZE`.
        unsafe impl ::planus::Primitive for EntityType {
            const ALIGNMENT: usize = 1;
            const SIZE: usize = 1;
        }

        impl ::planus::WriteAsPrimitive<EntityType> for EntityType {
            #[inline]
            fn write<const N: usize>(&self, cursor: ::planus::Cursor<'_, N>, buffer_position: u32) {
                (*self as u8).write(cursor, buffer_position);
            }
        }

        impl ::planus::WriteAs<EntityType> for EntityType {
            type Prepared = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> EntityType {
                *self
            }
        }

        impl ::planus::WriteAsDefault<EntityType, EntityType> for EntityType {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
                default: &EntityType,
            ) -> ::core::option::Option<EntityType> {
                if self == default {
                    ::core::option::Option::None
                } else {
                    ::core::option::Option::Some(*self)
                }
            }
        }

        impl ::planus::WriteAsOptional<EntityType> for EntityType {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<EntityType> {
                ::core::option::Option::Some(*self)
            }
        }

        impl<'buf> ::planus::TableRead<'buf> for EntityType {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
            }
        }

        impl<'buf> ::planus::VectorReadInner<'buf> for EntityType {
            type Error = ::planus::errors::UnknownEnumTag;
            const STRIDE: usize = 1;
            #[inline]
            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag> {
                let value = unsafe { *buffer.buffer.get_unchecked(offset) };
                let value: ::core::result::Result<Self, _> =
                    ::core::convert::TryInto::try_into(value);
                value.map_err(|error_kind| {
                    error_kind.with_error_location(
                        "EntityType",
                        "VectorRead::from_buffer",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<EntityType> for EntityType {
            const STRIDE: usize = 1;

            type Value = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                *self
            }

            #[inline]
            unsafe fn write_values(
                values: &[Self],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - i as u32,
                    );
                }
            }
        }

        /// The union `ObjectRefUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `ObjectRefUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:564`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum ObjectRefUnion {
            /// The variant of type `ObjectRefId` in the union `ObjectRefUnion`
            ObjectRefId(::planus::alloc::boxed::Box<self::ObjectRefId>),

            /// The variant of type `ObjectRefSysObj` in the union `ObjectRefUnion`
            ObjectRefSysObj(::planus::alloc::boxed::Box<self::ObjectRefSysObj>),

            /// The variant of type `ObjectRefMatch` in the union `ObjectRefUnion`
            ObjectRefMatch(::planus::alloc::boxed::Box<self::ObjectRefMatch>),
        }

        impl ObjectRefUnion {
            /// Creates a [ObjectRefUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectRefUnionBuilder<::planus::Uninitialized> {
                ObjectRefUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_object_ref_id(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectRefId>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_object_ref_sys_obj(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectRefSysObj>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_object_ref_match(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ObjectRefMatch>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<ObjectRefUnion> for ObjectRefUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::ObjectRefId(value) => Self::create_object_ref_id(builder, value),
                    Self::ObjectRefSysObj(value) => Self::create_object_ref_sys_obj(builder, value),
                    Self::ObjectRefMatch(value) => Self::create_object_ref_match(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<ObjectRefUnion> for ObjectRefUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [ObjectRefUnion] type.
        ///
        /// Can be created using the [ObjectRefUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectRefUnionBuilder<T>(T);

        impl ObjectRefUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`ObjectRefId` variant](ObjectRefUnion#variant.ObjectRefId).
            #[inline]
            pub fn object_ref_id<T>(
                self,
                value: T,
            ) -> ObjectRefUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectRefId>,
            {
                ObjectRefUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ObjectRefSysObj` variant](ObjectRefUnion#variant.ObjectRefSysObj).
            #[inline]
            pub fn object_ref_sys_obj<T>(
                self,
                value: T,
            ) -> ObjectRefUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectRefSysObj>,
            {
                ObjectRefUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ObjectRefMatch` variant](ObjectRefUnion#variant.ObjectRefMatch).
            #[inline]
            pub fn object_ref_match<T>(
                self,
                value: T,
            ) -> ObjectRefUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::ObjectRefMatch>,
            {
                ObjectRefUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> ObjectRefUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [ObjectRefUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ObjectRefUnion>
            where
                Self: ::planus::WriteAsUnion<ObjectRefUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefId>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ObjectRefUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefId>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjectRefUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefSysObj>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ObjectRefUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefSysObj>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjectRefUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ObjectRefUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ObjectRefUnion>
            for ObjectRefUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::ObjectRefMatch>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ObjectRefUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [ObjectRefUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum ObjectRefUnionRef<'a> {
            ObjectRefId(self::ObjectRefIdRef<'a>),
            ObjectRefSysObj(self::ObjectRefSysObjRef<'a>),
            ObjectRefMatch(self::ObjectRefMatchRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<ObjectRefUnionRef<'a>> for ObjectRefUnion {
            type Error = ::planus::Error;

            fn try_from(value: ObjectRefUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    ObjectRefUnionRef::ObjectRefId(value) => {
                        Self::ObjectRefId(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ObjectRefUnionRef::ObjectRefSysObj(value) => {
                        Self::ObjectRefSysObj(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ObjectRefUnionRef::ObjectRefMatch(value) => {
                        Self::ObjectRefMatch(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for ObjectRefUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::ObjectRefId(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::ObjectRefSysObj(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::ObjectRefMatch(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for ObjectRefUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[ObjectRefUnionRef]";
        }

        /// The table `ObjectRefId` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ObjectRefId` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:570`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectRefId {
            /// The field `obj` in the table `ObjectRefId`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
        }

        impl ObjectRefId {
            /// Creates a [ObjectRefIdBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectRefIdBuilder<()> {
                ObjectRefIdBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectRefId>> for ObjectRefId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectRefId>> for ObjectRefId {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectRefId> for ObjectRefId {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefId> {
                ObjectRefId::create(builder, &self.obj)
            }
        }

        /// Builder for serializing an instance of the [ObjectRefId] type.
        ///
        /// Can be created using the [ObjectRefId::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectRefIdBuilder<State>(State);

        impl ObjectRefIdBuilder<()> {
            /// Setter for the [`obj` field](ObjectRefId#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> ObjectRefIdBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                ObjectRefIdBuilder((value,))
            }
        }

        impl<T0> ObjectRefIdBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectRefId].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefId>
            where
                Self: ::planus::WriteAsOffset<ObjectRefId>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAs<::planus::Offset<ObjectRefId>> for ObjectRefIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefId>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefId> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectRefId>> for ObjectRefIdBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefId>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefId>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Obj>>>
            ::planus::WriteAsOffset<ObjectRefId> for ObjectRefIdBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefId> {
                let (v0,) = &self.0;
                ObjectRefId::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectRefId].
        #[derive(Copy, Clone)]
        pub struct ObjectRefIdRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectRefIdRef<'a> {
            /// Getter for the [`obj` field](ObjectRefId#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "ObjectRefId", "obj")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectRefIdRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectRefIdRef");
                f.field("obj", &self.obj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectRefIdRef<'a>> for ObjectRefId {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectRefIdRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectRefIdRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectRefIdRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectRefIdRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectRefId>> for ObjectRefId {
            type Value = ::planus::Offset<ObjectRefId>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectRefId>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectRefIdRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectRefIdRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectRefSysObj` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ObjectRefSysObj` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:574`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectRefSysObj {
            /// The field `symbols` in the table `ObjectRefSysObj`
            pub symbols: ::planus::alloc::vec::Vec<self::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ObjectRefSysObj {
            fn default() -> Self {
                Self {
                    symbols: ::core::default::Default::default(),
                }
            }
        }

        impl ObjectRefSysObj {
            /// Creates a [ObjectRefSysObjBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectRefSysObjBuilder<()> {
                ObjectRefSysObjBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_symbols: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::Symbol>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_symbols = field_symbols.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Symbol>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_symbols);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectRefSysObj>> for ObjectRefSysObj {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectRefSysObj> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectRefSysObj>> for ObjectRefSysObj {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefSysObj>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectRefSysObj> for ObjectRefSysObj {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectRefSysObj> {
                ObjectRefSysObj::create(builder, &self.symbols)
            }
        }

        /// Builder for serializing an instance of the [ObjectRefSysObj] type.
        ///
        /// Can be created using the [ObjectRefSysObj::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectRefSysObjBuilder<State>(State);

        impl ObjectRefSysObjBuilder<()> {
            /// Setter for the [`symbols` field](ObjectRefSysObj#structfield.symbols).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn symbols<T0>(self, value: T0) -> ObjectRefSysObjBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            {
                ObjectRefSysObjBuilder((value,))
            }
        }

        impl<T0> ObjectRefSysObjBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectRefSysObj].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectRefSysObj>
            where
                Self: ::planus::WriteAsOffset<ObjectRefSysObj>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>>
            ::planus::WriteAs<::planus::Offset<ObjectRefSysObj>> for ObjectRefSysObjBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefSysObj>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectRefSysObj> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectRefSysObj>>
            for ObjectRefSysObjBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefSysObj>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefSysObj>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>>
            ::planus::WriteAsOffset<ObjectRefSysObj> for ObjectRefSysObjBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ObjectRefSysObj> {
                let (v0,) = &self.0;
                ObjectRefSysObj::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectRefSysObj].
        #[derive(Copy, Clone)]
        pub struct ObjectRefSysObjRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectRefSysObjRef<'a> {
            /// Getter for the [`symbols` field](ObjectRefSysObj#structfield.symbols).
            #[inline]
            pub fn symbols(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::SymbolRef<'a>>>>
            {
                self.0.access_required(0, "ObjectRefSysObj", "symbols")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectRefSysObjRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectRefSysObjRef");
                f.field("symbols", &self.symbols());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectRefSysObjRef<'a>> for ObjectRefSysObj {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectRefSysObjRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    symbols: value.symbols()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectRefSysObjRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectRefSysObjRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectRefSysObjRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectRefSysObj>> for ObjectRefSysObj {
            type Value = ::planus::Offset<ObjectRefSysObj>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectRefSysObj>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectRefSysObjRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectRefSysObjRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectRefMatch` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ObjectRefMatch` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:578`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectRefMatch {
            /// The field `match_string` in the table `ObjectRefMatch`
            pub match_string: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ObjectRefMatch {
            fn default() -> Self {
                Self {
                    match_string: ::core::default::Default::default(),
                }
            }
        }

        impl ObjectRefMatch {
            /// Creates a [ObjectRefMatchBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectRefMatchBuilder<()> {
                ObjectRefMatchBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_match_string: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_match_string = field_match_string.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_match_string);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectRefMatch>> for ObjectRefMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectRefMatch>> for ObjectRefMatch {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectRefMatch> for ObjectRefMatch {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefMatch> {
                ObjectRefMatch::create(builder, &self.match_string)
            }
        }

        /// Builder for serializing an instance of the [ObjectRefMatch] type.
        ///
        /// Can be created using the [ObjectRefMatch::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectRefMatchBuilder<State>(State);

        impl ObjectRefMatchBuilder<()> {
            /// Setter for the [`match_string` field](ObjectRefMatch#structfield.match_string).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn match_string<T0>(self, value: T0) -> ObjectRefMatchBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                ObjectRefMatchBuilder((value,))
            }
        }

        impl<T0> ObjectRefMatchBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectRefMatch].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefMatch>
            where
                Self: ::planus::WriteAsOffset<ObjectRefMatch>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<ObjectRefMatch>> for ObjectRefMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefMatch>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefMatch> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectRefMatch>>
            for ObjectRefMatchBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRefMatch>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRefMatch>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<ObjectRefMatch>
            for ObjectRefMatchBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRefMatch> {
                let (v0,) = &self.0;
                ObjectRefMatch::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectRefMatch].
        #[derive(Copy, Clone)]
        pub struct ObjectRefMatchRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectRefMatchRef<'a> {
            /// Getter for the [`match_string` field](ObjectRefMatch#structfield.match_string).
            #[inline]
            pub fn match_string(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "ObjectRefMatch", "match_string")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectRefMatchRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectRefMatchRef");
                f.field("match_string", &self.match_string());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectRefMatchRef<'a>> for ObjectRefMatch {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectRefMatchRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    match_string: ::core::convert::Into::into(value.match_string()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectRefMatchRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectRefMatchRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectRefMatchRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectRefMatch>> for ObjectRefMatch {
            type Value = ::planus::Offset<ObjectRefMatch>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectRefMatch>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectRefMatchRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectRefMatchRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ObjectRef` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ObjectRef` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:582`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ObjectRef {
            /// The field `ref` in the table `ObjectRef`
            pub ref_: self::ObjectRefUnion,
        }

        impl ObjectRef {
            /// Creates a [ObjectRefBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ObjectRefBuilder<()> {
                ObjectRefBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_ref_: impl ::planus::WriteAsUnion<self::ObjectRefUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_ref_ = field_ref_.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ObjectRefUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_ref_.offset());
                        object_writer.write::<_, _, 1>(&prepared_ref_.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ObjectRef>> for ObjectRef {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRef> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ObjectRef>> for ObjectRef {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRef>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ObjectRef> for ObjectRef {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRef> {
                ObjectRef::create(builder, &self.ref_)
            }
        }

        /// Builder for serializing an instance of the [ObjectRef] type.
        ///
        /// Can be created using the [ObjectRef::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ObjectRefBuilder<State>(State);

        impl ObjectRefBuilder<()> {
            /// Setter for the [`ref` field](ObjectRef#structfield.ref_).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn ref_<T0>(self, value: T0) -> ObjectRefBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::ObjectRefUnion>,
            {
                ObjectRefBuilder((value,))
            }
        }

        impl<T0> ObjectRefBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ObjectRef].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRef>
            where
                Self: ::planus::WriteAsOffset<ObjectRef>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjectRefUnion>>
            ::planus::WriteAs<::planus::Offset<ObjectRef>> for ObjectRefBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRef>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRef> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjectRefUnion>>
            ::planus::WriteAsOptional<::planus::Offset<ObjectRef>> for ObjectRefBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ObjectRef>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ObjectRef>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ObjectRefUnion>> ::planus::WriteAsOffset<ObjectRef>
            for ObjectRefBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ObjectRef> {
                let (v0,) = &self.0;
                ObjectRef::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ObjectRef].
        #[derive(Copy, Clone)]
        pub struct ObjectRefRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ObjectRefRef<'a> {
            /// Getter for the [`ref` field](ObjectRef#structfield.ref_).
            #[inline]
            pub fn ref_(&self) -> ::planus::Result<self::ObjectRefUnionRef<'a>> {
                self.0.access_union_required(0, "ObjectRef", "ref_")
            }
        }

        impl<'a> ::core::fmt::Debug for ObjectRefRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ObjectRefRef");
                f.field("ref_", &self.ref_());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ObjectRefRef<'a>> for ObjectRef {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ObjectRefRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    ref_: ::core::convert::TryInto::try_into(value.ref_()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ObjectRefRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ObjectRefRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ObjectRefRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ObjectRef>> for ObjectRef {
            type Value = ::planus::Offset<ObjectRef>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ObjectRef>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ObjectRefRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ObjectRefRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PropInfo` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PropInfo` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:590`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropInfo {
            /// The field `definer` in the table `PropInfo`
            pub definer: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `location` in the table `PropInfo`
            pub location: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `name` in the table `PropInfo`
            pub name: ::planus::alloc::boxed::Box<self::Symbol>,
            /// The field `owner` in the table `PropInfo`
            pub owner: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `r` in the table `PropInfo`
            pub r: bool,
            /// The field `w` in the table `PropInfo`
            pub w: bool,
            /// The field `chown` in the table `PropInfo`
            pub chown: bool,
        }

        impl PropInfo {
            /// Creates a [PropInfoBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropInfoBuilder<()> {
                PropInfoBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_definer: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_location: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_name: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
                field_owner: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_r: impl ::planus::WriteAsDefault<bool, bool>,
                field_w: impl ::planus::WriteAsDefault<bool, bool>,
                field_chown: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_definer = field_definer.prepare(builder);
                let prepared_location = field_location.prepare(builder);
                let prepared_name = field_name.prepare(builder);
                let prepared_owner = field_owner.prepare(builder);
                let prepared_r = field_r.prepare(builder, &false);
                let prepared_w = field_w.prepare(builder, &false);
                let prepared_chown = field_chown.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<18> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(2);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(3);
                if prepared_r.is_some() {
                    table_writer.write_entry::<bool>(4);
                }
                if prepared_w.is_some() {
                    table_writer.write_entry::<bool>(5);
                }
                if prepared_chown.is_some() {
                    table_writer.write_entry::<bool>(6);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_definer);
                        object_writer.write::<_, _, 4>(&prepared_location);
                        object_writer.write::<_, _, 4>(&prepared_name);
                        object_writer.write::<_, _, 4>(&prepared_owner);
                        if let ::core::option::Option::Some(prepared_r) = prepared_r {
                            object_writer.write::<_, _, 1>(&prepared_r);
                        }
                        if let ::core::option::Option::Some(prepared_w) = prepared_w {
                            object_writer.write::<_, _, 1>(&prepared_w);
                        }
                        if let ::core::option::Option::Some(prepared_chown) = prepared_chown {
                            object_writer.write::<_, _, 1>(&prepared_chown);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropInfo>> for PropInfo {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropInfo> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropInfo>> for PropInfo {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropInfo>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropInfo> for PropInfo {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropInfo> {
                PropInfo::create(
                    builder,
                    &self.definer,
                    &self.location,
                    &self.name,
                    &self.owner,
                    self.r,
                    self.w,
                    self.chown,
                )
            }
        }

        /// Builder for serializing an instance of the [PropInfo] type.
        ///
        /// Can be created using the [PropInfo::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropInfoBuilder<State>(State);

        impl PropInfoBuilder<()> {
            /// Setter for the [`definer` field](PropInfo#structfield.definer).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn definer<T0>(self, value: T0) -> PropInfoBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                PropInfoBuilder((value,))
            }
        }

        impl<T0> PropInfoBuilder<(T0,)> {
            /// Setter for the [`location` field](PropInfo#structfield.location).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn location<T1>(self, value: T1) -> PropInfoBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                PropInfoBuilder((v0, value))
            }
        }

        impl<T0, T1> PropInfoBuilder<(T0, T1)> {
            /// Setter for the [`name` field](PropInfo#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T2>(self, value: T2) -> PropInfoBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0, v1) = self.0;
                PropInfoBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> PropInfoBuilder<(T0, T1, T2)> {
            /// Setter for the [`owner` field](PropInfo#structfield.owner).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn owner<T3>(self, value: T3) -> PropInfoBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1, v2) = self.0;
                PropInfoBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> PropInfoBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`r` field](PropInfo#structfield.r).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn r<T4>(self, value: T4) -> PropInfoBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3) = self.0;
                PropInfoBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`r` field](PropInfo#structfield.r) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn r_as_default(self) -> PropInfoBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.r(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> PropInfoBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`w` field](PropInfo#structfield.w).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn w<T5>(self, value: T5) -> PropInfoBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                PropInfoBuilder((v0, v1, v2, v3, v4, value))
            }

            /// Sets the [`w` field](PropInfo#structfield.w) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn w_as_default(
                self,
            ) -> PropInfoBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                self.w(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5> PropInfoBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Setter for the [`chown` field](PropInfo#structfield.chown).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn chown<T6>(self, value: T6) -> PropInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            where
                T6: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3, v4, v5) = self.0;
                PropInfoBuilder((v0, v1, v2, v3, v4, v5, value))
            }

            /// Sets the [`chown` field](PropInfo#structfield.chown) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn chown_as_default(
                self,
            ) -> PropInfoBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)> {
                self.chown(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6> PropInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropInfo].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropInfo>
            where
                Self: ::planus::WriteAsOffset<PropInfo>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAs<::planus::Offset<PropInfo>>
            for PropInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            type Prepared = ::planus::Offset<PropInfo>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropInfo> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOptional<::planus::Offset<PropInfo>>
            for PropInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            type Prepared = ::planus::Offset<PropInfo>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropInfo>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOffset<PropInfo> for PropInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropInfo> {
                let (v0, v1, v2, v3, v4, v5, v6) = &self.0;
                PropInfo::create(builder, v0, v1, v2, v3, v4, v5, v6)
            }
        }

        /// Reference to a deserialized [PropInfo].
        #[derive(Copy, Clone)]
        pub struct PropInfoRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropInfoRef<'a> {
            /// Getter for the [`definer` field](PropInfo#structfield.definer).
            #[inline]
            pub fn definer(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "PropInfo", "definer")
            }

            /// Getter for the [`location` field](PropInfo#structfield.location).
            #[inline]
            pub fn location(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "PropInfo", "location")
            }

            /// Getter for the [`name` field](PropInfo#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(2, "PropInfo", "name")
            }

            /// Getter for the [`owner` field](PropInfo#structfield.owner).
            #[inline]
            pub fn owner(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(3, "PropInfo", "owner")
            }

            /// Getter for the [`r` field](PropInfo#structfield.r).
            #[inline]
            pub fn r(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(4, "PropInfo", "r")?.unwrap_or(false))
            }

            /// Getter for the [`w` field](PropInfo#structfield.w).
            #[inline]
            pub fn w(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(5, "PropInfo", "w")?.unwrap_or(false))
            }

            /// Getter for the [`chown` field](PropInfo#structfield.chown).
            #[inline]
            pub fn chown(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(6, "PropInfo", "chown")?.unwrap_or(false))
            }
        }

        impl<'a> ::core::fmt::Debug for PropInfoRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropInfoRef");
                f.field("definer", &self.definer());
                f.field("location", &self.location());
                f.field("name", &self.name());
                f.field("owner", &self.owner());
                f.field("r", &self.r());
                f.field("w", &self.w());
                f.field("chown", &self.chown());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropInfoRef<'a>> for PropInfo {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropInfoRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    definer: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.definer()?,
                    )?),
                    location: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.location()?,
                    )?),
                    name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.name()?,
                    )?),
                    owner: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.owner()?,
                    )?),
                    r: ::core::convert::TryInto::try_into(value.r()?)?,
                    w: ::core::convert::TryInto::try_into(value.w()?)?,
                    chown: ::core::convert::TryInto::try_into(value.chown()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropInfoRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropInfoRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[PropInfoRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropInfo>> for PropInfo {
            type Value = ::planus::Offset<PropInfo>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropInfo>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropInfoRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropInfoRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbInfo` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbInfo` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:600`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbInfo {
            /// The field `location` in the table `VerbInfo`
            pub location: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `owner` in the table `VerbInfo`
            pub owner: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `names` in the table `VerbInfo`
            pub names: ::planus::alloc::vec::Vec<self::Symbol>,
            /// The field `r` in the table `VerbInfo`
            pub r: bool,
            /// The field `w` in the table `VerbInfo`
            pub w: bool,
            /// The field `x` in the table `VerbInfo`
            pub x: bool,
            /// The field `d` in the table `VerbInfo`
            pub d: bool,
            /// The field `arg_spec` in the table `VerbInfo`
            pub arg_spec: ::planus::alloc::vec::Vec<self::Symbol>,
        }

        impl VerbInfo {
            /// Creates a [VerbInfoBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbInfoBuilder<()> {
                VerbInfoBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_location: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_owner: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_names: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
                field_r: impl ::planus::WriteAsDefault<bool, bool>,
                field_w: impl ::planus::WriteAsDefault<bool, bool>,
                field_x: impl ::planus::WriteAsDefault<bool, bool>,
                field_d: impl ::planus::WriteAsDefault<bool, bool>,
                field_arg_spec: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::Symbol>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_location = field_location.prepare(builder);
                let prepared_owner = field_owner.prepare(builder);
                let prepared_names = field_names.prepare(builder);
                let prepared_r = field_r.prepare(builder, &false);
                let prepared_w = field_w.prepare(builder, &false);
                let prepared_x = field_x.prepare(builder, &false);
                let prepared_d = field_d.prepare(builder, &false);
                let prepared_arg_spec = field_arg_spec.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<20> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Symbol>]>>(2);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Symbol>]>>(7);
                if prepared_r.is_some() {
                    table_writer.write_entry::<bool>(3);
                }
                if prepared_w.is_some() {
                    table_writer.write_entry::<bool>(4);
                }
                if prepared_x.is_some() {
                    table_writer.write_entry::<bool>(5);
                }
                if prepared_d.is_some() {
                    table_writer.write_entry::<bool>(6);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_location);
                        object_writer.write::<_, _, 4>(&prepared_owner);
                        object_writer.write::<_, _, 4>(&prepared_names);
                        object_writer.write::<_, _, 4>(&prepared_arg_spec);
                        if let ::core::option::Option::Some(prepared_r) = prepared_r {
                            object_writer.write::<_, _, 1>(&prepared_r);
                        }
                        if let ::core::option::Option::Some(prepared_w) = prepared_w {
                            object_writer.write::<_, _, 1>(&prepared_w);
                        }
                        if let ::core::option::Option::Some(prepared_x) = prepared_x {
                            object_writer.write::<_, _, 1>(&prepared_x);
                        }
                        if let ::core::option::Option::Some(prepared_d) = prepared_d {
                            object_writer.write::<_, _, 1>(&prepared_d);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbInfo>> for VerbInfo {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbInfo> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbInfo>> for VerbInfo {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbInfo>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbInfo> for VerbInfo {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbInfo> {
                VerbInfo::create(
                    builder,
                    &self.location,
                    &self.owner,
                    &self.names,
                    self.r,
                    self.w,
                    self.x,
                    self.d,
                    &self.arg_spec,
                )
            }
        }

        /// Builder for serializing an instance of the [VerbInfo] type.
        ///
        /// Can be created using the [VerbInfo::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbInfoBuilder<State>(State);

        impl VerbInfoBuilder<()> {
            /// Setter for the [`location` field](VerbInfo#structfield.location).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn location<T0>(self, value: T0) -> VerbInfoBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                VerbInfoBuilder((value,))
            }
        }

        impl<T0> VerbInfoBuilder<(T0,)> {
            /// Setter for the [`owner` field](VerbInfo#structfield.owner).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn owner<T1>(self, value: T1) -> VerbInfoBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                VerbInfoBuilder((v0, value))
            }
        }

        impl<T0, T1> VerbInfoBuilder<(T0, T1)> {
            /// Setter for the [`names` field](VerbInfo#structfield.names).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn names<T2>(self, value: T2) -> VerbInfoBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            {
                let (v0, v1) = self.0;
                VerbInfoBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> VerbInfoBuilder<(T0, T1, T2)> {
            /// Setter for the [`r` field](VerbInfo#structfield.r).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn r<T3>(self, value: T3) -> VerbInfoBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2) = self.0;
                VerbInfoBuilder((v0, v1, v2, value))
            }

            /// Sets the [`r` field](VerbInfo#structfield.r) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn r_as_default(self) -> VerbInfoBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.r(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> VerbInfoBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`w` field](VerbInfo#structfield.w).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn w<T4>(self, value: T4) -> VerbInfoBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3) = self.0;
                VerbInfoBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`w` field](VerbInfo#structfield.w) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn w_as_default(self) -> VerbInfoBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.w(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> VerbInfoBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`x` field](VerbInfo#structfield.x).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn x<T5>(self, value: T5) -> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                VerbInfoBuilder((v0, v1, v2, v3, v4, value))
            }

            /// Sets the [`x` field](VerbInfo#structfield.x) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn x_as_default(
                self,
            ) -> VerbInfoBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                self.x(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Setter for the [`d` field](VerbInfo#structfield.d).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn d<T6>(self, value: T6) -> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            where
                T6: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3, v4, v5) = self.0;
                VerbInfoBuilder((v0, v1, v2, v3, v4, v5, value))
            }

            /// Sets the [`d` field](VerbInfo#structfield.d) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn d_as_default(
                self,
            ) -> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)> {
                self.d(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
            /// Setter for the [`arg_spec` field](VerbInfo#structfield.arg_spec).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn arg_spec<T7>(
                self,
                value: T7,
            ) -> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            where
                T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            {
                let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                VerbInfoBuilder((v0, v1, v2, v3, v4, v5, v6, value))
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7> VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbInfo].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbInfo>
            where
                Self: ::planus::WriteAsOffset<VerbInfo>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
            T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
        > ::planus::WriteAs<::planus::Offset<VerbInfo>>
            for VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
        {
            type Prepared = ::planus::Offset<VerbInfo>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbInfo> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
            T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<VerbInfo>>
            for VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
        {
            type Prepared = ::planus::Offset<VerbInfo>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbInfo>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsDefault<bool, bool>,
            T6: ::planus::WriteAsDefault<bool, bool>,
            T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
        > ::planus::WriteAsOffset<VerbInfo> for VerbInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbInfo> {
                let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                VerbInfo::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
            }
        }

        /// Reference to a deserialized [VerbInfo].
        #[derive(Copy, Clone)]
        pub struct VerbInfoRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbInfoRef<'a> {
            /// Getter for the [`location` field](VerbInfo#structfield.location).
            #[inline]
            pub fn location(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "VerbInfo", "location")
            }

            /// Getter for the [`owner` field](VerbInfo#structfield.owner).
            #[inline]
            pub fn owner(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "VerbInfo", "owner")
            }

            /// Getter for the [`names` field](VerbInfo#structfield.names).
            #[inline]
            pub fn names(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::SymbolRef<'a>>>>
            {
                self.0.access_required(2, "VerbInfo", "names")
            }

            /// Getter for the [`r` field](VerbInfo#structfield.r).
            #[inline]
            pub fn r(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(3, "VerbInfo", "r")?.unwrap_or(false))
            }

            /// Getter for the [`w` field](VerbInfo#structfield.w).
            #[inline]
            pub fn w(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(4, "VerbInfo", "w")?.unwrap_or(false))
            }

            /// Getter for the [`x` field](VerbInfo#structfield.x).
            #[inline]
            pub fn x(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(5, "VerbInfo", "x")?.unwrap_or(false))
            }

            /// Getter for the [`d` field](VerbInfo#structfield.d).
            #[inline]
            pub fn d(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(6, "VerbInfo", "d")?.unwrap_or(false))
            }

            /// Getter for the [`arg_spec` field](VerbInfo#structfield.arg_spec).
            #[inline]
            pub fn arg_spec(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::SymbolRef<'a>>>>
            {
                self.0.access_required(7, "VerbInfo", "arg_spec")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbInfoRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbInfoRef");
                f.field("location", &self.location());
                f.field("owner", &self.owner());
                f.field("names", &self.names());
                f.field("r", &self.r());
                f.field("w", &self.w());
                f.field("x", &self.x());
                f.field("d", &self.d());
                f.field("arg_spec", &self.arg_spec());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbInfoRef<'a>> for VerbInfo {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbInfoRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    location: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.location()?,
                    )?),
                    owner: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.owner()?,
                    )?),
                    names: value.names()?.to_vec_result()?,
                    r: ::core::convert::TryInto::try_into(value.r()?)?,
                    w: ::core::convert::TryInto::try_into(value.w()?)?,
                    x: ::core::convert::TryInto::try_into(value.x()?)?,
                    d: ::core::convert::TryInto::try_into(value.d()?)?,
                    arg_spec: value.arg_spec()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbInfoRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbInfoRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VerbInfoRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbInfo>> for VerbInfo {
            type Value = ::planus::Offset<VerbInfo>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbInfo>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbInfoRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbInfoRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `HistoryRecallUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `HistoryRecallUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:615`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum HistoryRecallUnion {
            /// The variant of type `HistoryRecallSinceEvent` in the union `HistoryRecallUnion`
            HistoryRecallSinceEvent(::planus::alloc::boxed::Box<self::HistoryRecallSinceEvent>),

            /// The variant of type `HistoryRecallUntilEvent` in the union `HistoryRecallUnion`
            HistoryRecallUntilEvent(::planus::alloc::boxed::Box<self::HistoryRecallUntilEvent>),

            /// The variant of type `HistoryRecallSinceSeconds` in the union `HistoryRecallUnion`
            HistoryRecallSinceSeconds(::planus::alloc::boxed::Box<self::HistoryRecallSinceSeconds>),

            /// The variant of type `HistoryRecallNone` in the union `HistoryRecallUnion`
            HistoryRecallNone(::planus::alloc::boxed::Box<self::HistoryRecallNone>),
        }

        impl HistoryRecallUnion {
            /// Creates a [HistoryRecallUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HistoryRecallUnionBuilder<::planus::Uninitialized> {
                HistoryRecallUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_history_recall_since_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HistoryRecallSinceEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_history_recall_until_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HistoryRecallUntilEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_history_recall_since_seconds(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HistoryRecallSinceSeconds>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_history_recall_none(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HistoryRecallNone>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<HistoryRecallUnion> for HistoryRecallUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::HistoryRecallSinceEvent(value) => {
                        Self::create_history_recall_since_event(builder, value)
                    }
                    Self::HistoryRecallUntilEvent(value) => {
                        Self::create_history_recall_until_event(builder, value)
                    }
                    Self::HistoryRecallSinceSeconds(value) => {
                        Self::create_history_recall_since_seconds(builder, value)
                    }
                    Self::HistoryRecallNone(value) => {
                        Self::create_history_recall_none(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<HistoryRecallUnion> for HistoryRecallUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [HistoryRecallUnion] type.
        ///
        /// Can be created using the [HistoryRecallUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HistoryRecallUnionBuilder<T>(T);

        impl HistoryRecallUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`HistoryRecallSinceEvent` variant](HistoryRecallUnion#variant.HistoryRecallSinceEvent).
            #[inline]
            pub fn history_recall_since_event<T>(
                self,
                value: T,
            ) -> HistoryRecallUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::HistoryRecallSinceEvent>,
            {
                HistoryRecallUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`HistoryRecallUntilEvent` variant](HistoryRecallUnion#variant.HistoryRecallUntilEvent).
            #[inline]
            pub fn history_recall_until_event<T>(
                self,
                value: T,
            ) -> HistoryRecallUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::HistoryRecallUntilEvent>,
            {
                HistoryRecallUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`HistoryRecallSinceSeconds` variant](HistoryRecallUnion#variant.HistoryRecallSinceSeconds).
            #[inline]
            pub fn history_recall_since_seconds<T>(
                self,
                value: T,
            ) -> HistoryRecallUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::HistoryRecallSinceSeconds>,
            {
                HistoryRecallUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`HistoryRecallNone` variant](HistoryRecallUnion#variant.HistoryRecallNone).
            #[inline]
            pub fn history_recall_none<T>(
                self,
                value: T,
            ) -> HistoryRecallUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::HistoryRecallNone>,
            {
                HistoryRecallUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> HistoryRecallUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [HistoryRecallUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HistoryRecallUnion>
            where
                Self: ::planus::WriteAsUnion<HistoryRecallUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<HistoryRecallUnion>
            for HistoryRecallUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::HistoryRecallSinceEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HistoryRecallUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HistoryRecallUnion>
            for HistoryRecallUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::HistoryRecallSinceEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HistoryRecallUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HistoryRecallUnion>
            for HistoryRecallUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::HistoryRecallUntilEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HistoryRecallUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HistoryRecallUnion>
            for HistoryRecallUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::HistoryRecallUntilEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HistoryRecallUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HistoryRecallUnion>
            for HistoryRecallUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::HistoryRecallSinceSeconds>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HistoryRecallUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HistoryRecallUnion>
            for HistoryRecallUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::HistoryRecallSinceSeconds>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HistoryRecallUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HistoryRecallUnion>
            for HistoryRecallUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::HistoryRecallNone>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HistoryRecallUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HistoryRecallUnion>
            for HistoryRecallUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::HistoryRecallNone>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HistoryRecallUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [HistoryRecallUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum HistoryRecallUnionRef<'a> {
            HistoryRecallSinceEvent(self::HistoryRecallSinceEventRef<'a>),
            HistoryRecallUntilEvent(self::HistoryRecallUntilEventRef<'a>),
            HistoryRecallSinceSeconds(self::HistoryRecallSinceSecondsRef<'a>),
            HistoryRecallNone(self::HistoryRecallNoneRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<HistoryRecallUnionRef<'a>> for HistoryRecallUnion {
            type Error = ::planus::Error;

            fn try_from(value: HistoryRecallUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    HistoryRecallUnionRef::HistoryRecallSinceEvent(value) => {
                        Self::HistoryRecallSinceEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HistoryRecallUnionRef::HistoryRecallUntilEvent(value) => {
                        Self::HistoryRecallUntilEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HistoryRecallUnionRef::HistoryRecallSinceSeconds(value) => {
                        Self::HistoryRecallSinceSeconds(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HistoryRecallUnionRef::HistoryRecallNone(value) => {
                        Self::HistoryRecallNone(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for HistoryRecallUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::HistoryRecallSinceEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::HistoryRecallUntilEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::HistoryRecallSinceSeconds(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::HistoryRecallNone(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for HistoryRecallUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[HistoryRecallUnionRef]";
        }

        /// The table `HistoryRecallSinceEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HistoryRecallSinceEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:622`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HistoryRecallSinceEvent {
            /// The field `event_id` in the table `HistoryRecallSinceEvent`
            pub event_id: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `limit` in the table `HistoryRecallSinceEvent`
            pub limit: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for HistoryRecallSinceEvent {
            fn default() -> Self {
                Self {
                    event_id: ::core::default::Default::default(),
                    limit: 0,
                }
            }
        }

        impl HistoryRecallSinceEvent {
            /// Creates a [HistoryRecallSinceEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HistoryRecallSinceEventBuilder<()> {
                HistoryRecallSinceEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_event_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_limit: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_event_id = field_event_id.prepare(builder);
                let prepared_limit = field_limit.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_limit.is_some() {
                    table_writer.write_entry::<u64>(1);
                }
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_limit) = prepared_limit {
                            object_writer.write::<_, _, 8>(&prepared_limit);
                        }
                        object_writer.write::<_, _, 4>(&prepared_event_id);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HistoryRecallSinceEvent>> for HistoryRecallSinceEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallSinceEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HistoryRecallSinceEvent>>
            for HistoryRecallSinceEvent
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryRecallSinceEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HistoryRecallSinceEvent> for HistoryRecallSinceEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallSinceEvent> {
                HistoryRecallSinceEvent::create(builder, &self.event_id, self.limit)
            }
        }

        /// Builder for serializing an instance of the [HistoryRecallSinceEvent] type.
        ///
        /// Can be created using the [HistoryRecallSinceEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HistoryRecallSinceEventBuilder<State>(State);

        impl HistoryRecallSinceEventBuilder<()> {
            /// Setter for the [`event_id` field](HistoryRecallSinceEvent#structfield.event_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event_id<T0>(self, value: T0) -> HistoryRecallSinceEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                HistoryRecallSinceEventBuilder((value,))
            }
        }

        impl<T0> HistoryRecallSinceEventBuilder<(T0,)> {
            /// Setter for the [`limit` field](HistoryRecallSinceEvent#structfield.limit).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn limit<T1>(self, value: T1) -> HistoryRecallSinceEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                HistoryRecallSinceEventBuilder((v0, value))
            }

            /// Sets the [`limit` field](HistoryRecallSinceEvent#structfield.limit) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn limit_as_default(
                self,
            ) -> HistoryRecallSinceEventBuilder<(T0, ::planus::DefaultValue)> {
                self.limit(::planus::DefaultValue)
            }
        }

        impl<T0, T1> HistoryRecallSinceEventBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HistoryRecallSinceEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallSinceEvent>
            where
                Self: ::planus::WriteAsOffset<HistoryRecallSinceEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAs<::planus::Offset<HistoryRecallSinceEvent>>
            for HistoryRecallSinceEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HistoryRecallSinceEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallSinceEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAsOptional<::planus::Offset<HistoryRecallSinceEvent>>
            for HistoryRecallSinceEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HistoryRecallSinceEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryRecallSinceEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAsOffset<HistoryRecallSinceEvent>
            for HistoryRecallSinceEventBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallSinceEvent> {
                let (v0, v1) = &self.0;
                HistoryRecallSinceEvent::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [HistoryRecallSinceEvent].
        #[derive(Copy, Clone)]
        pub struct HistoryRecallSinceEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HistoryRecallSinceEventRef<'a> {
            /// Getter for the [`event_id` field](HistoryRecallSinceEvent#structfield.event_id).
            #[inline]
            pub fn event_id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0
                    .access_required(0, "HistoryRecallSinceEvent", "event_id")
            }

            /// Getter for the [`limit` field](HistoryRecallSinceEvent#structfield.limit).
            #[inline]
            pub fn limit(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "HistoryRecallSinceEvent", "limit")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for HistoryRecallSinceEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HistoryRecallSinceEventRef");
                f.field("event_id", &self.event_id());
                f.field("limit", &self.limit());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HistoryRecallSinceEventRef<'a>> for HistoryRecallSinceEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HistoryRecallSinceEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    event_id: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.event_id()?,
                    )?),
                    limit: ::core::convert::TryInto::try_into(value.limit()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HistoryRecallSinceEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HistoryRecallSinceEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoryRecallSinceEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HistoryRecallSinceEvent>>
            for HistoryRecallSinceEvent
        {
            type Value = ::planus::Offset<HistoryRecallSinceEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HistoryRecallSinceEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HistoryRecallSinceEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoryRecallSinceEventRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `HistoryRecallUntilEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HistoryRecallUntilEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:627`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HistoryRecallUntilEvent {
            /// The field `event_id` in the table `HistoryRecallUntilEvent`
            pub event_id: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `limit` in the table `HistoryRecallUntilEvent`
            pub limit: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for HistoryRecallUntilEvent {
            fn default() -> Self {
                Self {
                    event_id: ::core::default::Default::default(),
                    limit: 0,
                }
            }
        }

        impl HistoryRecallUntilEvent {
            /// Creates a [HistoryRecallUntilEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HistoryRecallUntilEventBuilder<()> {
                HistoryRecallUntilEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_event_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_limit: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_event_id = field_event_id.prepare(builder);
                let prepared_limit = field_limit.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_limit.is_some() {
                    table_writer.write_entry::<u64>(1);
                }
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_limit) = prepared_limit {
                            object_writer.write::<_, _, 8>(&prepared_limit);
                        }
                        object_writer.write::<_, _, 4>(&prepared_event_id);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HistoryRecallUntilEvent>> for HistoryRecallUntilEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallUntilEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HistoryRecallUntilEvent>>
            for HistoryRecallUntilEvent
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryRecallUntilEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HistoryRecallUntilEvent> for HistoryRecallUntilEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallUntilEvent> {
                HistoryRecallUntilEvent::create(builder, &self.event_id, self.limit)
            }
        }

        /// Builder for serializing an instance of the [HistoryRecallUntilEvent] type.
        ///
        /// Can be created using the [HistoryRecallUntilEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HistoryRecallUntilEventBuilder<State>(State);

        impl HistoryRecallUntilEventBuilder<()> {
            /// Setter for the [`event_id` field](HistoryRecallUntilEvent#structfield.event_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event_id<T0>(self, value: T0) -> HistoryRecallUntilEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                HistoryRecallUntilEventBuilder((value,))
            }
        }

        impl<T0> HistoryRecallUntilEventBuilder<(T0,)> {
            /// Setter for the [`limit` field](HistoryRecallUntilEvent#structfield.limit).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn limit<T1>(self, value: T1) -> HistoryRecallUntilEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                HistoryRecallUntilEventBuilder((v0, value))
            }

            /// Sets the [`limit` field](HistoryRecallUntilEvent#structfield.limit) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn limit_as_default(
                self,
            ) -> HistoryRecallUntilEventBuilder<(T0, ::planus::DefaultValue)> {
                self.limit(::planus::DefaultValue)
            }
        }

        impl<T0, T1> HistoryRecallUntilEventBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HistoryRecallUntilEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallUntilEvent>
            where
                Self: ::planus::WriteAsOffset<HistoryRecallUntilEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAs<::planus::Offset<HistoryRecallUntilEvent>>
            for HistoryRecallUntilEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HistoryRecallUntilEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallUntilEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAsOptional<::planus::Offset<HistoryRecallUntilEvent>>
            for HistoryRecallUntilEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HistoryRecallUntilEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryRecallUntilEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAsOffset<HistoryRecallUntilEvent>
            for HistoryRecallUntilEventBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallUntilEvent> {
                let (v0, v1) = &self.0;
                HistoryRecallUntilEvent::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [HistoryRecallUntilEvent].
        #[derive(Copy, Clone)]
        pub struct HistoryRecallUntilEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HistoryRecallUntilEventRef<'a> {
            /// Getter for the [`event_id` field](HistoryRecallUntilEvent#structfield.event_id).
            #[inline]
            pub fn event_id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0
                    .access_required(0, "HistoryRecallUntilEvent", "event_id")
            }

            /// Getter for the [`limit` field](HistoryRecallUntilEvent#structfield.limit).
            #[inline]
            pub fn limit(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "HistoryRecallUntilEvent", "limit")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for HistoryRecallUntilEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HistoryRecallUntilEventRef");
                f.field("event_id", &self.event_id());
                f.field("limit", &self.limit());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HistoryRecallUntilEventRef<'a>> for HistoryRecallUntilEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HistoryRecallUntilEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    event_id: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.event_id()?,
                    )?),
                    limit: ::core::convert::TryInto::try_into(value.limit()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HistoryRecallUntilEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HistoryRecallUntilEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoryRecallUntilEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HistoryRecallUntilEvent>>
            for HistoryRecallUntilEvent
        {
            type Value = ::planus::Offset<HistoryRecallUntilEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HistoryRecallUntilEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HistoryRecallUntilEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoryRecallUntilEventRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `HistoryRecallSinceSeconds` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HistoryRecallSinceSeconds` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:632`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HistoryRecallSinceSeconds {
            /// The field `seconds_ago` in the table `HistoryRecallSinceSeconds`
            pub seconds_ago: u64,
            /// The field `limit` in the table `HistoryRecallSinceSeconds`
            pub limit: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for HistoryRecallSinceSeconds {
            fn default() -> Self {
                Self {
                    seconds_ago: 0,
                    limit: 0,
                }
            }
        }

        impl HistoryRecallSinceSeconds {
            /// Creates a [HistoryRecallSinceSecondsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HistoryRecallSinceSecondsBuilder<()> {
                HistoryRecallSinceSecondsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_seconds_ago: impl ::planus::WriteAsDefault<u64, u64>,
                field_limit: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_seconds_ago = field_seconds_ago.prepare(builder, &0);
                let prepared_limit = field_limit.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_seconds_ago.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                if prepared_limit.is_some() {
                    table_writer.write_entry::<u64>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_seconds_ago) =
                            prepared_seconds_ago
                        {
                            object_writer.write::<_, _, 8>(&prepared_seconds_ago);
                        }
                        if let ::core::option::Option::Some(prepared_limit) = prepared_limit {
                            object_writer.write::<_, _, 8>(&prepared_limit);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HistoryRecallSinceSeconds>> for HistoryRecallSinceSeconds {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallSinceSeconds> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HistoryRecallSinceSeconds>>
            for HistoryRecallSinceSeconds
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryRecallSinceSeconds>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HistoryRecallSinceSeconds> for HistoryRecallSinceSeconds {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallSinceSeconds> {
                HistoryRecallSinceSeconds::create(builder, self.seconds_ago, self.limit)
            }
        }

        /// Builder for serializing an instance of the [HistoryRecallSinceSeconds] type.
        ///
        /// Can be created using the [HistoryRecallSinceSeconds::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HistoryRecallSinceSecondsBuilder<State>(State);

        impl HistoryRecallSinceSecondsBuilder<()> {
            /// Setter for the [`seconds_ago` field](HistoryRecallSinceSeconds#structfield.seconds_ago).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn seconds_ago<T0>(self, value: T0) -> HistoryRecallSinceSecondsBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                HistoryRecallSinceSecondsBuilder((value,))
            }

            /// Sets the [`seconds_ago` field](HistoryRecallSinceSeconds#structfield.seconds_ago) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn seconds_ago_as_default(
                self,
            ) -> HistoryRecallSinceSecondsBuilder<(::planus::DefaultValue,)> {
                self.seconds_ago(::planus::DefaultValue)
            }
        }

        impl<T0> HistoryRecallSinceSecondsBuilder<(T0,)> {
            /// Setter for the [`limit` field](HistoryRecallSinceSeconds#structfield.limit).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn limit<T1>(self, value: T1) -> HistoryRecallSinceSecondsBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                HistoryRecallSinceSecondsBuilder((v0, value))
            }

            /// Sets the [`limit` field](HistoryRecallSinceSeconds#structfield.limit) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn limit_as_default(
                self,
            ) -> HistoryRecallSinceSecondsBuilder<(T0, ::planus::DefaultValue)> {
                self.limit(::planus::DefaultValue)
            }
        }

        impl<T0, T1> HistoryRecallSinceSecondsBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HistoryRecallSinceSeconds].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallSinceSeconds>
            where
                Self: ::planus::WriteAsOffset<HistoryRecallSinceSeconds>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAs<::planus::Offset<HistoryRecallSinceSeconds>>
            for HistoryRecallSinceSecondsBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HistoryRecallSinceSeconds>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallSinceSeconds> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<HistoryRecallSinceSeconds>>
            for HistoryRecallSinceSecondsBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HistoryRecallSinceSeconds>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryRecallSinceSeconds>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>, T1: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOffset<HistoryRecallSinceSeconds>
            for HistoryRecallSinceSecondsBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallSinceSeconds> {
                let (v0, v1) = &self.0;
                HistoryRecallSinceSeconds::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [HistoryRecallSinceSeconds].
        #[derive(Copy, Clone)]
        pub struct HistoryRecallSinceSecondsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HistoryRecallSinceSecondsRef<'a> {
            /// Getter for the [`seconds_ago` field](HistoryRecallSinceSeconds#structfield.seconds_ago).
            #[inline]
            pub fn seconds_ago(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "HistoryRecallSinceSeconds", "seconds_ago")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`limit` field](HistoryRecallSinceSeconds#structfield.limit).
            #[inline]
            pub fn limit(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "HistoryRecallSinceSeconds", "limit")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for HistoryRecallSinceSecondsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HistoryRecallSinceSecondsRef");
                f.field("seconds_ago", &self.seconds_ago());
                f.field("limit", &self.limit());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HistoryRecallSinceSecondsRef<'a>> for HistoryRecallSinceSeconds {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HistoryRecallSinceSecondsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    seconds_ago: ::core::convert::TryInto::try_into(value.seconds_ago()?)?,
                    limit: ::core::convert::TryInto::try_into(value.limit()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HistoryRecallSinceSecondsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HistoryRecallSinceSecondsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoryRecallSinceSecondsRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HistoryRecallSinceSeconds>>
            for HistoryRecallSinceSeconds
        {
            type Value = ::planus::Offset<HistoryRecallSinceSeconds>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HistoryRecallSinceSeconds>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HistoryRecallSinceSecondsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoryRecallSinceSecondsRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `HistoryRecallNone` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HistoryRecallNone` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:637`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HistoryRecallNone {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for HistoryRecallNone {
            fn default() -> Self {
                Self {}
            }
        }

        impl HistoryRecallNone {
            /// Creates a [HistoryRecallNoneBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HistoryRecallNoneBuilder<()> {
                HistoryRecallNoneBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HistoryRecallNone>> for HistoryRecallNone {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallNone> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HistoryRecallNone>> for HistoryRecallNone {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryRecallNone>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HistoryRecallNone> for HistoryRecallNone {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallNone> {
                HistoryRecallNone::create(builder)
            }
        }

        /// Builder for serializing an instance of the [HistoryRecallNone] type.
        ///
        /// Can be created using the [HistoryRecallNone::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HistoryRecallNoneBuilder<State>(State);

        impl HistoryRecallNoneBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HistoryRecallNone].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallNone>
            where
                Self: ::planus::WriteAsOffset<HistoryRecallNone>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HistoryRecallNone>> for HistoryRecallNoneBuilder<()> {
            type Prepared = ::planus::Offset<HistoryRecallNone>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallNone> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HistoryRecallNone>>
            for HistoryRecallNoneBuilder<()>
        {
            type Prepared = ::planus::Offset<HistoryRecallNone>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryRecallNone>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HistoryRecallNone> for HistoryRecallNoneBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryRecallNone> {
                HistoryRecallNone::create(builder)
            }
        }

        /// Reference to a deserialized [HistoryRecallNone].
        #[derive(Copy, Clone)]
        pub struct HistoryRecallNoneRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HistoryRecallNoneRef<'a> {}

        impl<'a> ::core::fmt::Debug for HistoryRecallNoneRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HistoryRecallNoneRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HistoryRecallNoneRef<'a>> for HistoryRecallNone {
            type Error = ::planus::Error;

            fn try_from(_value: HistoryRecallNoneRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for HistoryRecallNoneRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HistoryRecallNoneRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoryRecallNoneRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HistoryRecallNone>> for HistoryRecallNone {
            type Value = ::planus::Offset<HistoryRecallNone>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HistoryRecallNone>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HistoryRecallNoneRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HistoryRecallNoneRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `HistoryRecall` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HistoryRecall` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:640`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HistoryRecall {
            /// The field `recall` in the table `HistoryRecall`
            pub recall: self::HistoryRecallUnion,
        }

        impl HistoryRecall {
            /// Creates a [HistoryRecallBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HistoryRecallBuilder<()> {
                HistoryRecallBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_recall: impl ::planus::WriteAsUnion<self::HistoryRecallUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_recall = field_recall.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::HistoryRecallUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_recall.offset());
                        object_writer.write::<_, _, 1>(&prepared_recall.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HistoryRecall>> for HistoryRecall {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HistoryRecall> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HistoryRecall>> for HistoryRecall {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryRecall>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HistoryRecall> for HistoryRecall {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HistoryRecall> {
                HistoryRecall::create(builder, &self.recall)
            }
        }

        /// Builder for serializing an instance of the [HistoryRecall] type.
        ///
        /// Can be created using the [HistoryRecall::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HistoryRecallBuilder<State>(State);

        impl HistoryRecallBuilder<()> {
            /// Setter for the [`recall` field](HistoryRecall#structfield.recall).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn recall<T0>(self, value: T0) -> HistoryRecallBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::HistoryRecallUnion>,
            {
                HistoryRecallBuilder((value,))
            }
        }

        impl<T0> HistoryRecallBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HistoryRecall].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<HistoryRecall>
            where
                Self: ::planus::WriteAsOffset<HistoryRecall>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HistoryRecallUnion>>
            ::planus::WriteAs<::planus::Offset<HistoryRecall>> for HistoryRecallBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HistoryRecall>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HistoryRecall> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HistoryRecallUnion>>
            ::planus::WriteAsOptional<::planus::Offset<HistoryRecall>>
            for HistoryRecallBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HistoryRecall>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryRecall>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HistoryRecallUnion>>
            ::planus::WriteAsOffset<HistoryRecall> for HistoryRecallBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HistoryRecall> {
                let (v0,) = &self.0;
                HistoryRecall::create(builder, v0)
            }
        }

        /// Reference to a deserialized [HistoryRecall].
        #[derive(Copy, Clone)]
        pub struct HistoryRecallRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HistoryRecallRef<'a> {
            /// Getter for the [`recall` field](HistoryRecall#structfield.recall).
            #[inline]
            pub fn recall(&self) -> ::planus::Result<self::HistoryRecallUnionRef<'a>> {
                self.0.access_union_required(0, "HistoryRecall", "recall")
            }
        }

        impl<'a> ::core::fmt::Debug for HistoryRecallRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HistoryRecallRef");
                f.field("recall", &self.recall());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HistoryRecallRef<'a>> for HistoryRecall {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HistoryRecallRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    recall: ::core::convert::TryInto::try_into(value.recall()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HistoryRecallRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HistoryRecallRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoryRecallRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HistoryRecall>> for HistoryRecall {
            type Value = ::planus::Offset<HistoryRecall>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HistoryRecall>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HistoryRecallRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HistoryRecallRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `HistoricalNarrativeEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HistoricalNarrativeEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:644`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HistoricalNarrativeEvent {
            /// The field `event` in the table `HistoricalNarrativeEvent`
            pub event: ::planus::alloc::boxed::Box<self::NarrativeEvent>,
            /// The field `is_historical` in the table `HistoricalNarrativeEvent`
            pub is_historical: bool,
            /// The field `player` in the table `HistoricalNarrativeEvent`
            pub player: ::planus::alloc::boxed::Box<self::Obj>,
        }

        impl HistoricalNarrativeEvent {
            /// Creates a [HistoricalNarrativeEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HistoricalNarrativeEventBuilder<()> {
                HistoricalNarrativeEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_event: impl ::planus::WriteAs<::planus::Offset<self::NarrativeEvent>>,
                field_is_historical: impl ::planus::WriteAsDefault<bool, bool>,
                field_player: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_event = field_event.prepare(builder);
                let prepared_is_historical = field_is_historical.prepare(builder, &false);
                let prepared_player = field_player.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::NarrativeEvent>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(2);
                if prepared_is_historical.is_some() {
                    table_writer.write_entry::<bool>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_event);
                        object_writer.write::<_, _, 4>(&prepared_player);
                        if let ::core::option::Option::Some(prepared_is_historical) =
                            prepared_is_historical
                        {
                            object_writer.write::<_, _, 1>(&prepared_is_historical);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HistoricalNarrativeEvent>> for HistoricalNarrativeEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoricalNarrativeEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HistoricalNarrativeEvent>>
            for HistoricalNarrativeEvent
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoricalNarrativeEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HistoricalNarrativeEvent> for HistoricalNarrativeEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoricalNarrativeEvent> {
                HistoricalNarrativeEvent::create(
                    builder,
                    &self.event,
                    self.is_historical,
                    &self.player,
                )
            }
        }

        /// Builder for serializing an instance of the [HistoricalNarrativeEvent] type.
        ///
        /// Can be created using the [HistoricalNarrativeEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HistoricalNarrativeEventBuilder<State>(State);

        impl HistoricalNarrativeEventBuilder<()> {
            /// Setter for the [`event` field](HistoricalNarrativeEvent#structfield.event).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event<T0>(self, value: T0) -> HistoricalNarrativeEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::NarrativeEvent>>,
            {
                HistoricalNarrativeEventBuilder((value,))
            }
        }

        impl<T0> HistoricalNarrativeEventBuilder<(T0,)> {
            /// Setter for the [`is_historical` field](HistoricalNarrativeEvent#structfield.is_historical).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn is_historical<T1>(self, value: T1) -> HistoricalNarrativeEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0,) = self.0;
                HistoricalNarrativeEventBuilder((v0, value))
            }

            /// Sets the [`is_historical` field](HistoricalNarrativeEvent#structfield.is_historical) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn is_historical_as_default(
                self,
            ) -> HistoricalNarrativeEventBuilder<(T0, ::planus::DefaultValue)> {
                self.is_historical(::planus::DefaultValue)
            }
        }

        impl<T0, T1> HistoricalNarrativeEventBuilder<(T0, T1)> {
            /// Setter for the [`player` field](HistoricalNarrativeEvent#structfield.player).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn player<T2>(self, value: T2) -> HistoricalNarrativeEventBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1) = self.0;
                HistoricalNarrativeEventBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> HistoricalNarrativeEventBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HistoricalNarrativeEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoricalNarrativeEvent>
            where
                Self: ::planus::WriteAsOffset<HistoricalNarrativeEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::NarrativeEvent>>,
            T1: ::planus::WriteAsDefault<bool, bool>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAs<::planus::Offset<HistoricalNarrativeEvent>>
            for HistoricalNarrativeEventBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<HistoricalNarrativeEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoricalNarrativeEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::NarrativeEvent>>,
            T1: ::planus::WriteAsDefault<bool, bool>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOptional<::planus::Offset<HistoricalNarrativeEvent>>
            for HistoricalNarrativeEventBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<HistoricalNarrativeEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoricalNarrativeEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::NarrativeEvent>>,
            T1: ::planus::WriteAsDefault<bool, bool>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOffset<HistoricalNarrativeEvent>
            for HistoricalNarrativeEventBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoricalNarrativeEvent> {
                let (v0, v1, v2) = &self.0;
                HistoricalNarrativeEvent::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [HistoricalNarrativeEvent].
        #[derive(Copy, Clone)]
        pub struct HistoricalNarrativeEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HistoricalNarrativeEventRef<'a> {
            /// Getter for the [`event` field](HistoricalNarrativeEvent#structfield.event).
            #[inline]
            pub fn event(&self) -> ::planus::Result<self::NarrativeEventRef<'a>> {
                self.0
                    .access_required(0, "HistoricalNarrativeEvent", "event")
            }

            /// Getter for the [`is_historical` field](HistoricalNarrativeEvent#structfield.is_historical).
            #[inline]
            pub fn is_historical(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "HistoricalNarrativeEvent", "is_historical")?
                        .unwrap_or(false),
                )
            }

            /// Getter for the [`player` field](HistoricalNarrativeEvent#structfield.player).
            #[inline]
            pub fn player(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(2, "HistoricalNarrativeEvent", "player")
            }
        }

        impl<'a> ::core::fmt::Debug for HistoricalNarrativeEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HistoricalNarrativeEventRef");
                f.field("event", &self.event());
                f.field("is_historical", &self.is_historical());
                f.field("player", &self.player());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HistoricalNarrativeEventRef<'a>> for HistoricalNarrativeEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HistoricalNarrativeEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    event: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.event()?,
                    )?),
                    is_historical: ::core::convert::TryInto::try_into(value.is_historical()?)?,
                    player: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.player()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HistoricalNarrativeEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HistoricalNarrativeEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoricalNarrativeEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HistoricalNarrativeEvent>>
            for HistoricalNarrativeEvent
        {
            type Value = ::planus::Offset<HistoricalNarrativeEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HistoricalNarrativeEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HistoricalNarrativeEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoricalNarrativeEventRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `HistoryResponse` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HistoryResponse` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:650`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HistoryResponse {
            /// The field `events` in the table `HistoryResponse`
            pub events: ::planus::alloc::vec::Vec<self::HistoricalNarrativeEvent>,
            /// The field `time_range_start` in the table `HistoryResponse`
            pub time_range_start: u64,
            /// The field `time_range_end` in the table `HistoryResponse`
            pub time_range_end: u64,
            /// The field `total_events` in the table `HistoryResponse`
            pub total_events: u64,
            /// The field `has_more_before` in the table `HistoryResponse`
            pub has_more_before: bool,
            /// The field `earliest_event_id` in the table `HistoryResponse`
            pub earliest_event_id: ::core::option::Option<::planus::alloc::boxed::Box<self::Uuid>>,
            /// The field `latest_event_id` in the table `HistoryResponse`
            pub latest_event_id: ::core::option::Option<::planus::alloc::boxed::Box<self::Uuid>>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for HistoryResponse {
            fn default() -> Self {
                Self {
                    events: ::core::default::Default::default(),
                    time_range_start: 0,
                    time_range_end: 0,
                    total_events: 0,
                    has_more_before: false,
                    earliest_event_id: ::core::default::Default::default(),
                    latest_event_id: ::core::default::Default::default(),
                }
            }
        }

        impl HistoryResponse {
            /// Creates a [HistoryResponseBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HistoryResponseBuilder<()> {
                HistoryResponseBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_events: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::HistoricalNarrativeEvent>]>,
                >,
                field_time_range_start: impl ::planus::WriteAsDefault<u64, u64>,
                field_time_range_end: impl ::planus::WriteAsDefault<u64, u64>,
                field_total_events: impl ::planus::WriteAsDefault<u64, u64>,
                field_has_more_before: impl ::planus::WriteAsDefault<bool, bool>,
                field_earliest_event_id: impl ::planus::WriteAsOptional<::planus::Offset<self::Uuid>>,
                field_latest_event_id: impl ::planus::WriteAsOptional<::planus::Offset<self::Uuid>>,
            ) -> ::planus::Offset<Self> {
                let prepared_events = field_events.prepare(builder);
                let prepared_time_range_start = field_time_range_start.prepare(builder, &0);
                let prepared_time_range_end = field_time_range_end.prepare(builder, &0);
                let prepared_total_events = field_total_events.prepare(builder, &0);
                let prepared_has_more_before = field_has_more_before.prepare(builder, &false);
                let prepared_earliest_event_id = field_earliest_event_id.prepare(builder);
                let prepared_latest_event_id = field_latest_event_id.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<18> =
                    ::core::default::Default::default();
                if prepared_time_range_start.is_some() {
                    table_writer.write_entry::<u64>(1);
                }
                if prepared_time_range_end.is_some() {
                    table_writer.write_entry::<u64>(2);
                }
                if prepared_total_events.is_some() {
                    table_writer.write_entry::<u64>(3);
                }
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::HistoricalNarrativeEvent>]>>(0);
                if prepared_earliest_event_id.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::Uuid>>(5);
                }
                if prepared_latest_event_id.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::Uuid>>(6);
                }
                if prepared_has_more_before.is_some() {
                    table_writer.write_entry::<bool>(4);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_time_range_start) =
                            prepared_time_range_start
                        {
                            object_writer.write::<_, _, 8>(&prepared_time_range_start);
                        }
                        if let ::core::option::Option::Some(prepared_time_range_end) =
                            prepared_time_range_end
                        {
                            object_writer.write::<_, _, 8>(&prepared_time_range_end);
                        }
                        if let ::core::option::Option::Some(prepared_total_events) =
                            prepared_total_events
                        {
                            object_writer.write::<_, _, 8>(&prepared_total_events);
                        }
                        object_writer.write::<_, _, 4>(&prepared_events);
                        if let ::core::option::Option::Some(prepared_earliest_event_id) =
                            prepared_earliest_event_id
                        {
                            object_writer.write::<_, _, 4>(&prepared_earliest_event_id);
                        }
                        if let ::core::option::Option::Some(prepared_latest_event_id) =
                            prepared_latest_event_id
                        {
                            object_writer.write::<_, _, 4>(&prepared_latest_event_id);
                        }
                        if let ::core::option::Option::Some(prepared_has_more_before) =
                            prepared_has_more_before
                        {
                            object_writer.write::<_, _, 1>(&prepared_has_more_before);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HistoryResponse>> for HistoryResponse {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryResponse> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HistoryResponse>> for HistoryResponse {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryResponse>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HistoryResponse> for HistoryResponse {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryResponse> {
                HistoryResponse::create(
                    builder,
                    &self.events,
                    self.time_range_start,
                    self.time_range_end,
                    self.total_events,
                    self.has_more_before,
                    &self.earliest_event_id,
                    &self.latest_event_id,
                )
            }
        }

        /// Builder for serializing an instance of the [HistoryResponse] type.
        ///
        /// Can be created using the [HistoryResponse::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HistoryResponseBuilder<State>(State);

        impl HistoryResponseBuilder<()> {
            /// Setter for the [`events` field](HistoryResponse#structfield.events).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn events<T0>(self, value: T0) -> HistoryResponseBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::HistoricalNarrativeEvent>]>,
                    >,
            {
                HistoryResponseBuilder((value,))
            }
        }

        impl<T0> HistoryResponseBuilder<(T0,)> {
            /// Setter for the [`time_range_start` field](HistoryResponse#structfield.time_range_start).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn time_range_start<T1>(self, value: T1) -> HistoryResponseBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                HistoryResponseBuilder((v0, value))
            }

            /// Sets the [`time_range_start` field](HistoryResponse#structfield.time_range_start) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn time_range_start_as_default(
                self,
            ) -> HistoryResponseBuilder<(T0, ::planus::DefaultValue)> {
                self.time_range_start(::planus::DefaultValue)
            }
        }

        impl<T0, T1> HistoryResponseBuilder<(T0, T1)> {
            /// Setter for the [`time_range_end` field](HistoryResponse#structfield.time_range_end).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn time_range_end<T2>(self, value: T2) -> HistoryResponseBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1) = self.0;
                HistoryResponseBuilder((v0, v1, value))
            }

            /// Sets the [`time_range_end` field](HistoryResponse#structfield.time_range_end) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn time_range_end_as_default(
                self,
            ) -> HistoryResponseBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.time_range_end(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> HistoryResponseBuilder<(T0, T1, T2)> {
            /// Setter for the [`total_events` field](HistoryResponse#structfield.total_events).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn total_events<T3>(self, value: T3) -> HistoryResponseBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1, v2) = self.0;
                HistoryResponseBuilder((v0, v1, v2, value))
            }

            /// Sets the [`total_events` field](HistoryResponse#structfield.total_events) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn total_events_as_default(
                self,
            ) -> HistoryResponseBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.total_events(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> HistoryResponseBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`has_more_before` field](HistoryResponse#structfield.has_more_before).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn has_more_before<T4>(
                self,
                value: T4,
            ) -> HistoryResponseBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2, v3) = self.0;
                HistoryResponseBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`has_more_before` field](HistoryResponse#structfield.has_more_before) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn has_more_before_as_default(
                self,
            ) -> HistoryResponseBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.has_more_before(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> HistoryResponseBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`earliest_event_id` field](HistoryResponse#structfield.earliest_event_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn earliest_event_id<T5>(
                self,
                value: T5,
            ) -> HistoryResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAsOptional<::planus::Offset<self::Uuid>>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                HistoryResponseBuilder((v0, v1, v2, v3, v4, value))
            }

            /// Sets the [`earliest_event_id` field](HistoryResponse#structfield.earliest_event_id) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn earliest_event_id_as_null(
                self,
            ) -> HistoryResponseBuilder<(T0, T1, T2, T3, T4, ())> {
                self.earliest_event_id(())
            }
        }

        impl<T0, T1, T2, T3, T4, T5> HistoryResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Setter for the [`latest_event_id` field](HistoryResponse#structfield.latest_event_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn latest_event_id<T6>(
                self,
                value: T6,
            ) -> HistoryResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            where
                T6: ::planus::WriteAsOptional<::planus::Offset<self::Uuid>>,
            {
                let (v0, v1, v2, v3, v4, v5) = self.0;
                HistoryResponseBuilder((v0, v1, v2, v3, v4, v5, value))
            }

            /// Sets the [`latest_event_id` field](HistoryResponse#structfield.latest_event_id) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn latest_event_id_as_null(
                self,
            ) -> HistoryResponseBuilder<(T0, T1, T2, T3, T4, T5, ())> {
                self.latest_event_id(())
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6> HistoryResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HistoryResponse].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryResponse>
            where
                Self: ::planus::WriteAsOffset<HistoryResponse>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::HistoricalNarrativeEvent>]>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u64, u64>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsOptional<::planus::Offset<self::Uuid>>,
            T6: ::planus::WriteAsOptional<::planus::Offset<self::Uuid>>,
        > ::planus::WriteAs<::planus::Offset<HistoryResponse>>
            for HistoryResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            type Prepared = ::planus::Offset<HistoryResponse>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryResponse> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::HistoricalNarrativeEvent>]>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u64, u64>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsOptional<::planus::Offset<self::Uuid>>,
            T6: ::planus::WriteAsOptional<::planus::Offset<self::Uuid>>,
        > ::planus::WriteAsOptional<::planus::Offset<HistoryResponse>>
            for HistoryResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            type Prepared = ::planus::Offset<HistoryResponse>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HistoryResponse>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::HistoricalNarrativeEvent>]>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAsDefault<u64, u64>,
            T3: ::planus::WriteAsDefault<u64, u64>,
            T4: ::planus::WriteAsDefault<bool, bool>,
            T5: ::planus::WriteAsOptional<::planus::Offset<self::Uuid>>,
            T6: ::planus::WriteAsOptional<::planus::Offset<self::Uuid>>,
        > ::planus::WriteAsOffset<HistoryResponse>
            for HistoryResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HistoryResponse> {
                let (v0, v1, v2, v3, v4, v5, v6) = &self.0;
                HistoryResponse::create(builder, v0, v1, v2, v3, v4, v5, v6)
            }
        }

        /// Reference to a deserialized [HistoryResponse].
        #[derive(Copy, Clone)]
        pub struct HistoryResponseRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HistoryResponseRef<'a> {
            /// Getter for the [`events` field](HistoryResponse#structfield.events).
            #[inline]
            pub fn events(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::HistoricalNarrativeEventRef<'a>>>,
            > {
                self.0.access_required(0, "HistoryResponse", "events")
            }

            /// Getter for the [`time_range_start` field](HistoryResponse#structfield.time_range_start).
            #[inline]
            pub fn time_range_start(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "HistoryResponse", "time_range_start")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`time_range_end` field](HistoryResponse#structfield.time_range_end).
            #[inline]
            pub fn time_range_end(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "HistoryResponse", "time_range_end")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`total_events` field](HistoryResponse#structfield.total_events).
            #[inline]
            pub fn total_events(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "HistoryResponse", "total_events")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`has_more_before` field](HistoryResponse#structfield.has_more_before).
            #[inline]
            pub fn has_more_before(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(4, "HistoryResponse", "has_more_before")?
                        .unwrap_or(false),
                )
            }

            /// Getter for the [`earliest_event_id` field](HistoryResponse#structfield.earliest_event_id).
            #[inline]
            pub fn earliest_event_id(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::UuidRef<'a>>> {
                self.0.access(5, "HistoryResponse", "earliest_event_id")
            }

            /// Getter for the [`latest_event_id` field](HistoryResponse#structfield.latest_event_id).
            #[inline]
            pub fn latest_event_id(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::UuidRef<'a>>> {
                self.0.access(6, "HistoryResponse", "latest_event_id")
            }
        }

        impl<'a> ::core::fmt::Debug for HistoryResponseRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HistoryResponseRef");
                f.field("events", &self.events());
                f.field("time_range_start", &self.time_range_start());
                f.field("time_range_end", &self.time_range_end());
                f.field("total_events", &self.total_events());
                f.field("has_more_before", &self.has_more_before());
                if let ::core::option::Option::Some(field_earliest_event_id) =
                    self.earliest_event_id().transpose()
                {
                    f.field("earliest_event_id", &field_earliest_event_id);
                }
                if let ::core::option::Option::Some(field_latest_event_id) =
                    self.latest_event_id().transpose()
                {
                    f.field("latest_event_id", &field_latest_event_id);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HistoryResponseRef<'a>> for HistoryResponse {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HistoryResponseRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    events: value.events()?.to_vec_result()?,
                    time_range_start: ::core::convert::TryInto::try_into(
                        value.time_range_start()?,
                    )?,
                    time_range_end: ::core::convert::TryInto::try_into(value.time_range_end()?)?,
                    total_events: ::core::convert::TryInto::try_into(value.total_events()?)?,
                    has_more_before: ::core::convert::TryInto::try_into(value.has_more_before()?)?,
                    earliest_event_id: if let ::core::option::Option::Some(earliest_event_id) =
                        value.earliest_event_id()?
                    {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(earliest_event_id)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                    latest_event_id: if let ::core::option::Option::Some(latest_event_id) =
                        value.latest_event_id()?
                    {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(latest_event_id)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HistoryResponseRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HistoryResponseRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HistoryResponseRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HistoryResponse>> for HistoryResponse {
            type Value = ::planus::Offset<HistoryResponse>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HistoryResponse>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HistoryResponseRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HistoryResponseRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `VerbProgramResponseUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `VerbProgramResponseUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:664`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum VerbProgramResponseUnion {
            /// The variant of type `VerbProgramSuccess` in the union `VerbProgramResponseUnion`
            VerbProgramSuccess(::planus::alloc::boxed::Box<self::VerbProgramSuccess>),

            /// The variant of type `VerbProgramFailure` in the union `VerbProgramResponseUnion`
            VerbProgramFailure(::planus::alloc::boxed::Box<self::VerbProgramFailure>),
        }

        impl VerbProgramResponseUnion {
            /// Creates a [VerbProgramResponseUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbProgramResponseUnionBuilder<::planus::Uninitialized> {
                VerbProgramResponseUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_verb_program_success(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbProgramSuccess>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_program_failure(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbProgramFailure>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<VerbProgramResponseUnion> for VerbProgramResponseUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::VerbProgramSuccess(value) => {
                        Self::create_verb_program_success(builder, value)
                    }
                    Self::VerbProgramFailure(value) => {
                        Self::create_verb_program_failure(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<VerbProgramResponseUnion> for VerbProgramResponseUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [VerbProgramResponseUnion] type.
        ///
        /// Can be created using the [VerbProgramResponseUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbProgramResponseUnionBuilder<T>(T);

        impl VerbProgramResponseUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`VerbProgramSuccess` variant](VerbProgramResponseUnion#variant.VerbProgramSuccess).
            #[inline]
            pub fn verb_program_success<T>(
                self,
                value: T,
            ) -> VerbProgramResponseUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbProgramSuccess>,
            {
                VerbProgramResponseUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbProgramFailure` variant](VerbProgramResponseUnion#variant.VerbProgramFailure).
            #[inline]
            pub fn verb_program_failure<T>(
                self,
                value: T,
            ) -> VerbProgramResponseUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbProgramFailure>,
            {
                VerbProgramResponseUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> VerbProgramResponseUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [VerbProgramResponseUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<VerbProgramResponseUnion>
            where
                Self: ::planus::WriteAsUnion<VerbProgramResponseUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<VerbProgramResponseUnion>
            for VerbProgramResponseUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbProgramSuccess>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<VerbProgramResponseUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VerbProgramResponseUnion>
            for VerbProgramResponseUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbProgramSuccess>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VerbProgramResponseUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<VerbProgramResponseUnion>
            for VerbProgramResponseUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbProgramFailure>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<VerbProgramResponseUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<VerbProgramResponseUnion>
            for VerbProgramResponseUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbProgramFailure>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<VerbProgramResponseUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [VerbProgramResponseUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum VerbProgramResponseUnionRef<'a> {
            VerbProgramSuccess(self::VerbProgramSuccessRef<'a>),
            VerbProgramFailure(self::VerbProgramFailureRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<VerbProgramResponseUnionRef<'a>> for VerbProgramResponseUnion {
            type Error = ::planus::Error;

            fn try_from(value: VerbProgramResponseUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    VerbProgramResponseUnionRef::VerbProgramSuccess(value) => {
                        Self::VerbProgramSuccess(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    VerbProgramResponseUnionRef::VerbProgramFailure(value) => {
                        Self::VerbProgramFailure(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for VerbProgramResponseUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::VerbProgramSuccess(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::VerbProgramFailure(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for VerbProgramResponseUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[VerbProgramResponseUnionRef]";
        }

        /// The table `VerbProgramSuccess` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbProgramSuccess` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:669`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbProgramSuccess {
            /// The field `obj` in the table `VerbProgramSuccess`
            pub obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `verb_name` in the table `VerbProgramSuccess`
            pub verb_name: ::planus::alloc::string::String,
        }

        impl VerbProgramSuccess {
            /// Creates a [VerbProgramSuccessBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbProgramSuccessBuilder<()> {
                VerbProgramSuccessBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_verb_name: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_obj = field_obj.prepare(builder);
                let prepared_verb_name = field_verb_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_obj);
                        object_writer.write::<_, _, 4>(&prepared_verb_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbProgramSuccess>> for VerbProgramSuccess {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramSuccess> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbProgramSuccess>> for VerbProgramSuccess {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramSuccess>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbProgramSuccess> for VerbProgramSuccess {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramSuccess> {
                VerbProgramSuccess::create(builder, &self.obj, &self.verb_name)
            }
        }

        /// Builder for serializing an instance of the [VerbProgramSuccess] type.
        ///
        /// Can be created using the [VerbProgramSuccess::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbProgramSuccessBuilder<State>(State);

        impl VerbProgramSuccessBuilder<()> {
            /// Setter for the [`obj` field](VerbProgramSuccess#structfield.obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn obj<T0>(self, value: T0) -> VerbProgramSuccessBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                VerbProgramSuccessBuilder((value,))
            }
        }

        impl<T0> VerbProgramSuccessBuilder<(T0,)> {
            /// Setter for the [`verb_name` field](VerbProgramSuccess#structfield.verb_name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verb_name<T1>(self, value: T1) -> VerbProgramSuccessBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                VerbProgramSuccessBuilder((v0, value))
            }
        }

        impl<T0, T1> VerbProgramSuccessBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbProgramSuccess].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramSuccess>
            where
                Self: ::planus::WriteAsOffset<VerbProgramSuccess>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<VerbProgramSuccess>>
            for VerbProgramSuccessBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbProgramSuccess>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramSuccess> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<VerbProgramSuccess>>
            for VerbProgramSuccessBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbProgramSuccess>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramSuccess>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<VerbProgramSuccess> for VerbProgramSuccessBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramSuccess> {
                let (v0, v1) = &self.0;
                VerbProgramSuccess::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [VerbProgramSuccess].
        #[derive(Copy, Clone)]
        pub struct VerbProgramSuccessRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbProgramSuccessRef<'a> {
            /// Getter for the [`obj` field](VerbProgramSuccess#structfield.obj).
            #[inline]
            pub fn obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "VerbProgramSuccess", "obj")
            }

            /// Getter for the [`verb_name` field](VerbProgramSuccess#structfield.verb_name).
            #[inline]
            pub fn verb_name(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "VerbProgramSuccess", "verb_name")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbProgramSuccessRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbProgramSuccessRef");
                f.field("obj", &self.obj());
                f.field("verb_name", &self.verb_name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbProgramSuccessRef<'a>> for VerbProgramSuccess {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbProgramSuccessRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    obj: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.obj()?,
                    )?),
                    verb_name: ::core::convert::Into::into(value.verb_name()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbProgramSuccessRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbProgramSuccessRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbProgramSuccessRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbProgramSuccess>> for VerbProgramSuccess {
            type Value = ::planus::Offset<VerbProgramSuccess>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbProgramSuccess>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbProgramSuccessRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbProgramSuccessRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbProgramFailure` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbProgramFailure` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:674`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbProgramFailure {
            /// The field `error` in the table `VerbProgramFailure`
            pub error: ::planus::alloc::boxed::Box<self::VerbProgramError>,
        }

        impl VerbProgramFailure {
            /// Creates a [VerbProgramFailureBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbProgramFailureBuilder<()> {
                VerbProgramFailureBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::VerbProgramError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::VerbProgramError>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbProgramFailure>> for VerbProgramFailure {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramFailure> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbProgramFailure>> for VerbProgramFailure {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramFailure>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbProgramFailure> for VerbProgramFailure {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramFailure> {
                VerbProgramFailure::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [VerbProgramFailure] type.
        ///
        /// Can be created using the [VerbProgramFailure::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbProgramFailureBuilder<State>(State);

        impl VerbProgramFailureBuilder<()> {
            /// Setter for the [`error` field](VerbProgramFailure#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> VerbProgramFailureBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramError>>,
            {
                VerbProgramFailureBuilder((value,))
            }
        }

        impl<T0> VerbProgramFailureBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbProgramFailure].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramFailure>
            where
                Self: ::planus::WriteAsOffset<VerbProgramFailure>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramError>>>
            ::planus::WriteAs<::planus::Offset<VerbProgramFailure>>
            for VerbProgramFailureBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbProgramFailure>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramFailure> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramError>>>
            ::planus::WriteAsOptional<::planus::Offset<VerbProgramFailure>>
            for VerbProgramFailureBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbProgramFailure>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramFailure>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramError>>>
            ::planus::WriteAsOffset<VerbProgramFailure> for VerbProgramFailureBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramFailure> {
                let (v0,) = &self.0;
                VerbProgramFailure::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VerbProgramFailure].
        #[derive(Copy, Clone)]
        pub struct VerbProgramFailureRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbProgramFailureRef<'a> {
            /// Getter for the [`error` field](VerbProgramFailure#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::VerbProgramErrorRef<'a>> {
                self.0.access_required(0, "VerbProgramFailure", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbProgramFailureRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbProgramFailureRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbProgramFailureRef<'a>> for VerbProgramFailure {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbProgramFailureRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbProgramFailureRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbProgramFailureRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbProgramFailureRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbProgramFailure>> for VerbProgramFailure {
            type Value = ::planus::Offset<VerbProgramFailure>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbProgramFailure>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbProgramFailureRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbProgramFailureRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbProgramResponse` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbProgramResponse` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:678`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbProgramResponse {
            /// The field `response` in the table `VerbProgramResponse`
            pub response: self::VerbProgramResponseUnion,
        }

        impl VerbProgramResponse {
            /// Creates a [VerbProgramResponseBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbProgramResponseBuilder<()> {
                VerbProgramResponseBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_response: impl ::planus::WriteAsUnion<self::VerbProgramResponseUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_response = field_response.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::VerbProgramResponseUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_response.offset());
                        object_writer.write::<_, _, 1>(&prepared_response.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbProgramResponse>> for VerbProgramResponse {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramResponse> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbProgramResponse>> for VerbProgramResponse {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramResponse>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbProgramResponse> for VerbProgramResponse {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramResponse> {
                VerbProgramResponse::create(builder, &self.response)
            }
        }

        /// Builder for serializing an instance of the [VerbProgramResponse] type.
        ///
        /// Can be created using the [VerbProgramResponse::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbProgramResponseBuilder<State>(State);

        impl VerbProgramResponseBuilder<()> {
            /// Setter for the [`response` field](VerbProgramResponse#structfield.response).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn response<T0>(self, value: T0) -> VerbProgramResponseBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::VerbProgramResponseUnion>,
            {
                VerbProgramResponseBuilder((value,))
            }
        }

        impl<T0> VerbProgramResponseBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbProgramResponse].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramResponse>
            where
                Self: ::planus::WriteAsOffset<VerbProgramResponse>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::VerbProgramResponseUnion>>
            ::planus::WriteAs<::planus::Offset<VerbProgramResponse>>
            for VerbProgramResponseBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbProgramResponse>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramResponse> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::VerbProgramResponseUnion>>
            ::planus::WriteAsOptional<::planus::Offset<VerbProgramResponse>>
            for VerbProgramResponseBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbProgramResponse>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramResponse>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::VerbProgramResponseUnion>>
            ::planus::WriteAsOffset<VerbProgramResponse> for VerbProgramResponseBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramResponse> {
                let (v0,) = &self.0;
                VerbProgramResponse::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VerbProgramResponse].
        #[derive(Copy, Clone)]
        pub struct VerbProgramResponseRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbProgramResponseRef<'a> {
            /// Getter for the [`response` field](VerbProgramResponse#structfield.response).
            #[inline]
            pub fn response(&self) -> ::planus::Result<self::VerbProgramResponseUnionRef<'a>> {
                self.0
                    .access_union_required(0, "VerbProgramResponse", "response")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbProgramResponseRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbProgramResponseRef");
                f.field("response", &self.response());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbProgramResponseRef<'a>> for VerbProgramResponse {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbProgramResponseRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    response: ::core::convert::TryInto::try_into(value.response()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbProgramResponseRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbProgramResponseRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbProgramResponseRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbProgramResponse>> for VerbProgramResponse {
            type Value = ::planus::Offset<VerbProgramResponse>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbProgramResponse>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbProgramResponseRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbProgramResponseRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ConnectionAttribute` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ConnectionAttribute` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:686`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ConnectionAttribute {
            /// The field `key` in the table `ConnectionAttribute`
            pub key: ::planus::alloc::boxed::Box<self::Symbol>,
            /// The field `value` in the table `ConnectionAttribute`
            pub value: ::planus::alloc::boxed::Box<self::VarBytes>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ConnectionAttribute {
            fn default() -> Self {
                Self {
                    key: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }

        impl ConnectionAttribute {
            /// Creates a [ConnectionAttributeBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ConnectionAttributeBuilder<()> {
                ConnectionAttributeBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_key: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
                field_value: impl ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            ) -> ::planus::Offset<Self> {
                let prepared_key = field_key.prepare(builder);
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(0);
                table_writer.write_entry::<::planus::Offset<self::VarBytes>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_key);
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ConnectionAttribute>> for ConnectionAttribute {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionAttribute> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ConnectionAttribute>> for ConnectionAttribute {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ConnectionAttribute>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ConnectionAttribute> for ConnectionAttribute {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionAttribute> {
                ConnectionAttribute::create(builder, &self.key, &self.value)
            }
        }

        /// Builder for serializing an instance of the [ConnectionAttribute] type.
        ///
        /// Can be created using the [ConnectionAttribute::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ConnectionAttributeBuilder<State>(State);

        impl ConnectionAttributeBuilder<()> {
            /// Setter for the [`key` field](ConnectionAttribute#structfield.key).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn key<T0>(self, value: T0) -> ConnectionAttributeBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                ConnectionAttributeBuilder((value,))
            }
        }

        impl<T0> ConnectionAttributeBuilder<(T0,)> {
            /// Setter for the [`value` field](ConnectionAttribute#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T1>(self, value: T1) -> ConnectionAttributeBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            {
                let (v0,) = self.0;
                ConnectionAttributeBuilder((v0, value))
            }
        }

        impl<T0, T1> ConnectionAttributeBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectionAttribute].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionAttribute>
            where
                Self: ::planus::WriteAsOffset<ConnectionAttribute>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAs<::planus::Offset<ConnectionAttribute>>
            for ConnectionAttributeBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<ConnectionAttribute>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionAttribute> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOptional<::planus::Offset<ConnectionAttribute>>
            for ConnectionAttributeBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<ConnectionAttribute>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ConnectionAttribute>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOffset<ConnectionAttribute> for ConnectionAttributeBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionAttribute> {
                let (v0, v1) = &self.0;
                ConnectionAttribute::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [ConnectionAttribute].
        #[derive(Copy, Clone)]
        pub struct ConnectionAttributeRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ConnectionAttributeRef<'a> {
            /// Getter for the [`key` field](ConnectionAttribute#structfield.key).
            #[inline]
            pub fn key(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(0, "ConnectionAttribute", "key")
            }

            /// Getter for the [`value` field](ConnectionAttribute#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<self::VarBytesRef<'a>> {
                self.0.access_required(1, "ConnectionAttribute", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for ConnectionAttributeRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ConnectionAttributeRef");
                f.field("key", &self.key());
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ConnectionAttributeRef<'a>> for ConnectionAttribute {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ConnectionAttributeRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    key: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.key()?,
                    )?),
                    value: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.value()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ConnectionAttributeRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ConnectionAttributeRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ConnectionAttributeRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ConnectionAttribute>> for ConnectionAttribute {
            type Value = ::planus::Offset<ConnectionAttribute>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ConnectionAttribute>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ConnectionAttributeRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ConnectionAttributeRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `HostToDaemonMessageUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `HostToDaemonMessageUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:695`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum HostToDaemonMessageUnion {
            /// The variant of type `RegisterHost` in the union `HostToDaemonMessageUnion`
            RegisterHost(::planus::alloc::boxed::Box<self::RegisterHost>),

            /// The variant of type `DetachHost` in the union `HostToDaemonMessageUnion`
            DetachHost(::planus::alloc::boxed::Box<self::DetachHost>),

            /// The variant of type `RequestPerformanceCounters` in the union `HostToDaemonMessageUnion`
            RequestPerformanceCounters(
                ::planus::alloc::boxed::Box<self::RequestPerformanceCounters>,
            ),

            /// The variant of type `HostPong` in the union `HostToDaemonMessageUnion`
            HostPong(::planus::alloc::boxed::Box<self::HostPong>),
        }

        impl HostToDaemonMessageUnion {
            /// Creates a [HostToDaemonMessageUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostToDaemonMessageUnionBuilder<::planus::Uninitialized> {
                HostToDaemonMessageUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_register_host(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RegisterHost>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_detach_host(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DetachHost>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_request_performance_counters(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RequestPerformanceCounters>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_host_pong(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HostPong>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<HostToDaemonMessageUnion> for HostToDaemonMessageUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::RegisterHost(value) => Self::create_register_host(builder, value),
                    Self::DetachHost(value) => Self::create_detach_host(builder, value),
                    Self::RequestPerformanceCounters(value) => {
                        Self::create_request_performance_counters(builder, value)
                    }
                    Self::HostPong(value) => Self::create_host_pong(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<HostToDaemonMessageUnion> for HostToDaemonMessageUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [HostToDaemonMessageUnion] type.
        ///
        /// Can be created using the [HostToDaemonMessageUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostToDaemonMessageUnionBuilder<T>(T);

        impl HostToDaemonMessageUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`RegisterHost` variant](HostToDaemonMessageUnion#variant.RegisterHost).
            #[inline]
            pub fn register_host<T>(
                self,
                value: T,
            ) -> HostToDaemonMessageUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::RegisterHost>,
            {
                HostToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DetachHost` variant](HostToDaemonMessageUnion#variant.DetachHost).
            #[inline]
            pub fn detach_host<T>(
                self,
                value: T,
            ) -> HostToDaemonMessageUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::DetachHost>,
            {
                HostToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RequestPerformanceCounters` variant](HostToDaemonMessageUnion#variant.RequestPerformanceCounters).
            #[inline]
            pub fn request_performance_counters<T>(
                self,
                value: T,
            ) -> HostToDaemonMessageUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::RequestPerformanceCounters>,
            {
                HostToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`HostPong` variant](HostToDaemonMessageUnion#variant.HostPong).
            #[inline]
            pub fn host_pong<T>(
                self,
                value: T,
            ) -> HostToDaemonMessageUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::HostPong>,
            {
                HostToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> HostToDaemonMessageUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [HostToDaemonMessageUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostToDaemonMessageUnion>
            where
                Self: ::planus::WriteAsUnion<HostToDaemonMessageUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<HostToDaemonMessageUnion>
            for HostToDaemonMessageUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::RegisterHost>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostToDaemonMessageUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostToDaemonMessageUnion>
            for HostToDaemonMessageUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::RegisterHost>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostToDaemonMessageUnion>
            for HostToDaemonMessageUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::DetachHost>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostToDaemonMessageUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostToDaemonMessageUnion>
            for HostToDaemonMessageUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::DetachHost>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostToDaemonMessageUnion>
            for HostToDaemonMessageUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestPerformanceCounters>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostToDaemonMessageUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostToDaemonMessageUnion>
            for HostToDaemonMessageUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestPerformanceCounters>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostToDaemonMessageUnion>
            for HostToDaemonMessageUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::HostPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostToDaemonMessageUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostToDaemonMessageUnion>
            for HostToDaemonMessageUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::HostPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [HostToDaemonMessageUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum HostToDaemonMessageUnionRef<'a> {
            RegisterHost(self::RegisterHostRef<'a>),
            DetachHost(self::DetachHostRef<'a>),
            RequestPerformanceCounters(self::RequestPerformanceCountersRef<'a>),
            HostPong(self::HostPongRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<HostToDaemonMessageUnionRef<'a>> for HostToDaemonMessageUnion {
            type Error = ::planus::Error;

            fn try_from(value: HostToDaemonMessageUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    HostToDaemonMessageUnionRef::RegisterHost(value) => {
                        Self::RegisterHost(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostToDaemonMessageUnionRef::DetachHost(value) => {
                        Self::DetachHost(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostToDaemonMessageUnionRef::RequestPerformanceCounters(value) => {
                        Self::RequestPerformanceCounters(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostToDaemonMessageUnionRef::HostPong(value) => {
                        Self::HostPong(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for HostToDaemonMessageUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::RegisterHost(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::DetachHost(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::RequestPerformanceCounters(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::HostPong(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for HostToDaemonMessageUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[HostToDaemonMessageUnionRef]";
        }

        /// The table `RegisterHost` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RegisterHost` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:702`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RegisterHost {
            /// The field `timestamp` in the table `RegisterHost`
            pub timestamp: u64,
            /// The field `host_type` in the table `RegisterHost`
            pub host_type: self::HostType,
            /// The field `listeners` in the table `RegisterHost`
            pub listeners: ::planus::alloc::vec::Vec<self::Listener>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for RegisterHost {
            fn default() -> Self {
                Self {
                    timestamp: 0,
                    host_type: self::HostType::Tcp,
                    listeners: ::core::default::Default::default(),
                }
            }
        }

        impl RegisterHost {
            /// Creates a [RegisterHostBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RegisterHostBuilder<()> {
                RegisterHostBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                field_host_type: impl ::planus::WriteAsDefault<self::HostType, self::HostType>,
                field_listeners: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::Listener>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_timestamp = field_timestamp.prepare(builder, &0);
                let prepared_host_type = field_host_type.prepare(builder, &self::HostType::Tcp);
                let prepared_listeners = field_listeners.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                if prepared_timestamp.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Listener>]>>(2);
                if prepared_host_type.is_some() {
                    table_writer.write_entry::<self::HostType>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            object_writer.write::<_, _, 8>(&prepared_timestamp);
                        }
                        object_writer.write::<_, _, 4>(&prepared_listeners);
                        if let ::core::option::Option::Some(prepared_host_type) = prepared_host_type
                        {
                            object_writer.write::<_, _, 1>(&prepared_host_type);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RegisterHost>> for RegisterHost {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RegisterHost> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RegisterHost>> for RegisterHost {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RegisterHost>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RegisterHost> for RegisterHost {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RegisterHost> {
                RegisterHost::create(builder, self.timestamp, self.host_type, &self.listeners)
            }
        }

        /// Builder for serializing an instance of the [RegisterHost] type.
        ///
        /// Can be created using the [RegisterHost::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RegisterHostBuilder<State>(State);

        impl RegisterHostBuilder<()> {
            /// Setter for the [`timestamp` field](RegisterHost#structfield.timestamp).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp<T0>(self, value: T0) -> RegisterHostBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                RegisterHostBuilder((value,))
            }

            /// Sets the [`timestamp` field](RegisterHost#structfield.timestamp) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp_as_default(self) -> RegisterHostBuilder<(::planus::DefaultValue,)> {
                self.timestamp(::planus::DefaultValue)
            }
        }

        impl<T0> RegisterHostBuilder<(T0,)> {
            /// Setter for the [`host_type` field](RegisterHost#structfield.host_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_type<T1>(self, value: T1) -> RegisterHostBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            {
                let (v0,) = self.0;
                RegisterHostBuilder((v0, value))
            }

            /// Sets the [`host_type` field](RegisterHost#structfield.host_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_type_as_default(self) -> RegisterHostBuilder<(T0, ::planus::DefaultValue)> {
                self.host_type(::planus::DefaultValue)
            }
        }

        impl<T0, T1> RegisterHostBuilder<(T0, T1)> {
            /// Setter for the [`listeners` field](RegisterHost#structfield.listeners).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn listeners<T2>(self, value: T2) -> RegisterHostBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Listener>]>>,
            {
                let (v0, v1) = self.0;
                RegisterHostBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> RegisterHostBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RegisterHost].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RegisterHost>
            where
                Self: ::planus::WriteAsOffset<RegisterHost>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Listener>]>>,
        > ::planus::WriteAs<::planus::Offset<RegisterHost>> for RegisterHostBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RegisterHost>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RegisterHost> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Listener>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<RegisterHost>>
            for RegisterHostBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RegisterHost>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RegisterHost>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Listener>]>>,
        > ::planus::WriteAsOffset<RegisterHost> for RegisterHostBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RegisterHost> {
                let (v0, v1, v2) = &self.0;
                RegisterHost::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [RegisterHost].
        #[derive(Copy, Clone)]
        pub struct RegisterHostRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RegisterHostRef<'a> {
            /// Getter for the [`timestamp` field](RegisterHost#structfield.timestamp).
            #[inline]
            pub fn timestamp(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0.access(0, "RegisterHost", "timestamp")?.unwrap_or(0),
                )
            }

            /// Getter for the [`host_type` field](RegisterHost#structfield.host_type).
            #[inline]
            pub fn host_type(&self) -> ::planus::Result<self::HostType> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "RegisterHost", "host_type")?
                        .unwrap_or(self::HostType::Tcp),
                )
            }

            /// Getter for the [`listeners` field](RegisterHost#structfield.listeners).
            #[inline]
            pub fn listeners(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::ListenerRef<'a>>>>
            {
                self.0.access_required(2, "RegisterHost", "listeners")
            }
        }

        impl<'a> ::core::fmt::Debug for RegisterHostRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RegisterHostRef");
                f.field("timestamp", &self.timestamp());
                f.field("host_type", &self.host_type());
                f.field("listeners", &self.listeners());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RegisterHostRef<'a>> for RegisterHost {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RegisterHostRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                    host_type: ::core::convert::TryInto::try_into(value.host_type()?)?,
                    listeners: value.listeners()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RegisterHostRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RegisterHostRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RegisterHostRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RegisterHost>> for RegisterHost {
            type Value = ::planus::Offset<RegisterHost>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RegisterHost>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RegisterHostRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RegisterHostRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DetachHost` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DetachHost` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:708`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DetachHost {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DetachHost {
            fn default() -> Self {
                Self {}
            }
        }

        impl DetachHost {
            /// Creates a [DetachHostBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DetachHostBuilder<()> {
                DetachHostBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DetachHost>> for DetachHost {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DetachHost> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DetachHost>> for DetachHost {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DetachHost>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DetachHost> for DetachHost {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DetachHost> {
                DetachHost::create(builder)
            }
        }

        /// Builder for serializing an instance of the [DetachHost] type.
        ///
        /// Can be created using the [DetachHost::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DetachHostBuilder<State>(State);

        impl DetachHostBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DetachHost].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<DetachHost>
            where
                Self: ::planus::WriteAsOffset<DetachHost>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DetachHost>> for DetachHostBuilder<()> {
            type Prepared = ::planus::Offset<DetachHost>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DetachHost> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DetachHost>> for DetachHostBuilder<()> {
            type Prepared = ::planus::Offset<DetachHost>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DetachHost>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DetachHost> for DetachHostBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DetachHost> {
                DetachHost::create(builder)
            }
        }

        /// Reference to a deserialized [DetachHost].
        #[derive(Copy, Clone)]
        pub struct DetachHostRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DetachHostRef<'a> {}

        impl<'a> ::core::fmt::Debug for DetachHostRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DetachHostRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DetachHostRef<'a>> for DetachHost {
            type Error = ::planus::Error;

            fn try_from(_value: DetachHostRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for DetachHostRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DetachHostRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DetachHostRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DetachHost>> for DetachHost {
            type Value = ::planus::Offset<DetachHost>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DetachHost>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DetachHostRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DetachHostRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `RequestPerformanceCounters` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RequestPerformanceCounters` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:711`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RequestPerformanceCounters {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for RequestPerformanceCounters {
            fn default() -> Self {
                Self {}
            }
        }

        impl RequestPerformanceCounters {
            /// Creates a [RequestPerformanceCountersBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RequestPerformanceCountersBuilder<()> {
                RequestPerformanceCountersBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RequestPerformanceCounters>>
            for RequestPerformanceCounters
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestPerformanceCounters> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RequestPerformanceCounters>>
            for RequestPerformanceCounters
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestPerformanceCounters>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RequestPerformanceCounters> for RequestPerformanceCounters {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestPerformanceCounters> {
                RequestPerformanceCounters::create(builder)
            }
        }

        /// Builder for serializing an instance of the [RequestPerformanceCounters] type.
        ///
        /// Can be created using the [RequestPerformanceCounters::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RequestPerformanceCountersBuilder<State>(State);

        impl RequestPerformanceCountersBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RequestPerformanceCounters].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestPerformanceCounters>
            where
                Self: ::planus::WriteAsOffset<RequestPerformanceCounters>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RequestPerformanceCounters>>
            for RequestPerformanceCountersBuilder<()>
        {
            type Prepared = ::planus::Offset<RequestPerformanceCounters>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestPerformanceCounters> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RequestPerformanceCounters>>
            for RequestPerformanceCountersBuilder<()>
        {
            type Prepared = ::planus::Offset<RequestPerformanceCounters>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestPerformanceCounters>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RequestPerformanceCounters> for RequestPerformanceCountersBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestPerformanceCounters> {
                RequestPerformanceCounters::create(builder)
            }
        }

        /// Reference to a deserialized [RequestPerformanceCounters].
        #[derive(Copy, Clone)]
        pub struct RequestPerformanceCountersRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RequestPerformanceCountersRef<'a> {}

        impl<'a> ::core::fmt::Debug for RequestPerformanceCountersRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RequestPerformanceCountersRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RequestPerformanceCountersRef<'a>>
            for RequestPerformanceCounters
        {
            type Error = ::planus::Error;

            fn try_from(_value: RequestPerformanceCountersRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for RequestPerformanceCountersRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RequestPerformanceCountersRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RequestPerformanceCountersRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RequestPerformanceCounters>>
            for RequestPerformanceCounters
        {
            type Value = ::planus::Offset<RequestPerformanceCounters>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RequestPerformanceCounters>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RequestPerformanceCountersRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RequestPerformanceCountersRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `HostPong` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostPong` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:714`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostPong {
            /// The field `timestamp` in the table `HostPong`
            pub timestamp: u64,
            /// The field `host_type` in the table `HostPong`
            pub host_type: self::HostType,
            /// The field `listeners` in the table `HostPong`
            pub listeners: ::planus::alloc::vec::Vec<self::Listener>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for HostPong {
            fn default() -> Self {
                Self {
                    timestamp: 0,
                    host_type: self::HostType::Tcp,
                    listeners: ::core::default::Default::default(),
                }
            }
        }

        impl HostPong {
            /// Creates a [HostPongBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostPongBuilder<()> {
                HostPongBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                field_host_type: impl ::planus::WriteAsDefault<self::HostType, self::HostType>,
                field_listeners: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::Listener>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_timestamp = field_timestamp.prepare(builder, &0);
                let prepared_host_type = field_host_type.prepare(builder, &self::HostType::Tcp);
                let prepared_listeners = field_listeners.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                if prepared_timestamp.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Listener>]>>(2);
                if prepared_host_type.is_some() {
                    table_writer.write_entry::<self::HostType>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            object_writer.write::<_, _, 8>(&prepared_timestamp);
                        }
                        object_writer.write::<_, _, 4>(&prepared_listeners);
                        if let ::core::option::Option::Some(prepared_host_type) = prepared_host_type
                        {
                            object_writer.write::<_, _, 1>(&prepared_host_type);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostPong>> for HostPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostPong>> for HostPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostPong> for HostPong {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostPong> {
                HostPong::create(builder, self.timestamp, self.host_type, &self.listeners)
            }
        }

        /// Builder for serializing an instance of the [HostPong] type.
        ///
        /// Can be created using the [HostPong::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostPongBuilder<State>(State);

        impl HostPongBuilder<()> {
            /// Setter for the [`timestamp` field](HostPong#structfield.timestamp).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp<T0>(self, value: T0) -> HostPongBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                HostPongBuilder((value,))
            }

            /// Sets the [`timestamp` field](HostPong#structfield.timestamp) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp_as_default(self) -> HostPongBuilder<(::planus::DefaultValue,)> {
                self.timestamp(::planus::DefaultValue)
            }
        }

        impl<T0> HostPongBuilder<(T0,)> {
            /// Setter for the [`host_type` field](HostPong#structfield.host_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_type<T1>(self, value: T1) -> HostPongBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            {
                let (v0,) = self.0;
                HostPongBuilder((v0, value))
            }

            /// Sets the [`host_type` field](HostPong#structfield.host_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_type_as_default(self) -> HostPongBuilder<(T0, ::planus::DefaultValue)> {
                self.host_type(::planus::DefaultValue)
            }
        }

        impl<T0, T1> HostPongBuilder<(T0, T1)> {
            /// Setter for the [`listeners` field](HostPong#structfield.listeners).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn listeners<T2>(self, value: T2) -> HostPongBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Listener>]>>,
            {
                let (v0, v1) = self.0;
                HostPongBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> HostPongBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostPong].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostPong>
            where
                Self: ::planus::WriteAsOffset<HostPong>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Listener>]>>,
        > ::planus::WriteAs<::planus::Offset<HostPong>> for HostPongBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<HostPong>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Listener>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<HostPong>> for HostPongBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<HostPong>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Listener>]>>,
        > ::planus::WriteAsOffset<HostPong> for HostPongBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostPong> {
                let (v0, v1, v2) = &self.0;
                HostPong::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [HostPong].
        #[derive(Copy, Clone)]
        pub struct HostPongRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostPongRef<'a> {
            /// Getter for the [`timestamp` field](HostPong#structfield.timestamp).
            #[inline]
            pub fn timestamp(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(self.0.access(0, "HostPong", "timestamp")?.unwrap_or(0))
            }

            /// Getter for the [`host_type` field](HostPong#structfield.host_type).
            #[inline]
            pub fn host_type(&self) -> ::planus::Result<self::HostType> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "HostPong", "host_type")?
                        .unwrap_or(self::HostType::Tcp),
                )
            }

            /// Getter for the [`listeners` field](HostPong#structfield.listeners).
            #[inline]
            pub fn listeners(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::ListenerRef<'a>>>>
            {
                self.0.access_required(2, "HostPong", "listeners")
            }
        }

        impl<'a> ::core::fmt::Debug for HostPongRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostPongRef");
                f.field("timestamp", &self.timestamp());
                f.field("host_type", &self.host_type());
                f.field("listeners", &self.listeners());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostPongRef<'a>> for HostPong {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostPongRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                    host_type: ::core::convert::TryInto::try_into(value.host_type()?)?,
                    listeners: value.listeners()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostPongRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostPongRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[HostPongRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostPong>> for HostPong {
            type Value = ::planus::Offset<HostPong>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostPong>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostPongRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HostPongRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Listener` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Listener` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:720`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Listener {
            /// The field `handler_object` in the table `Listener`
            pub handler_object: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `socket_addr` in the table `Listener`
            pub socket_addr: ::planus::alloc::string::String,
        }

        impl Listener {
            /// Creates a [ListenerBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ListenerBuilder<()> {
                ListenerBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_handler_object: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_socket_addr: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_handler_object = field_handler_object.prepare(builder);
                let prepared_socket_addr = field_socket_addr.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_handler_object);
                        object_writer.write::<_, _, 4>(&prepared_socket_addr);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Listener>> for Listener {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Listener> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Listener>> for Listener {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Listener>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Listener> for Listener {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Listener> {
                Listener::create(builder, &self.handler_object, &self.socket_addr)
            }
        }

        /// Builder for serializing an instance of the [Listener] type.
        ///
        /// Can be created using the [Listener::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ListenerBuilder<State>(State);

        impl ListenerBuilder<()> {
            /// Setter for the [`handler_object` field](Listener#structfield.handler_object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn handler_object<T0>(self, value: T0) -> ListenerBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                ListenerBuilder((value,))
            }
        }

        impl<T0> ListenerBuilder<(T0,)> {
            /// Setter for the [`socket_addr` field](Listener#structfield.socket_addr).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn socket_addr<T1>(self, value: T1) -> ListenerBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                ListenerBuilder((v0, value))
            }
        }

        impl<T0, T1> ListenerBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Listener].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Listener>
            where
                Self: ::planus::WriteAsOffset<Listener>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<Listener>> for ListenerBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<Listener>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Listener> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<Listener>> for ListenerBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<Listener>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Listener>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<Listener> for ListenerBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Listener> {
                let (v0, v1) = &self.0;
                Listener::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [Listener].
        #[derive(Copy, Clone)]
        pub struct ListenerRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ListenerRef<'a> {
            /// Getter for the [`handler_object` field](Listener#structfield.handler_object).
            #[inline]
            pub fn handler_object(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "Listener", "handler_object")
            }

            /// Getter for the [`socket_addr` field](Listener#structfield.socket_addr).
            #[inline]
            pub fn socket_addr(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "Listener", "socket_addr")
            }
        }

        impl<'a> ::core::fmt::Debug for ListenerRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ListenerRef");
                f.field("handler_object", &self.handler_object());
                f.field("socket_addr", &self.socket_addr());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ListenerRef<'a>> for Listener {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ListenerRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    handler_object: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.handler_object()?)?,
                    ),
                    socket_addr: ::core::convert::Into::into(value.socket_addr()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ListenerRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ListenerRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[ListenerRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Listener>> for Listener {
            type Value = ::planus::Offset<Listener>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Listener>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ListenerRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ListenerRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `HostToDaemonMessage` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostToDaemonMessage` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:725`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostToDaemonMessage {
            /// The field `message` in the table `HostToDaemonMessage`
            pub message: self::HostToDaemonMessageUnion,
        }

        impl HostToDaemonMessage {
            /// Creates a [HostToDaemonMessageBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostToDaemonMessageBuilder<()> {
                HostToDaemonMessageBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAsUnion<self::HostToDaemonMessageUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::HostToDaemonMessageUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message.offset());
                        object_writer.write::<_, _, 1>(&prepared_message.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostToDaemonMessage>> for HostToDaemonMessage {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostToDaemonMessage> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostToDaemonMessage>> for HostToDaemonMessage {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostToDaemonMessage>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostToDaemonMessage> for HostToDaemonMessage {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostToDaemonMessage> {
                HostToDaemonMessage::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [HostToDaemonMessage] type.
        ///
        /// Can be created using the [HostToDaemonMessage::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostToDaemonMessageBuilder<State>(State);

        impl HostToDaemonMessageBuilder<()> {
            /// Setter for the [`message` field](HostToDaemonMessage#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> HostToDaemonMessageBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::HostToDaemonMessageUnion>,
            {
                HostToDaemonMessageBuilder((value,))
            }
        }

        impl<T0> HostToDaemonMessageBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostToDaemonMessage].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostToDaemonMessage>
            where
                Self: ::planus::WriteAsOffset<HostToDaemonMessage>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HostToDaemonMessageUnion>>
            ::planus::WriteAs<::planus::Offset<HostToDaemonMessage>>
            for HostToDaemonMessageBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostToDaemonMessage>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostToDaemonMessage> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HostToDaemonMessageUnion>>
            ::planus::WriteAsOptional<::planus::Offset<HostToDaemonMessage>>
            for HostToDaemonMessageBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostToDaemonMessage>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostToDaemonMessage>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HostToDaemonMessageUnion>>
            ::planus::WriteAsOffset<HostToDaemonMessage> for HostToDaemonMessageBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostToDaemonMessage> {
                let (v0,) = &self.0;
                HostToDaemonMessage::create(builder, v0)
            }
        }

        /// Reference to a deserialized [HostToDaemonMessage].
        #[derive(Copy, Clone)]
        pub struct HostToDaemonMessageRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostToDaemonMessageRef<'a> {
            /// Getter for the [`message` field](HostToDaemonMessage#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<self::HostToDaemonMessageUnionRef<'a>> {
                self.0
                    .access_union_required(0, "HostToDaemonMessage", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for HostToDaemonMessageRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostToDaemonMessageRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostToDaemonMessageRef<'a>> for HostToDaemonMessage {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostToDaemonMessageRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::TryInto::try_into(value.message()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostToDaemonMessageRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostToDaemonMessageRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostToDaemonMessageRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostToDaemonMessage>> for HostToDaemonMessage {
            type Value = ::planus::Offset<HostToDaemonMessage>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostToDaemonMessage>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostToDaemonMessageRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HostToDaemonMessageRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `DaemonToHostReplyUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `DaemonToHostReplyUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:733`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum DaemonToHostReplyUnion {
            /// The variant of type `DaemonToHostAck` in the union `DaemonToHostReplyUnion`
            DaemonToHostAck(::planus::alloc::boxed::Box<self::DaemonToHostAck>),

            /// The variant of type `DaemonToHostReject` in the union `DaemonToHostReplyUnion`
            DaemonToHostReject(::planus::alloc::boxed::Box<self::DaemonToHostReject>),

            /// The variant of type `DaemonToHostPerfCounters` in the union `DaemonToHostReplyUnion`
            DaemonToHostPerfCounters(::planus::alloc::boxed::Box<self::DaemonToHostPerfCounters>),
        }

        impl DaemonToHostReplyUnion {
            /// Creates a [DaemonToHostReplyUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToHostReplyUnionBuilder<::planus::Uninitialized> {
                DaemonToHostReplyUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_daemon_to_host_ack(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DaemonToHostAck>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_daemon_to_host_reject(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DaemonToHostReject>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_daemon_to_host_perf_counters(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DaemonToHostPerfCounters>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<DaemonToHostReplyUnion> for DaemonToHostReplyUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::DaemonToHostAck(value) => Self::create_daemon_to_host_ack(builder, value),
                    Self::DaemonToHostReject(value) => {
                        Self::create_daemon_to_host_reject(builder, value)
                    }
                    Self::DaemonToHostPerfCounters(value) => {
                        Self::create_daemon_to_host_perf_counters(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<DaemonToHostReplyUnion> for DaemonToHostReplyUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [DaemonToHostReplyUnion] type.
        ///
        /// Can be created using the [DaemonToHostReplyUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToHostReplyUnionBuilder<T>(T);

        impl DaemonToHostReplyUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`DaemonToHostAck` variant](DaemonToHostReplyUnion#variant.DaemonToHostAck).
            #[inline]
            pub fn daemon_to_host_ack<T>(
                self,
                value: T,
            ) -> DaemonToHostReplyUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::DaemonToHostAck>,
            {
                DaemonToHostReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DaemonToHostReject` variant](DaemonToHostReplyUnion#variant.DaemonToHostReject).
            #[inline]
            pub fn daemon_to_host_reject<T>(
                self,
                value: T,
            ) -> DaemonToHostReplyUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::DaemonToHostReject>,
            {
                DaemonToHostReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DaemonToHostPerfCounters` variant](DaemonToHostReplyUnion#variant.DaemonToHostPerfCounters).
            #[inline]
            pub fn daemon_to_host_perf_counters<T>(
                self,
                value: T,
            ) -> DaemonToHostReplyUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::DaemonToHostPerfCounters>,
            {
                DaemonToHostReplyUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> DaemonToHostReplyUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [DaemonToHostReplyUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToHostReplyUnion>
            where
                Self: ::planus::WriteAsUnion<DaemonToHostReplyUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<DaemonToHostReplyUnion>
            for DaemonToHostReplyUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::DaemonToHostAck>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToHostReplyUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToHostReplyUnion>
            for DaemonToHostReplyUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::DaemonToHostAck>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToHostReplyUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToHostReplyUnion>
            for DaemonToHostReplyUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::DaemonToHostReject>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToHostReplyUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToHostReplyUnion>
            for DaemonToHostReplyUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::DaemonToHostReject>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToHostReplyUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToHostReplyUnion>
            for DaemonToHostReplyUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::DaemonToHostPerfCounters>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToHostReplyUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToHostReplyUnion>
            for DaemonToHostReplyUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::DaemonToHostPerfCounters>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToHostReplyUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [DaemonToHostReplyUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum DaemonToHostReplyUnionRef<'a> {
            DaemonToHostAck(self::DaemonToHostAckRef<'a>),
            DaemonToHostReject(self::DaemonToHostRejectRef<'a>),
            DaemonToHostPerfCounters(self::DaemonToHostPerfCountersRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<DaemonToHostReplyUnionRef<'a>> for DaemonToHostReplyUnion {
            type Error = ::planus::Error;

            fn try_from(value: DaemonToHostReplyUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    DaemonToHostReplyUnionRef::DaemonToHostAck(value) => {
                        Self::DaemonToHostAck(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToHostReplyUnionRef::DaemonToHostReject(value) => {
                        Self::DaemonToHostReject(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToHostReplyUnionRef::DaemonToHostPerfCounters(value) => {
                        Self::DaemonToHostPerfCounters(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for DaemonToHostReplyUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::DaemonToHostAck(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::DaemonToHostReject(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::DaemonToHostPerfCounters(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for DaemonToHostReplyUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[DaemonToHostReplyUnionRef]";
        }

        /// The table `DaemonToHostAck` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DaemonToHostAck` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:739`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DaemonToHostAck {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DaemonToHostAck {
            fn default() -> Self {
                Self {}
            }
        }

        impl DaemonToHostAck {
            /// Creates a [DaemonToHostAckBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToHostAckBuilder<()> {
                DaemonToHostAckBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DaemonToHostAck>> for DaemonToHostAck {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostAck> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DaemonToHostAck>> for DaemonToHostAck {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToHostAck>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DaemonToHostAck> for DaemonToHostAck {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostAck> {
                DaemonToHostAck::create(builder)
            }
        }

        /// Builder for serializing an instance of the [DaemonToHostAck] type.
        ///
        /// Can be created using the [DaemonToHostAck::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToHostAckBuilder<State>(State);

        impl DaemonToHostAckBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DaemonToHostAck].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostAck>
            where
                Self: ::planus::WriteAsOffset<DaemonToHostAck>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DaemonToHostAck>> for DaemonToHostAckBuilder<()> {
            type Prepared = ::planus::Offset<DaemonToHostAck>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostAck> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DaemonToHostAck>> for DaemonToHostAckBuilder<()> {
            type Prepared = ::planus::Offset<DaemonToHostAck>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToHostAck>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DaemonToHostAck> for DaemonToHostAckBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostAck> {
                DaemonToHostAck::create(builder)
            }
        }

        /// Reference to a deserialized [DaemonToHostAck].
        #[derive(Copy, Clone)]
        pub struct DaemonToHostAckRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DaemonToHostAckRef<'a> {}

        impl<'a> ::core::fmt::Debug for DaemonToHostAckRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DaemonToHostAckRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DaemonToHostAckRef<'a>> for DaemonToHostAck {
            type Error = ::planus::Error;

            fn try_from(_value: DaemonToHostAckRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for DaemonToHostAckRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DaemonToHostAckRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DaemonToHostAckRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DaemonToHostAck>> for DaemonToHostAck {
            type Value = ::planus::Offset<DaemonToHostAck>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DaemonToHostAck>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DaemonToHostAckRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DaemonToHostAckRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DaemonToHostReject` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DaemonToHostReject` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:742`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DaemonToHostReject {
            /// The field `reason` in the table `DaemonToHostReject`
            pub reason: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DaemonToHostReject {
            fn default() -> Self {
                Self {
                    reason: ::core::default::Default::default(),
                }
            }
        }

        impl DaemonToHostReject {
            /// Creates a [DaemonToHostRejectBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToHostRejectBuilder<()> {
                DaemonToHostRejectBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_reason: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_reason = field_reason.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_reason);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DaemonToHostReject>> for DaemonToHostReject {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostReject> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DaemonToHostReject>> for DaemonToHostReject {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToHostReject>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DaemonToHostReject> for DaemonToHostReject {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostReject> {
                DaemonToHostReject::create(builder, &self.reason)
            }
        }

        /// Builder for serializing an instance of the [DaemonToHostReject] type.
        ///
        /// Can be created using the [DaemonToHostReject::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToHostRejectBuilder<State>(State);

        impl DaemonToHostRejectBuilder<()> {
            /// Setter for the [`reason` field](DaemonToHostReject#structfield.reason).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn reason<T0>(self, value: T0) -> DaemonToHostRejectBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                DaemonToHostRejectBuilder((value,))
            }
        }

        impl<T0> DaemonToHostRejectBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DaemonToHostReject].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostReject>
            where
                Self: ::planus::WriteAsOffset<DaemonToHostReject>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAs<::planus::Offset<DaemonToHostReject>>
            for DaemonToHostRejectBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DaemonToHostReject>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostReject> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOptional<::planus::Offset<DaemonToHostReject>>
            for DaemonToHostRejectBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DaemonToHostReject>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToHostReject>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
            ::planus::WriteAsOffset<DaemonToHostReject> for DaemonToHostRejectBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostReject> {
                let (v0,) = &self.0;
                DaemonToHostReject::create(builder, v0)
            }
        }

        /// Reference to a deserialized [DaemonToHostReject].
        #[derive(Copy, Clone)]
        pub struct DaemonToHostRejectRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DaemonToHostRejectRef<'a> {
            /// Getter for the [`reason` field](DaemonToHostReject#structfield.reason).
            #[inline]
            pub fn reason(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(0, "DaemonToHostReject", "reason")
            }
        }

        impl<'a> ::core::fmt::Debug for DaemonToHostRejectRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DaemonToHostRejectRef");
                f.field("reason", &self.reason());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DaemonToHostRejectRef<'a>> for DaemonToHostReject {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DaemonToHostRejectRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    reason: ::core::convert::Into::into(value.reason()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DaemonToHostRejectRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DaemonToHostRejectRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DaemonToHostRejectRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DaemonToHostReject>> for DaemonToHostReject {
            type Value = ::planus::Offset<DaemonToHostReject>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DaemonToHostReject>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DaemonToHostRejectRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DaemonToHostRejectRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Counter` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Counter` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:746`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Counter {
            /// The field `name` in the table `Counter`
            pub name: ::planus::alloc::boxed::Box<self::Symbol>,
            /// The field `count` in the table `Counter`
            pub count: i64,
            /// The field `total_cumulative_ns` in the table `Counter`
            pub total_cumulative_ns: i64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Counter {
            fn default() -> Self {
                Self {
                    name: ::core::default::Default::default(),
                    count: 0,
                    total_cumulative_ns: 0,
                }
            }
        }

        impl Counter {
            /// Creates a [CounterBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CounterBuilder<()> {
                CounterBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_name: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
                field_count: impl ::planus::WriteAsDefault<i64, i64>,
                field_total_cumulative_ns: impl ::planus::WriteAsDefault<i64, i64>,
            ) -> ::planus::Offset<Self> {
                let prepared_name = field_name.prepare(builder);
                let prepared_count = field_count.prepare(builder, &0);
                let prepared_total_cumulative_ns = field_total_cumulative_ns.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                if prepared_count.is_some() {
                    table_writer.write_entry::<i64>(1);
                }
                if prepared_total_cumulative_ns.is_some() {
                    table_writer.write_entry::<i64>(2);
                }
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_count) = prepared_count {
                            object_writer.write::<_, _, 8>(&prepared_count);
                        }
                        if let ::core::option::Option::Some(prepared_total_cumulative_ns) =
                            prepared_total_cumulative_ns
                        {
                            object_writer.write::<_, _, 8>(&prepared_total_cumulative_ns);
                        }
                        object_writer.write::<_, _, 4>(&prepared_name);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Counter>> for Counter {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Counter> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Counter>> for Counter {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Counter>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Counter> for Counter {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Counter> {
                Counter::create(builder, &self.name, self.count, self.total_cumulative_ns)
            }
        }

        /// Builder for serializing an instance of the [Counter] type.
        ///
        /// Can be created using the [Counter::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CounterBuilder<State>(State);

        impl CounterBuilder<()> {
            /// Setter for the [`name` field](Counter#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T0>(self, value: T0) -> CounterBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                CounterBuilder((value,))
            }
        }

        impl<T0> CounterBuilder<(T0,)> {
            /// Setter for the [`count` field](Counter#structfield.count).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn count<T1>(self, value: T1) -> CounterBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<i64, i64>,
            {
                let (v0,) = self.0;
                CounterBuilder((v0, value))
            }

            /// Sets the [`count` field](Counter#structfield.count) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn count_as_default(self) -> CounterBuilder<(T0, ::planus::DefaultValue)> {
                self.count(::planus::DefaultValue)
            }
        }

        impl<T0, T1> CounterBuilder<(T0, T1)> {
            /// Setter for the [`total_cumulative_ns` field](Counter#structfield.total_cumulative_ns).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn total_cumulative_ns<T2>(self, value: T2) -> CounterBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<i64, i64>,
            {
                let (v0, v1) = self.0;
                CounterBuilder((v0, v1, value))
            }

            /// Sets the [`total_cumulative_ns` field](Counter#structfield.total_cumulative_ns) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn total_cumulative_ns_as_default(
                self,
            ) -> CounterBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.total_cumulative_ns(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> CounterBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Counter].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Counter>
            where
                Self: ::planus::WriteAsOffset<Counter>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T1: ::planus::WriteAsDefault<i64, i64>,
            T2: ::planus::WriteAsDefault<i64, i64>,
        > ::planus::WriteAs<::planus::Offset<Counter>> for CounterBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<Counter>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Counter> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T1: ::planus::WriteAsDefault<i64, i64>,
            T2: ::planus::WriteAsDefault<i64, i64>,
        > ::planus::WriteAsOptional<::planus::Offset<Counter>> for CounterBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<Counter>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Counter>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T1: ::planus::WriteAsDefault<i64, i64>,
            T2: ::planus::WriteAsDefault<i64, i64>,
        > ::planus::WriteAsOffset<Counter> for CounterBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Counter> {
                let (v0, v1, v2) = &self.0;
                Counter::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [Counter].
        #[derive(Copy, Clone)]
        pub struct CounterRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CounterRef<'a> {
            /// Getter for the [`name` field](Counter#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(0, "Counter", "name")
            }

            /// Getter for the [`count` field](Counter#structfield.count).
            #[inline]
            pub fn count(&self) -> ::planus::Result<i64> {
                ::core::result::Result::Ok(self.0.access(1, "Counter", "count")?.unwrap_or(0))
            }

            /// Getter for the [`total_cumulative_ns` field](Counter#structfield.total_cumulative_ns).
            #[inline]
            pub fn total_cumulative_ns(&self) -> ::planus::Result<i64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "Counter", "total_cumulative_ns")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for CounterRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CounterRef");
                f.field("name", &self.name());
                f.field("count", &self.count());
                f.field("total_cumulative_ns", &self.total_cumulative_ns());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CounterRef<'a>> for Counter {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CounterRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.name()?,
                    )?),
                    count: ::core::convert::TryInto::try_into(value.count()?)?,
                    total_cumulative_ns: ::core::convert::TryInto::try_into(
                        value.total_cumulative_ns()?,
                    )?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CounterRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CounterRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[CounterRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Counter>> for Counter {
            type Value = ::planus::Offset<Counter>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Counter>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CounterRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CounterRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `CounterCategory` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `CounterCategory` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:752`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CounterCategory {
            /// The field `category` in the table `CounterCategory`
            pub category: ::planus::alloc::boxed::Box<self::Symbol>,
            /// The field `counters` in the table `CounterCategory`
            pub counters: ::planus::alloc::vec::Vec<self::Counter>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for CounterCategory {
            fn default() -> Self {
                Self {
                    category: ::core::default::Default::default(),
                    counters: ::core::default::Default::default(),
                }
            }
        }

        impl CounterCategory {
            /// Creates a [CounterCategoryBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CounterCategoryBuilder<()> {
                CounterCategoryBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_category: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
                field_counters: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::Counter>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_category = field_category.prepare(builder);
                let prepared_counters = field_counters.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(0);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::Counter>]>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_category);
                        object_writer.write::<_, _, 4>(&prepared_counters);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CounterCategory>> for CounterCategory {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CounterCategory> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CounterCategory>> for CounterCategory {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CounterCategory>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CounterCategory> for CounterCategory {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CounterCategory> {
                CounterCategory::create(builder, &self.category, &self.counters)
            }
        }

        /// Builder for serializing an instance of the [CounterCategory] type.
        ///
        /// Can be created using the [CounterCategory::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CounterCategoryBuilder<State>(State);

        impl CounterCategoryBuilder<()> {
            /// Setter for the [`category` field](CounterCategory#structfield.category).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn category<T0>(self, value: T0) -> CounterCategoryBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                CounterCategoryBuilder((value,))
            }
        }

        impl<T0> CounterCategoryBuilder<(T0,)> {
            /// Setter for the [`counters` field](CounterCategory#structfield.counters).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn counters<T1>(self, value: T1) -> CounterCategoryBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Counter>]>>,
            {
                let (v0,) = self.0;
                CounterCategoryBuilder((v0, value))
            }
        }

        impl<T0, T1> CounterCategoryBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CounterCategory].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CounterCategory>
            where
                Self: ::planus::WriteAsOffset<CounterCategory>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Counter>]>>,
        > ::planus::WriteAs<::planus::Offset<CounterCategory>>
            for CounterCategoryBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<CounterCategory>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CounterCategory> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Counter>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<CounterCategory>>
            for CounterCategoryBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<CounterCategory>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CounterCategory>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Counter>]>>,
        > ::planus::WriteAsOffset<CounterCategory> for CounterCategoryBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CounterCategory> {
                let (v0, v1) = &self.0;
                CounterCategory::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [CounterCategory].
        #[derive(Copy, Clone)]
        pub struct CounterCategoryRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CounterCategoryRef<'a> {
            /// Getter for the [`category` field](CounterCategory#structfield.category).
            #[inline]
            pub fn category(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(0, "CounterCategory", "category")
            }

            /// Getter for the [`counters` field](CounterCategory#structfield.counters).
            #[inline]
            pub fn counters(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::CounterRef<'a>>>>
            {
                self.0.access_required(1, "CounterCategory", "counters")
            }
        }

        impl<'a> ::core::fmt::Debug for CounterCategoryRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CounterCategoryRef");
                f.field("category", &self.category());
                f.field("counters", &self.counters());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CounterCategoryRef<'a>> for CounterCategory {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CounterCategoryRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    category: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.category()?,
                    )?),
                    counters: value.counters()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CounterCategoryRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CounterCategoryRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CounterCategoryRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CounterCategory>> for CounterCategory {
            type Value = ::planus::Offset<CounterCategory>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CounterCategory>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CounterCategoryRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CounterCategoryRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DaemonToHostPerfCounters` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DaemonToHostPerfCounters` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:757`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DaemonToHostPerfCounters {
            /// The field `timestamp` in the table `DaemonToHostPerfCounters`
            pub timestamp: u64,
            /// The field `counters` in the table `DaemonToHostPerfCounters`
            pub counters: ::planus::alloc::vec::Vec<self::CounterCategory>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DaemonToHostPerfCounters {
            fn default() -> Self {
                Self {
                    timestamp: 0,
                    counters: ::core::default::Default::default(),
                }
            }
        }

        impl DaemonToHostPerfCounters {
            /// Creates a [DaemonToHostPerfCountersBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToHostPerfCountersBuilder<()> {
                DaemonToHostPerfCountersBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                field_counters: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::CounterCategory>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_timestamp = field_timestamp.prepare(builder, &0);
                let prepared_counters = field_counters.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_timestamp.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::CounterCategory>]>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            object_writer.write::<_, _, 8>(&prepared_timestamp);
                        }
                        object_writer.write::<_, _, 4>(&prepared_counters);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DaemonToHostPerfCounters>> for DaemonToHostPerfCounters {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostPerfCounters> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DaemonToHostPerfCounters>>
            for DaemonToHostPerfCounters
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToHostPerfCounters>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DaemonToHostPerfCounters> for DaemonToHostPerfCounters {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostPerfCounters> {
                DaemonToHostPerfCounters::create(builder, self.timestamp, &self.counters)
            }
        }

        /// Builder for serializing an instance of the [DaemonToHostPerfCounters] type.
        ///
        /// Can be created using the [DaemonToHostPerfCounters::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToHostPerfCountersBuilder<State>(State);

        impl DaemonToHostPerfCountersBuilder<()> {
            /// Setter for the [`timestamp` field](DaemonToHostPerfCounters#structfield.timestamp).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp<T0>(self, value: T0) -> DaemonToHostPerfCountersBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                DaemonToHostPerfCountersBuilder((value,))
            }

            /// Sets the [`timestamp` field](DaemonToHostPerfCounters#structfield.timestamp) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp_as_default(
                self,
            ) -> DaemonToHostPerfCountersBuilder<(::planus::DefaultValue,)> {
                self.timestamp(::planus::DefaultValue)
            }
        }

        impl<T0> DaemonToHostPerfCountersBuilder<(T0,)> {
            /// Setter for the [`counters` field](DaemonToHostPerfCounters#structfield.counters).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn counters<T1>(self, value: T1) -> DaemonToHostPerfCountersBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::CounterCategory>]>>,
            {
                let (v0,) = self.0;
                DaemonToHostPerfCountersBuilder((v0, value))
            }
        }

        impl<T0, T1> DaemonToHostPerfCountersBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DaemonToHostPerfCounters].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostPerfCounters>
            where
                Self: ::planus::WriteAsOffset<DaemonToHostPerfCounters>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::CounterCategory>]>>,
        > ::planus::WriteAs<::planus::Offset<DaemonToHostPerfCounters>>
            for DaemonToHostPerfCountersBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DaemonToHostPerfCounters>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostPerfCounters> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::CounterCategory>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<DaemonToHostPerfCounters>>
            for DaemonToHostPerfCountersBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<DaemonToHostPerfCounters>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToHostPerfCounters>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::CounterCategory>]>>,
        > ::planus::WriteAsOffset<DaemonToHostPerfCounters>
            for DaemonToHostPerfCountersBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostPerfCounters> {
                let (v0, v1) = &self.0;
                DaemonToHostPerfCounters::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [DaemonToHostPerfCounters].
        #[derive(Copy, Clone)]
        pub struct DaemonToHostPerfCountersRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DaemonToHostPerfCountersRef<'a> {
            /// Getter for the [`timestamp` field](DaemonToHostPerfCounters#structfield.timestamp).
            #[inline]
            pub fn timestamp(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "DaemonToHostPerfCounters", "timestamp")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`counters` field](DaemonToHostPerfCounters#structfield.counters).
            #[inline]
            pub fn counters(
                &self,
            ) -> ::planus::Result<
                ::planus::Vector<'a, ::planus::Result<self::CounterCategoryRef<'a>>>,
            > {
                self.0
                    .access_required(1, "DaemonToHostPerfCounters", "counters")
            }
        }

        impl<'a> ::core::fmt::Debug for DaemonToHostPerfCountersRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DaemonToHostPerfCountersRef");
                f.field("timestamp", &self.timestamp());
                f.field("counters", &self.counters());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DaemonToHostPerfCountersRef<'a>> for DaemonToHostPerfCounters {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DaemonToHostPerfCountersRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                    counters: value.counters()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DaemonToHostPerfCountersRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DaemonToHostPerfCountersRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DaemonToHostPerfCountersRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DaemonToHostPerfCounters>>
            for DaemonToHostPerfCounters
        {
            type Value = ::planus::Offset<DaemonToHostPerfCounters>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DaemonToHostPerfCounters>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DaemonToHostPerfCountersRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DaemonToHostPerfCountersRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `DaemonToHostReply` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DaemonToHostReply` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:762`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DaemonToHostReply {
            /// The field `reply` in the table `DaemonToHostReply`
            pub reply: self::DaemonToHostReplyUnion,
        }

        impl DaemonToHostReply {
            /// Creates a [DaemonToHostReplyBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToHostReplyBuilder<()> {
                DaemonToHostReplyBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_reply: impl ::planus::WriteAsUnion<self::DaemonToHostReplyUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_reply = field_reply.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::DaemonToHostReplyUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_reply.offset());
                        object_writer.write::<_, _, 1>(&prepared_reply.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DaemonToHostReply>> for DaemonToHostReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DaemonToHostReply>> for DaemonToHostReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToHostReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DaemonToHostReply> for DaemonToHostReply {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostReply> {
                DaemonToHostReply::create(builder, &self.reply)
            }
        }

        /// Builder for serializing an instance of the [DaemonToHostReply] type.
        ///
        /// Can be created using the [DaemonToHostReply::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToHostReplyBuilder<State>(State);

        impl DaemonToHostReplyBuilder<()> {
            /// Setter for the [`reply` field](DaemonToHostReply#structfield.reply).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn reply<T0>(self, value: T0) -> DaemonToHostReplyBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::DaemonToHostReplyUnion>,
            {
                DaemonToHostReplyBuilder((value,))
            }
        }

        impl<T0> DaemonToHostReplyBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DaemonToHostReply].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostReply>
            where
                Self: ::planus::WriteAsOffset<DaemonToHostReply>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToHostReplyUnion>>
            ::planus::WriteAs<::planus::Offset<DaemonToHostReply>>
            for DaemonToHostReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DaemonToHostReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToHostReplyUnion>>
            ::planus::WriteAsOptional<::planus::Offset<DaemonToHostReply>>
            for DaemonToHostReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DaemonToHostReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToHostReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToHostReplyUnion>>
            ::planus::WriteAsOffset<DaemonToHostReply> for DaemonToHostReplyBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToHostReply> {
                let (v0,) = &self.0;
                DaemonToHostReply::create(builder, v0)
            }
        }

        /// Reference to a deserialized [DaemonToHostReply].
        #[derive(Copy, Clone)]
        pub struct DaemonToHostReplyRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DaemonToHostReplyRef<'a> {
            /// Getter for the [`reply` field](DaemonToHostReply#structfield.reply).
            #[inline]
            pub fn reply(&self) -> ::planus::Result<self::DaemonToHostReplyUnionRef<'a>> {
                self.0
                    .access_union_required(0, "DaemonToHostReply", "reply")
            }
        }

        impl<'a> ::core::fmt::Debug for DaemonToHostReplyRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DaemonToHostReplyRef");
                f.field("reply", &self.reply());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DaemonToHostReplyRef<'a>> for DaemonToHostReply {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DaemonToHostReplyRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    reply: ::core::convert::TryInto::try_into(value.reply()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DaemonToHostReplyRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DaemonToHostReplyRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DaemonToHostReplyRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DaemonToHostReply>> for DaemonToHostReply {
            type Value = ::planus::Offset<DaemonToHostReply>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DaemonToHostReply>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DaemonToHostReplyRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DaemonToHostReplyRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `HostBroadcastEventUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `HostBroadcastEventUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:770`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum HostBroadcastEventUnion {
            /// The variant of type `HostBroadcastListen` in the union `HostBroadcastEventUnion`
            HostBroadcastListen(::planus::alloc::boxed::Box<self::HostBroadcastListen>),

            /// The variant of type `HostBroadcastUnlisten` in the union `HostBroadcastEventUnion`
            HostBroadcastUnlisten(::planus::alloc::boxed::Box<self::HostBroadcastUnlisten>),

            /// The variant of type `HostBroadcastPingPong` in the union `HostBroadcastEventUnion`
            HostBroadcastPingPong(::planus::alloc::boxed::Box<self::HostBroadcastPingPong>),
        }

        impl HostBroadcastEventUnion {
            /// Creates a [HostBroadcastEventUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostBroadcastEventUnionBuilder<::planus::Uninitialized> {
                HostBroadcastEventUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_host_broadcast_listen(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HostBroadcastListen>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_host_broadcast_unlisten(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HostBroadcastUnlisten>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_host_broadcast_ping_pong(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HostBroadcastPingPong>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<HostBroadcastEventUnion> for HostBroadcastEventUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::HostBroadcastListen(value) => {
                        Self::create_host_broadcast_listen(builder, value)
                    }
                    Self::HostBroadcastUnlisten(value) => {
                        Self::create_host_broadcast_unlisten(builder, value)
                    }
                    Self::HostBroadcastPingPong(value) => {
                        Self::create_host_broadcast_ping_pong(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<HostBroadcastEventUnion> for HostBroadcastEventUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [HostBroadcastEventUnion] type.
        ///
        /// Can be created using the [HostBroadcastEventUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostBroadcastEventUnionBuilder<T>(T);

        impl HostBroadcastEventUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`HostBroadcastListen` variant](HostBroadcastEventUnion#variant.HostBroadcastListen).
            #[inline]
            pub fn host_broadcast_listen<T>(
                self,
                value: T,
            ) -> HostBroadcastEventUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::HostBroadcastListen>,
            {
                HostBroadcastEventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`HostBroadcastUnlisten` variant](HostBroadcastEventUnion#variant.HostBroadcastUnlisten).
            #[inline]
            pub fn host_broadcast_unlisten<T>(
                self,
                value: T,
            ) -> HostBroadcastEventUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::HostBroadcastUnlisten>,
            {
                HostBroadcastEventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`HostBroadcastPingPong` variant](HostBroadcastEventUnion#variant.HostBroadcastPingPong).
            #[inline]
            pub fn host_broadcast_ping_pong<T>(
                self,
                value: T,
            ) -> HostBroadcastEventUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::HostBroadcastPingPong>,
            {
                HostBroadcastEventUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> HostBroadcastEventUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [HostBroadcastEventUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostBroadcastEventUnion>
            where
                Self: ::planus::WriteAsUnion<HostBroadcastEventUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<HostBroadcastEventUnion>
            for HostBroadcastEventUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::HostBroadcastListen>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostBroadcastEventUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostBroadcastEventUnion>
            for HostBroadcastEventUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::HostBroadcastListen>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostBroadcastEventUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostBroadcastEventUnion>
            for HostBroadcastEventUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::HostBroadcastUnlisten>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostBroadcastEventUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostBroadcastEventUnion>
            for HostBroadcastEventUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::HostBroadcastUnlisten>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostBroadcastEventUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostBroadcastEventUnion>
            for HostBroadcastEventUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::HostBroadcastPingPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostBroadcastEventUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostBroadcastEventUnion>
            for HostBroadcastEventUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::HostBroadcastPingPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostBroadcastEventUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [HostBroadcastEventUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum HostBroadcastEventUnionRef<'a> {
            HostBroadcastListen(self::HostBroadcastListenRef<'a>),
            HostBroadcastUnlisten(self::HostBroadcastUnlistenRef<'a>),
            HostBroadcastPingPong(self::HostBroadcastPingPongRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<HostBroadcastEventUnionRef<'a>> for HostBroadcastEventUnion {
            type Error = ::planus::Error;

            fn try_from(value: HostBroadcastEventUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    HostBroadcastEventUnionRef::HostBroadcastListen(value) => {
                        Self::HostBroadcastListen(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostBroadcastEventUnionRef::HostBroadcastUnlisten(value) => {
                        Self::HostBroadcastUnlisten(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostBroadcastEventUnionRef::HostBroadcastPingPong(value) => {
                        Self::HostBroadcastPingPong(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for HostBroadcastEventUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::HostBroadcastListen(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::HostBroadcastUnlisten(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::HostBroadcastPingPong(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for HostBroadcastEventUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[HostBroadcastEventUnionRef]";
        }

        /// The table `HostBroadcastListen` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostBroadcastListen` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:776`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostBroadcastListen {
            /// The field `handler_object` in the table `HostBroadcastListen`
            pub handler_object: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `host_type` in the table `HostBroadcastListen`
            pub host_type: self::HostType,
            /// The field `port` in the table `HostBroadcastListen`
            pub port: u16,
            /// The field `print_messages` in the table `HostBroadcastListen`
            pub print_messages: bool,
        }

        impl HostBroadcastListen {
            /// Creates a [HostBroadcastListenBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostBroadcastListenBuilder<()> {
                HostBroadcastListenBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_handler_object: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_host_type: impl ::planus::WriteAsDefault<self::HostType, self::HostType>,
                field_port: impl ::planus::WriteAsDefault<u16, u16>,
                field_print_messages: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_handler_object = field_handler_object.prepare(builder);
                let prepared_host_type = field_host_type.prepare(builder, &self::HostType::Tcp);
                let prepared_port = field_port.prepare(builder, &0);
                let prepared_print_messages = field_print_messages.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                if prepared_port.is_some() {
                    table_writer.write_entry::<u16>(2);
                }
                if prepared_host_type.is_some() {
                    table_writer.write_entry::<self::HostType>(1);
                }
                if prepared_print_messages.is_some() {
                    table_writer.write_entry::<bool>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_handler_object);
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            object_writer.write::<_, _, 2>(&prepared_port);
                        }
                        if let ::core::option::Option::Some(prepared_host_type) = prepared_host_type
                        {
                            object_writer.write::<_, _, 1>(&prepared_host_type);
                        }
                        if let ::core::option::Option::Some(prepared_print_messages) =
                            prepared_print_messages
                        {
                            object_writer.write::<_, _, 1>(&prepared_print_messages);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostBroadcastListen>> for HostBroadcastListen {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastListen> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostBroadcastListen>> for HostBroadcastListen {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostBroadcastListen>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostBroadcastListen> for HostBroadcastListen {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastListen> {
                HostBroadcastListen::create(
                    builder,
                    &self.handler_object,
                    self.host_type,
                    self.port,
                    self.print_messages,
                )
            }
        }

        /// Builder for serializing an instance of the [HostBroadcastListen] type.
        ///
        /// Can be created using the [HostBroadcastListen::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostBroadcastListenBuilder<State>(State);

        impl HostBroadcastListenBuilder<()> {
            /// Setter for the [`handler_object` field](HostBroadcastListen#structfield.handler_object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn handler_object<T0>(self, value: T0) -> HostBroadcastListenBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                HostBroadcastListenBuilder((value,))
            }
        }

        impl<T0> HostBroadcastListenBuilder<(T0,)> {
            /// Setter for the [`host_type` field](HostBroadcastListen#structfield.host_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_type<T1>(self, value: T1) -> HostBroadcastListenBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            {
                let (v0,) = self.0;
                HostBroadcastListenBuilder((v0, value))
            }

            /// Sets the [`host_type` field](HostBroadcastListen#structfield.host_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_type_as_default(
                self,
            ) -> HostBroadcastListenBuilder<(T0, ::planus::DefaultValue)> {
                self.host_type(::planus::DefaultValue)
            }
        }

        impl<T0, T1> HostBroadcastListenBuilder<(T0, T1)> {
            /// Setter for the [`port` field](HostBroadcastListen#structfield.port).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn port<T2>(self, value: T2) -> HostBroadcastListenBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1) = self.0;
                HostBroadcastListenBuilder((v0, v1, value))
            }

            /// Sets the [`port` field](HostBroadcastListen#structfield.port) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn port_as_default(
                self,
            ) -> HostBroadcastListenBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.port(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> HostBroadcastListenBuilder<(T0, T1, T2)> {
            /// Setter for the [`print_messages` field](HostBroadcastListen#structfield.print_messages).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn print_messages<T3>(
                self,
                value: T3,
            ) -> HostBroadcastListenBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2) = self.0;
                HostBroadcastListenBuilder((v0, v1, v2, value))
            }

            /// Sets the [`print_messages` field](HostBroadcastListen#structfield.print_messages) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn print_messages_as_default(
                self,
            ) -> HostBroadcastListenBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.print_messages(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> HostBroadcastListenBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostBroadcastListen].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastListen>
            where
                Self: ::planus::WriteAsOffset<HostBroadcastListen>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T2: ::planus::WriteAsDefault<u16, u16>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAs<::planus::Offset<HostBroadcastListen>>
            for HostBroadcastListenBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<HostBroadcastListen>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastListen> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T2: ::planus::WriteAsDefault<u16, u16>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOptional<::planus::Offset<HostBroadcastListen>>
            for HostBroadcastListenBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<HostBroadcastListen>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostBroadcastListen>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T2: ::planus::WriteAsDefault<u16, u16>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOffset<HostBroadcastListen>
            for HostBroadcastListenBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastListen> {
                let (v0, v1, v2, v3) = &self.0;
                HostBroadcastListen::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [HostBroadcastListen].
        #[derive(Copy, Clone)]
        pub struct HostBroadcastListenRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostBroadcastListenRef<'a> {
            /// Getter for the [`handler_object` field](HostBroadcastListen#structfield.handler_object).
            #[inline]
            pub fn handler_object(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(0, "HostBroadcastListen", "handler_object")
            }

            /// Getter for the [`host_type` field](HostBroadcastListen#structfield.host_type).
            #[inline]
            pub fn host_type(&self) -> ::planus::Result<self::HostType> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "HostBroadcastListen", "host_type")?
                        .unwrap_or(self::HostType::Tcp),
                )
            }

            /// Getter for the [`port` field](HostBroadcastListen#structfield.port).
            #[inline]
            pub fn port(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "HostBroadcastListen", "port")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`print_messages` field](HostBroadcastListen#structfield.print_messages).
            #[inline]
            pub fn print_messages(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "HostBroadcastListen", "print_messages")?
                        .unwrap_or(false),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for HostBroadcastListenRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostBroadcastListenRef");
                f.field("handler_object", &self.handler_object());
                f.field("host_type", &self.host_type());
                f.field("port", &self.port());
                f.field("print_messages", &self.print_messages());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostBroadcastListenRef<'a>> for HostBroadcastListen {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostBroadcastListenRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    handler_object: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.handler_object()?)?,
                    ),
                    host_type: ::core::convert::TryInto::try_into(value.host_type()?)?,
                    port: ::core::convert::TryInto::try_into(value.port()?)?,
                    print_messages: ::core::convert::TryInto::try_into(value.print_messages()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostBroadcastListenRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostBroadcastListenRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostBroadcastListenRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostBroadcastListen>> for HostBroadcastListen {
            type Value = ::planus::Offset<HostBroadcastListen>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostBroadcastListen>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostBroadcastListenRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HostBroadcastListenRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `HostBroadcastUnlisten` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostBroadcastUnlisten` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:783`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostBroadcastUnlisten {
            /// The field `host_type` in the table `HostBroadcastUnlisten`
            pub host_type: self::HostType,
            /// The field `port` in the table `HostBroadcastUnlisten`
            pub port: u16,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for HostBroadcastUnlisten {
            fn default() -> Self {
                Self {
                    host_type: self::HostType::Tcp,
                    port: 0,
                }
            }
        }

        impl HostBroadcastUnlisten {
            /// Creates a [HostBroadcastUnlistenBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostBroadcastUnlistenBuilder<()> {
                HostBroadcastUnlistenBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_host_type: impl ::planus::WriteAsDefault<self::HostType, self::HostType>,
                field_port: impl ::planus::WriteAsDefault<u16, u16>,
            ) -> ::planus::Offset<Self> {
                let prepared_host_type = field_host_type.prepare(builder, &self::HostType::Tcp);
                let prepared_port = field_port.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_port.is_some() {
                    table_writer.write_entry::<u16>(1);
                }
                if prepared_host_type.is_some() {
                    table_writer.write_entry::<self::HostType>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            object_writer.write::<_, _, 2>(&prepared_port);
                        }
                        if let ::core::option::Option::Some(prepared_host_type) = prepared_host_type
                        {
                            object_writer.write::<_, _, 1>(&prepared_host_type);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostBroadcastUnlisten>> for HostBroadcastUnlisten {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastUnlisten> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostBroadcastUnlisten>> for HostBroadcastUnlisten {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostBroadcastUnlisten>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostBroadcastUnlisten> for HostBroadcastUnlisten {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastUnlisten> {
                HostBroadcastUnlisten::create(builder, self.host_type, self.port)
            }
        }

        /// Builder for serializing an instance of the [HostBroadcastUnlisten] type.
        ///
        /// Can be created using the [HostBroadcastUnlisten::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostBroadcastUnlistenBuilder<State>(State);

        impl HostBroadcastUnlistenBuilder<()> {
            /// Setter for the [`host_type` field](HostBroadcastUnlisten#structfield.host_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_type<T0>(self, value: T0) -> HostBroadcastUnlistenBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            {
                HostBroadcastUnlistenBuilder((value,))
            }

            /// Sets the [`host_type` field](HostBroadcastUnlisten#structfield.host_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_type_as_default(
                self,
            ) -> HostBroadcastUnlistenBuilder<(::planus::DefaultValue,)> {
                self.host_type(::planus::DefaultValue)
            }
        }

        impl<T0> HostBroadcastUnlistenBuilder<(T0,)> {
            /// Setter for the [`port` field](HostBroadcastUnlisten#structfield.port).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn port<T1>(self, value: T1) -> HostBroadcastUnlistenBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0,) = self.0;
                HostBroadcastUnlistenBuilder((v0, value))
            }

            /// Sets the [`port` field](HostBroadcastUnlisten#structfield.port) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn port_as_default(
                self,
            ) -> HostBroadcastUnlistenBuilder<(T0, ::planus::DefaultValue)> {
                self.port(::planus::DefaultValue)
            }
        }

        impl<T0, T1> HostBroadcastUnlistenBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostBroadcastUnlisten].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastUnlisten>
            where
                Self: ::planus::WriteAsOffset<HostBroadcastUnlisten>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T1: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAs<::planus::Offset<HostBroadcastUnlisten>>
            for HostBroadcastUnlistenBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HostBroadcastUnlisten>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastUnlisten> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T1: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOptional<::planus::Offset<HostBroadcastUnlisten>>
            for HostBroadcastUnlistenBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HostBroadcastUnlisten>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostBroadcastUnlisten>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T1: ::planus::WriteAsDefault<u16, u16>,
        > ::planus::WriteAsOffset<HostBroadcastUnlisten>
            for HostBroadcastUnlistenBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastUnlisten> {
                let (v0, v1) = &self.0;
                HostBroadcastUnlisten::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [HostBroadcastUnlisten].
        #[derive(Copy, Clone)]
        pub struct HostBroadcastUnlistenRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostBroadcastUnlistenRef<'a> {
            /// Getter for the [`host_type` field](HostBroadcastUnlisten#structfield.host_type).
            #[inline]
            pub fn host_type(&self) -> ::planus::Result<self::HostType> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "HostBroadcastUnlisten", "host_type")?
                        .unwrap_or(self::HostType::Tcp),
                )
            }

            /// Getter for the [`port` field](HostBroadcastUnlisten#structfield.port).
            #[inline]
            pub fn port(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "HostBroadcastUnlisten", "port")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for HostBroadcastUnlistenRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostBroadcastUnlistenRef");
                f.field("host_type", &self.host_type());
                f.field("port", &self.port());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostBroadcastUnlistenRef<'a>> for HostBroadcastUnlisten {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostBroadcastUnlistenRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    host_type: ::core::convert::TryInto::try_into(value.host_type()?)?,
                    port: ::core::convert::TryInto::try_into(value.port()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostBroadcastUnlistenRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostBroadcastUnlistenRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostBroadcastUnlistenRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostBroadcastUnlisten>>
            for HostBroadcastUnlisten
        {
            type Value = ::planus::Offset<HostBroadcastUnlisten>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostBroadcastUnlisten>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostBroadcastUnlistenRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HostBroadcastUnlistenRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `HostBroadcastPingPong` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostBroadcastPingPong` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:788`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostBroadcastPingPong {
            /// The field `timestamp` in the table `HostBroadcastPingPong`
            pub timestamp: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for HostBroadcastPingPong {
            fn default() -> Self {
                Self { timestamp: 0 }
            }
        }

        impl HostBroadcastPingPong {
            /// Creates a [HostBroadcastPingPongBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostBroadcastPingPongBuilder<()> {
                HostBroadcastPingPongBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_timestamp = field_timestamp.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_timestamp.is_some() {
                    table_writer.write_entry::<u64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            object_writer.write::<_, _, 8>(&prepared_timestamp);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostBroadcastPingPong>> for HostBroadcastPingPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastPingPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostBroadcastPingPong>> for HostBroadcastPingPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostBroadcastPingPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostBroadcastPingPong> for HostBroadcastPingPong {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastPingPong> {
                HostBroadcastPingPong::create(builder, self.timestamp)
            }
        }

        /// Builder for serializing an instance of the [HostBroadcastPingPong] type.
        ///
        /// Can be created using the [HostBroadcastPingPong::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostBroadcastPingPongBuilder<State>(State);

        impl HostBroadcastPingPongBuilder<()> {
            /// Setter for the [`timestamp` field](HostBroadcastPingPong#structfield.timestamp).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp<T0>(self, value: T0) -> HostBroadcastPingPongBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                HostBroadcastPingPongBuilder((value,))
            }

            /// Sets the [`timestamp` field](HostBroadcastPingPong#structfield.timestamp) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp_as_default(
                self,
            ) -> HostBroadcastPingPongBuilder<(::planus::DefaultValue,)> {
                self.timestamp(::planus::DefaultValue)
            }
        }

        impl<T0> HostBroadcastPingPongBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostBroadcastPingPong].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastPingPong>
            where
                Self: ::planus::WriteAsOffset<HostBroadcastPingPong>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAs<::planus::Offset<HostBroadcastPingPong>>
            for HostBroadcastPingPongBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostBroadcastPingPong>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastPingPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<HostBroadcastPingPong>>
            for HostBroadcastPingPongBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostBroadcastPingPong>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostBroadcastPingPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAsOffset<HostBroadcastPingPong>
            for HostBroadcastPingPongBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastPingPong> {
                let (v0,) = &self.0;
                HostBroadcastPingPong::create(builder, v0)
            }
        }

        /// Reference to a deserialized [HostBroadcastPingPong].
        #[derive(Copy, Clone)]
        pub struct HostBroadcastPingPongRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostBroadcastPingPongRef<'a> {
            /// Getter for the [`timestamp` field](HostBroadcastPingPong#structfield.timestamp).
            #[inline]
            pub fn timestamp(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "HostBroadcastPingPong", "timestamp")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for HostBroadcastPingPongRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostBroadcastPingPongRef");
                f.field("timestamp", &self.timestamp());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostBroadcastPingPongRef<'a>> for HostBroadcastPingPong {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostBroadcastPingPongRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostBroadcastPingPongRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostBroadcastPingPongRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostBroadcastPingPongRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostBroadcastPingPong>>
            for HostBroadcastPingPong
        {
            type Value = ::planus::Offset<HostBroadcastPingPong>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostBroadcastPingPong>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostBroadcastPingPongRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HostBroadcastPingPongRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `HostBroadcastEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostBroadcastEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:792`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostBroadcastEvent {
            /// The field `event` in the table `HostBroadcastEvent`
            pub event: self::HostBroadcastEventUnion,
        }

        impl HostBroadcastEvent {
            /// Creates a [HostBroadcastEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostBroadcastEventBuilder<()> {
                HostBroadcastEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_event: impl ::planus::WriteAsUnion<self::HostBroadcastEventUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_event = field_event.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::HostBroadcastEventUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_event.offset());
                        object_writer.write::<_, _, 1>(&prepared_event.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostBroadcastEvent>> for HostBroadcastEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostBroadcastEvent>> for HostBroadcastEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostBroadcastEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostBroadcastEvent> for HostBroadcastEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastEvent> {
                HostBroadcastEvent::create(builder, &self.event)
            }
        }

        /// Builder for serializing an instance of the [HostBroadcastEvent] type.
        ///
        /// Can be created using the [HostBroadcastEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostBroadcastEventBuilder<State>(State);

        impl HostBroadcastEventBuilder<()> {
            /// Setter for the [`event` field](HostBroadcastEvent#structfield.event).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event<T0>(self, value: T0) -> HostBroadcastEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::HostBroadcastEventUnion>,
            {
                HostBroadcastEventBuilder((value,))
            }
        }

        impl<T0> HostBroadcastEventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostBroadcastEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastEvent>
            where
                Self: ::planus::WriteAsOffset<HostBroadcastEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HostBroadcastEventUnion>>
            ::planus::WriteAs<::planus::Offset<HostBroadcastEvent>>
            for HostBroadcastEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostBroadcastEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HostBroadcastEventUnion>>
            ::planus::WriteAsOptional<::planus::Offset<HostBroadcastEvent>>
            for HostBroadcastEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostBroadcastEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostBroadcastEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HostBroadcastEventUnion>>
            ::planus::WriteAsOffset<HostBroadcastEvent> for HostBroadcastEventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostBroadcastEvent> {
                let (v0,) = &self.0;
                HostBroadcastEvent::create(builder, v0)
            }
        }

        /// Reference to a deserialized [HostBroadcastEvent].
        #[derive(Copy, Clone)]
        pub struct HostBroadcastEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostBroadcastEventRef<'a> {
            /// Getter for the [`event` field](HostBroadcastEvent#structfield.event).
            #[inline]
            pub fn event(&self) -> ::planus::Result<self::HostBroadcastEventUnionRef<'a>> {
                self.0
                    .access_union_required(0, "HostBroadcastEvent", "event")
            }
        }

        impl<'a> ::core::fmt::Debug for HostBroadcastEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostBroadcastEventRef");
                f.field("event", &self.event());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostBroadcastEventRef<'a>> for HostBroadcastEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostBroadcastEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    event: ::core::convert::TryInto::try_into(value.event()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostBroadcastEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostBroadcastEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostBroadcastEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostBroadcastEvent>> for HostBroadcastEvent {
            type Value = ::planus::Offset<HostBroadcastEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostBroadcastEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostBroadcastEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HostBroadcastEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `HostClientToDaemonMessageUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `HostClientToDaemonMessageUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:800`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum HostClientToDaemonMessageUnion {
            /// The variant of type `ConnectionEstablish` in the union `HostClientToDaemonMessageUnion`
            ConnectionEstablish(::planus::alloc::boxed::Box<self::ConnectionEstablish>),

            /// The variant of type `RequestSysProp` in the union `HostClientToDaemonMessageUnion`
            RequestSysProp(::planus::alloc::boxed::Box<self::RequestSysProp>),

            /// The variant of type `LoginCommand` in the union `HostClientToDaemonMessageUnion`
            LoginCommand(::planus::alloc::boxed::Box<self::LoginCommand>),

            /// The variant of type `Attach` in the union `HostClientToDaemonMessageUnion`
            Attach(::planus::alloc::boxed::Box<self::Attach>),

            /// The variant of type `Command` in the union `HostClientToDaemonMessageUnion`
            Command(::planus::alloc::boxed::Box<self::Command>),

            /// The variant of type `Verbs` in the union `HostClientToDaemonMessageUnion`
            Verbs(::planus::alloc::boxed::Box<self::Verbs>),

            /// The variant of type `InvokeVerb` in the union `HostClientToDaemonMessageUnion`
            InvokeVerb(::planus::alloc::boxed::Box<self::InvokeVerb>),

            /// The variant of type `Properties` in the union `HostClientToDaemonMessageUnion`
            Properties(::planus::alloc::boxed::Box<self::Properties>),

            /// The variant of type `Retrieve` in the union `HostClientToDaemonMessageUnion`
            Retrieve(::planus::alloc::boxed::Box<self::Retrieve>),

            /// The variant of type `Program` in the union `HostClientToDaemonMessageUnion`
            Program(::planus::alloc::boxed::Box<self::Program>),

            /// The variant of type `RequestedInput` in the union `HostClientToDaemonMessageUnion`
            RequestedInput(::planus::alloc::boxed::Box<self::RequestedInput>),

            /// The variant of type `OutOfBand` in the union `HostClientToDaemonMessageUnion`
            OutOfBand(::planus::alloc::boxed::Box<self::OutOfBand>),

            /// The variant of type `Eval` in the union `HostClientToDaemonMessageUnion`
            Eval(::planus::alloc::boxed::Box<self::Eval>),

            /// The variant of type `Resolve` in the union `HostClientToDaemonMessageUnion`
            Resolve(::planus::alloc::boxed::Box<self::Resolve>),

            /// The variant of type `ClientPong` in the union `HostClientToDaemonMessageUnion`
            ClientPong(::planus::alloc::boxed::Box<self::ClientPong>),

            /// The variant of type `RequestHistory` in the union `HostClientToDaemonMessageUnion`
            RequestHistory(::planus::alloc::boxed::Box<self::RequestHistory>),

            /// The variant of type `RequestCurrentPresentations` in the union `HostClientToDaemonMessageUnion`
            RequestCurrentPresentations(
                ::planus::alloc::boxed::Box<self::RequestCurrentPresentations>,
            ),

            /// The variant of type `DismissPresentation` in the union `HostClientToDaemonMessageUnion`
            DismissPresentation(::planus::alloc::boxed::Box<self::DismissPresentation>),

            /// The variant of type `SetClientAttribute` in the union `HostClientToDaemonMessageUnion`
            SetClientAttribute(::planus::alloc::boxed::Box<self::SetClientAttribute>),

            /// The variant of type `Detach` in the union `HostClientToDaemonMessageUnion`
            Detach(::planus::alloc::boxed::Box<self::Detach>),
        }

        impl HostClientToDaemonMessageUnion {
            /// Creates a [HostClientToDaemonMessageUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostClientToDaemonMessageUnionBuilder<::planus::Uninitialized> {
                HostClientToDaemonMessageUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_connection_establish(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ConnectionEstablish>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_request_sys_prop(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RequestSysProp>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_login_command(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::LoginCommand>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_attach(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Attach>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_command(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Command>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verbs(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Verbs>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_invoke_verb(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::InvokeVerb>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_properties(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Properties>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_retrieve(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Retrieve>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_program(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Program>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_requested_input(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RequestedInput>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_out_of_band(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::OutOfBand>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_eval(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Eval>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_resolve(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Resolve>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(14, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_client_pong(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ClientPong>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(15, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_request_history(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RequestHistory>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(16, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_request_current_presentations(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RequestCurrentPresentations>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(17, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_dismiss_presentation(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DismissPresentation>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(18, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_set_client_attribute(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::SetClientAttribute>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(19, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_detach(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Detach>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(20, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<HostClientToDaemonMessageUnion> for HostClientToDaemonMessageUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::ConnectionEstablish(value) => {
                        Self::create_connection_establish(builder, value)
                    }
                    Self::RequestSysProp(value) => Self::create_request_sys_prop(builder, value),
                    Self::LoginCommand(value) => Self::create_login_command(builder, value),
                    Self::Attach(value) => Self::create_attach(builder, value),
                    Self::Command(value) => Self::create_command(builder, value),
                    Self::Verbs(value) => Self::create_verbs(builder, value),
                    Self::InvokeVerb(value) => Self::create_invoke_verb(builder, value),
                    Self::Properties(value) => Self::create_properties(builder, value),
                    Self::Retrieve(value) => Self::create_retrieve(builder, value),
                    Self::Program(value) => Self::create_program(builder, value),
                    Self::RequestedInput(value) => Self::create_requested_input(builder, value),
                    Self::OutOfBand(value) => Self::create_out_of_band(builder, value),
                    Self::Eval(value) => Self::create_eval(builder, value),
                    Self::Resolve(value) => Self::create_resolve(builder, value),
                    Self::ClientPong(value) => Self::create_client_pong(builder, value),
                    Self::RequestHistory(value) => Self::create_request_history(builder, value),
                    Self::RequestCurrentPresentations(value) => {
                        Self::create_request_current_presentations(builder, value)
                    }
                    Self::DismissPresentation(value) => {
                        Self::create_dismiss_presentation(builder, value)
                    }
                    Self::SetClientAttribute(value) => {
                        Self::create_set_client_attribute(builder, value)
                    }
                    Self::Detach(value) => Self::create_detach(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnion
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [HostClientToDaemonMessageUnion] type.
        ///
        /// Can be created using the [HostClientToDaemonMessageUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostClientToDaemonMessageUnionBuilder<T>(T);

        impl HostClientToDaemonMessageUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`ConnectionEstablish` variant](HostClientToDaemonMessageUnion#variant.ConnectionEstablish).
            #[inline]
            pub fn connection_establish<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::ConnectionEstablish>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RequestSysProp` variant](HostClientToDaemonMessageUnion#variant.RequestSysProp).
            #[inline]
            pub fn request_sys_prop<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::RequestSysProp>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`LoginCommand` variant](HostClientToDaemonMessageUnion#variant.LoginCommand).
            #[inline]
            pub fn login_command<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::LoginCommand>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Attach` variant](HostClientToDaemonMessageUnion#variant.Attach).
            #[inline]
            pub fn attach<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::Attach>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Command` variant](HostClientToDaemonMessageUnion#variant.Command).
            #[inline]
            pub fn command<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::Command>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Verbs` variant](HostClientToDaemonMessageUnion#variant.Verbs).
            #[inline]
            pub fn verbs<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::Verbs>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`InvokeVerb` variant](HostClientToDaemonMessageUnion#variant.InvokeVerb).
            #[inline]
            pub fn invoke_verb<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<self::InvokeVerb>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Properties` variant](HostClientToDaemonMessageUnion#variant.Properties).
            #[inline]
            pub fn properties<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<self::Properties>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Retrieve` variant](HostClientToDaemonMessageUnion#variant.Retrieve).
            #[inline]
            pub fn retrieve<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<self::Retrieve>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Program` variant](HostClientToDaemonMessageUnion#variant.Program).
            #[inline]
            pub fn program<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<self::Program>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RequestedInput` variant](HostClientToDaemonMessageUnion#variant.RequestedInput).
            #[inline]
            pub fn requested_input<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<self::RequestedInput>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`OutOfBand` variant](HostClientToDaemonMessageUnion#variant.OutOfBand).
            #[inline]
            pub fn out_of_band<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<self::OutOfBand>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Eval` variant](HostClientToDaemonMessageUnion#variant.Eval).
            #[inline]
            pub fn eval<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<self::Eval>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Resolve` variant](HostClientToDaemonMessageUnion#variant.Resolve).
            #[inline]
            pub fn resolve<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<self::Resolve>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ClientPong` variant](HostClientToDaemonMessageUnion#variant.ClientPong).
            #[inline]
            pub fn client_pong<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<self::ClientPong>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RequestHistory` variant](HostClientToDaemonMessageUnion#variant.RequestHistory).
            #[inline]
            pub fn request_history<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<16, T>>
            where
                T: ::planus::WriteAsOffset<self::RequestHistory>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RequestCurrentPresentations` variant](HostClientToDaemonMessageUnion#variant.RequestCurrentPresentations).
            #[inline]
            pub fn request_current_presentations<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<17, T>>
            where
                T: ::planus::WriteAsOffset<self::RequestCurrentPresentations>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DismissPresentation` variant](HostClientToDaemonMessageUnion#variant.DismissPresentation).
            #[inline]
            pub fn dismiss_presentation<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<18, T>>
            where
                T: ::planus::WriteAsOffset<self::DismissPresentation>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`SetClientAttribute` variant](HostClientToDaemonMessageUnion#variant.SetClientAttribute).
            #[inline]
            pub fn set_client_attribute<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<19, T>>
            where
                T: ::planus::WriteAsOffset<self::SetClientAttribute>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Detach` variant](HostClientToDaemonMessageUnion#variant.Detach).
            #[inline]
            pub fn detach<T>(
                self,
                value: T,
            ) -> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<20, T>>
            where
                T: ::planus::WriteAsOffset<self::Detach>,
            {
                HostClientToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> HostClientToDaemonMessageUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [HostClientToDaemonMessageUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion>
            where
                Self: ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ConnectionEstablish>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ConnectionEstablish>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestSysProp>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestSysProp>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::LoginCommand>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::LoginCommand>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::Attach>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::Attach>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::Command>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::Command>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::Verbs>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::Verbs>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::InvokeVerb>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::InvokeVerb>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::Properties>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::Properties>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::Retrieve>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::Retrieve>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::Program>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::Program>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestedInput>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(11, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestedInput>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::OutOfBand>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(12, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::OutOfBand>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::Eval>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(13, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::Eval>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<14, T>>
        where
            T: ::planus::WriteAsOffset<self::Resolve>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(14, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<14, T>>
        where
            T: ::planus::WriteAsOffset<self::Resolve>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<15, T>>
        where
            T: ::planus::WriteAsOffset<self::ClientPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(15, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<15, T>>
        where
            T: ::planus::WriteAsOffset<self::ClientPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<16, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestHistory>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(16, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<16, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestHistory>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<17, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestCurrentPresentations>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(17, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<17, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestCurrentPresentations>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<18, T>>
        where
            T: ::planus::WriteAsOffset<self::DismissPresentation>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(18, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<18, T>>
        where
            T: ::planus::WriteAsOffset<self::DismissPresentation>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<19, T>>
        where
            T: ::planus::WriteAsOffset<self::SetClientAttribute>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(19, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<19, T>>
        where
            T: ::planus::WriteAsOffset<self::SetClientAttribute>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<20, T>>
        where
            T: ::planus::WriteAsOffset<self::Detach>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<HostClientToDaemonMessageUnion> {
                ::planus::UnionOffset::new(20, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<HostClientToDaemonMessageUnion>
            for HostClientToDaemonMessageUnionBuilder<::planus::Initialized<20, T>>
        where
            T: ::planus::WriteAsOffset<self::Detach>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<HostClientToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [HostClientToDaemonMessageUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum HostClientToDaemonMessageUnionRef<'a> {
            ConnectionEstablish(self::ConnectionEstablishRef<'a>),
            RequestSysProp(self::RequestSysPropRef<'a>),
            LoginCommand(self::LoginCommandRef<'a>),
            Attach(self::AttachRef<'a>),
            Command(self::CommandRef<'a>),
            Verbs(self::VerbsRef<'a>),
            InvokeVerb(self::InvokeVerbRef<'a>),
            Properties(self::PropertiesRef<'a>),
            Retrieve(self::RetrieveRef<'a>),
            Program(self::ProgramRef<'a>),
            RequestedInput(self::RequestedInputRef<'a>),
            OutOfBand(self::OutOfBandRef<'a>),
            Eval(self::EvalRef<'a>),
            Resolve(self::ResolveRef<'a>),
            ClientPong(self::ClientPongRef<'a>),
            RequestHistory(self::RequestHistoryRef<'a>),
            RequestCurrentPresentations(self::RequestCurrentPresentationsRef<'a>),
            DismissPresentation(self::DismissPresentationRef<'a>),
            SetClientAttribute(self::SetClientAttributeRef<'a>),
            Detach(self::DetachRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<HostClientToDaemonMessageUnionRef<'a>>
            for HostClientToDaemonMessageUnion
        {
            type Error = ::planus::Error;

            fn try_from(value: HostClientToDaemonMessageUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    HostClientToDaemonMessageUnionRef::ConnectionEstablish(value) => {
                        Self::ConnectionEstablish(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::RequestSysProp(value) => {
                        Self::RequestSysProp(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::LoginCommand(value) => {
                        Self::LoginCommand(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::Attach(value) => {
                        Self::Attach(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::Command(value) => {
                        Self::Command(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::Verbs(value) => {
                        Self::Verbs(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::InvokeVerb(value) => {
                        Self::InvokeVerb(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::Properties(value) => {
                        Self::Properties(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::Retrieve(value) => {
                        Self::Retrieve(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::Program(value) => {
                        Self::Program(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::RequestedInput(value) => {
                        Self::RequestedInput(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::OutOfBand(value) => {
                        Self::OutOfBand(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::Eval(value) => {
                        Self::Eval(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::Resolve(value) => {
                        Self::Resolve(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::ClientPong(value) => {
                        Self::ClientPong(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::RequestHistory(value) => {
                        Self::RequestHistory(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::RequestCurrentPresentations(value) => {
                        Self::RequestCurrentPresentations(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::DismissPresentation(value) => {
                        Self::DismissPresentation(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::SetClientAttribute(value) => {
                        Self::SetClientAttribute(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    HostClientToDaemonMessageUnionRef::Detach(value) => {
                        Self::Detach(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for HostClientToDaemonMessageUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::ConnectionEstablish(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::RequestSysProp(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::LoginCommand(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::Attach(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::Command(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    6 => ::core::result::Result::Ok(Self::Verbs(::planus::TableRead::from_buffer(
                        buffer,
                        field_offset,
                    )?)),
                    7 => ::core::result::Result::Ok(Self::InvokeVerb(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    8 => ::core::result::Result::Ok(Self::Properties(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    9 => ::core::result::Result::Ok(Self::Retrieve(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    10 => ::core::result::Result::Ok(Self::Program(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    11 => ::core::result::Result::Ok(Self::RequestedInput(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    12 => ::core::result::Result::Ok(Self::OutOfBand(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    13 => ::core::result::Result::Ok(Self::Eval(::planus::TableRead::from_buffer(
                        buffer,
                        field_offset,
                    )?)),
                    14 => ::core::result::Result::Ok(Self::Resolve(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    15 => ::core::result::Result::Ok(Self::ClientPong(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    16 => ::core::result::Result::Ok(Self::RequestHistory(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    17 => ::core::result::Result::Ok(Self::RequestCurrentPresentations(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    18 => ::core::result::Result::Ok(Self::DismissPresentation(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    19 => ::core::result::Result::Ok(Self::SetClientAttribute(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    20 => ::core::result::Result::Ok(Self::Detach(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for HostClientToDaemonMessageUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[HostClientToDaemonMessageUnionRef]";
        }

        /// The table `ConnectionEstablish` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ConnectionEstablish` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:823`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ConnectionEstablish {
            /// The field `peer_addr` in the table `ConnectionEstablish`
            pub peer_addr: ::planus::alloc::string::String,
            /// The field `local_port` in the table `ConnectionEstablish`
            pub local_port: u16,
            /// The field `remote_port` in the table `ConnectionEstablish`
            pub remote_port: u16,
            /// The field `acceptable_content_types` in the table `ConnectionEstablish`
            pub acceptable_content_types:
                ::core::option::Option<::planus::alloc::vec::Vec<self::Symbol>>,
            /// The field `connection_attributes` in the table `ConnectionEstablish`
            pub connection_attributes:
                ::core::option::Option<::planus::alloc::vec::Vec<self::ConnectionAttribute>>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ConnectionEstablish {
            fn default() -> Self {
                Self {
                    peer_addr: ::core::default::Default::default(),
                    local_port: 0,
                    remote_port: 0,
                    acceptable_content_types: ::core::default::Default::default(),
                    connection_attributes: ::core::default::Default::default(),
                }
            }
        }

        impl ConnectionEstablish {
            /// Creates a [ConnectionEstablishBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ConnectionEstablishBuilder<()> {
                ConnectionEstablishBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_peer_addr: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_local_port: impl ::planus::WriteAsDefault<u16, u16>,
                field_remote_port: impl ::planus::WriteAsDefault<u16, u16>,
                field_acceptable_content_types: impl ::planus::WriteAsOptional<
                    ::planus::Offset<[::planus::Offset<self::Symbol>]>,
                >,
                field_connection_attributes: impl ::planus::WriteAsOptional<
                    ::planus::Offset<[::planus::Offset<self::ConnectionAttribute>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_peer_addr = field_peer_addr.prepare(builder);
                let prepared_local_port = field_local_port.prepare(builder, &0);
                let prepared_remote_port = field_remote_port.prepare(builder, &0);
                let prepared_acceptable_content_types =
                    field_acceptable_content_types.prepare(builder);
                let prepared_connection_attributes = field_connection_attributes.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<14> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<str>>(0);
                if prepared_acceptable_content_types.is_some() {
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::Symbol>]>>(3);
                }
                if prepared_connection_attributes.is_some() {
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::ConnectionAttribute>]>>(4);
                }
                if prepared_local_port.is_some() {
                    table_writer.write_entry::<u16>(1);
                }
                if prepared_remote_port.is_some() {
                    table_writer.write_entry::<u16>(2);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_peer_addr);
                        if let ::core::option::Option::Some(prepared_acceptable_content_types) =
                            prepared_acceptable_content_types
                        {
                            object_writer.write::<_, _, 4>(&prepared_acceptable_content_types);
                        }
                        if let ::core::option::Option::Some(prepared_connection_attributes) =
                            prepared_connection_attributes
                        {
                            object_writer.write::<_, _, 4>(&prepared_connection_attributes);
                        }
                        if let ::core::option::Option::Some(prepared_local_port) =
                            prepared_local_port
                        {
                            object_writer.write::<_, _, 2>(&prepared_local_port);
                        }
                        if let ::core::option::Option::Some(prepared_remote_port) =
                            prepared_remote_port
                        {
                            object_writer.write::<_, _, 2>(&prepared_remote_port);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ConnectionEstablish>> for ConnectionEstablish {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionEstablish> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ConnectionEstablish>> for ConnectionEstablish {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ConnectionEstablish>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ConnectionEstablish> for ConnectionEstablish {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionEstablish> {
                ConnectionEstablish::create(
                    builder,
                    &self.peer_addr,
                    self.local_port,
                    self.remote_port,
                    &self.acceptable_content_types,
                    &self.connection_attributes,
                )
            }
        }

        /// Builder for serializing an instance of the [ConnectionEstablish] type.
        ///
        /// Can be created using the [ConnectionEstablish::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ConnectionEstablishBuilder<State>(State);

        impl ConnectionEstablishBuilder<()> {
            /// Setter for the [`peer_addr` field](ConnectionEstablish#structfield.peer_addr).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn peer_addr<T0>(self, value: T0) -> ConnectionEstablishBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<str>>,
            {
                ConnectionEstablishBuilder((value,))
            }
        }

        impl<T0> ConnectionEstablishBuilder<(T0,)> {
            /// Setter for the [`local_port` field](ConnectionEstablish#structfield.local_port).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn local_port<T1>(self, value: T1) -> ConnectionEstablishBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0,) = self.0;
                ConnectionEstablishBuilder((v0, value))
            }

            /// Sets the [`local_port` field](ConnectionEstablish#structfield.local_port) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn local_port_as_default(
                self,
            ) -> ConnectionEstablishBuilder<(T0, ::planus::DefaultValue)> {
                self.local_port(::planus::DefaultValue)
            }
        }

        impl<T0, T1> ConnectionEstablishBuilder<(T0, T1)> {
            /// Setter for the [`remote_port` field](ConnectionEstablish#structfield.remote_port).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn remote_port<T2>(self, value: T2) -> ConnectionEstablishBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1) = self.0;
                ConnectionEstablishBuilder((v0, v1, value))
            }

            /// Sets the [`remote_port` field](ConnectionEstablish#structfield.remote_port) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn remote_port_as_default(
                self,
            ) -> ConnectionEstablishBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.remote_port(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> ConnectionEstablishBuilder<(T0, T1, T2)> {
            /// Setter for the [`acceptable_content_types` field](ConnectionEstablish#structfield.acceptable_content_types).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn acceptable_content_types<T3>(
                self,
                value: T3,
            ) -> ConnectionEstablishBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            {
                let (v0, v1, v2) = self.0;
                ConnectionEstablishBuilder((v0, v1, v2, value))
            }

            /// Sets the [`acceptable_content_types` field](ConnectionEstablish#structfield.acceptable_content_types) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn acceptable_content_types_as_null(
                self,
            ) -> ConnectionEstablishBuilder<(T0, T1, T2, ())> {
                self.acceptable_content_types(())
            }
        }

        impl<T0, T1, T2, T3> ConnectionEstablishBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`connection_attributes` field](ConnectionEstablish#structfield.connection_attributes).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connection_attributes<T4>(
                self,
                value: T4,
            ) -> ConnectionEstablishBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::ConnectionAttribute>]>,
                    >,
            {
                let (v0, v1, v2, v3) = self.0;
                ConnectionEstablishBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`connection_attributes` field](ConnectionEstablish#structfield.connection_attributes) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connection_attributes_as_null(
                self,
            ) -> ConnectionEstablishBuilder<(T0, T1, T2, T3, ())> {
                self.connection_attributes(())
            }
        }

        impl<T0, T1, T2, T3, T4> ConnectionEstablishBuilder<(T0, T1, T2, T3, T4)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectionEstablish].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionEstablish>
            where
                Self: ::planus::WriteAsOffset<ConnectionEstablish>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsDefault<u16, u16>,
            T3: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T4: ::planus::WriteAsOptional<
                    ::planus::Offset<[::planus::Offset<self::ConnectionAttribute>]>,
                >,
        > ::planus::WriteAs<::planus::Offset<ConnectionEstablish>>
            for ConnectionEstablishBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<ConnectionEstablish>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionEstablish> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsDefault<u16, u16>,
            T3: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T4: ::planus::WriteAsOptional<
                    ::planus::Offset<[::planus::Offset<self::ConnectionAttribute>]>,
                >,
        > ::planus::WriteAsOptional<::planus::Offset<ConnectionEstablish>>
            for ConnectionEstablishBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<ConnectionEstablish>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ConnectionEstablish>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<str>>,
            T1: ::planus::WriteAsDefault<u16, u16>,
            T2: ::planus::WriteAsDefault<u16, u16>,
            T3: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            T4: ::planus::WriteAsOptional<
                    ::planus::Offset<[::planus::Offset<self::ConnectionAttribute>]>,
                >,
        > ::planus::WriteAsOffset<ConnectionEstablish>
            for ConnectionEstablishBuilder<(T0, T1, T2, T3, T4)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ConnectionEstablish> {
                let (v0, v1, v2, v3, v4) = &self.0;
                ConnectionEstablish::create(builder, v0, v1, v2, v3, v4)
            }
        }

        /// Reference to a deserialized [ConnectionEstablish].
        #[derive(Copy, Clone)]
        pub struct ConnectionEstablishRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ConnectionEstablishRef<'a> {
            /// Getter for the [`peer_addr` field](ConnectionEstablish#structfield.peer_addr).
            #[inline]
            pub fn peer_addr(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(0, "ConnectionEstablish", "peer_addr")
            }

            /// Getter for the [`local_port` field](ConnectionEstablish#structfield.local_port).
            #[inline]
            pub fn local_port(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "ConnectionEstablish", "local_port")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`remote_port` field](ConnectionEstablish#structfield.remote_port).
            #[inline]
            pub fn remote_port(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "ConnectionEstablish", "remote_port")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`acceptable_content_types` field](ConnectionEstablish#structfield.acceptable_content_types).
            #[inline]
            pub fn acceptable_content_types(
                &self,
            ) -> ::planus::Result<
                ::core::option::Option<::planus::Vector<'a, ::planus::Result<self::SymbolRef<'a>>>>,
            > {
                self.0
                    .access(3, "ConnectionEstablish", "acceptable_content_types")
            }

            /// Getter for the [`connection_attributes` field](ConnectionEstablish#structfield.connection_attributes).
            #[inline]
            pub fn connection_attributes(
                &self,
            ) -> ::planus::Result<
                ::core::option::Option<
                    ::planus::Vector<'a, ::planus::Result<self::ConnectionAttributeRef<'a>>>,
                >,
            > {
                self.0
                    .access(4, "ConnectionEstablish", "connection_attributes")
            }
        }

        impl<'a> ::core::fmt::Debug for ConnectionEstablishRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ConnectionEstablishRef");
                f.field("peer_addr", &self.peer_addr());
                f.field("local_port", &self.local_port());
                f.field("remote_port", &self.remote_port());
                if let ::core::option::Option::Some(field_acceptable_content_types) =
                    self.acceptable_content_types().transpose()
                {
                    f.field("acceptable_content_types", &field_acceptable_content_types);
                }
                if let ::core::option::Option::Some(field_connection_attributes) =
                    self.connection_attributes().transpose()
                {
                    f.field("connection_attributes", &field_connection_attributes);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ConnectionEstablishRef<'a>> for ConnectionEstablish {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ConnectionEstablishRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    peer_addr: ::core::convert::Into::into(value.peer_addr()?),
                    local_port: ::core::convert::TryInto::try_into(value.local_port()?)?,
                    remote_port: ::core::convert::TryInto::try_into(value.remote_port()?)?,
                    acceptable_content_types: if let ::core::option::Option::Some(
                        acceptable_content_types,
                    ) = value.acceptable_content_types()?
                    {
                        ::core::option::Option::Some(acceptable_content_types.to_vec_result()?)
                    } else {
                        ::core::option::Option::None
                    },
                    connection_attributes: if let ::core::option::Option::Some(
                        connection_attributes,
                    ) = value.connection_attributes()?
                    {
                        ::core::option::Option::Some(connection_attributes.to_vec_result()?)
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ConnectionEstablishRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ConnectionEstablishRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ConnectionEstablishRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ConnectionEstablish>> for ConnectionEstablish {
            type Value = ::planus::Offset<ConnectionEstablish>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ConnectionEstablish>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ConnectionEstablishRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ConnectionEstablishRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `RequestSysProp` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RequestSysProp` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:831`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RequestSysProp {
            /// The field `client_token` in the table `RequestSysProp`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `object` in the table `RequestSysProp`
            pub object: ::planus::alloc::boxed::Box<self::ObjectRef>,
            /// The field `property` in the table `RequestSysProp`
            pub property: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        impl RequestSysProp {
            /// Creates a [RequestSysPropBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RequestSysPropBuilder<()> {
                RequestSysPropBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_object: impl ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
                field_property: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_object = field_object.prepare(builder);
                let prepared_property = field_property.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::ObjectRef>>(1);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_object);
                        object_writer.write::<_, _, 4>(&prepared_property);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RequestSysProp>> for RequestSysProp {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestSysProp> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RequestSysProp>> for RequestSysProp {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestSysProp>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RequestSysProp> for RequestSysProp {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestSysProp> {
                RequestSysProp::create(builder, &self.client_token, &self.object, &self.property)
            }
        }

        /// Builder for serializing an instance of the [RequestSysProp] type.
        ///
        /// Can be created using the [RequestSysProp::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RequestSysPropBuilder<State>(State);

        impl RequestSysPropBuilder<()> {
            /// Setter for the [`client_token` field](RequestSysProp#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> RequestSysPropBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                RequestSysPropBuilder((value,))
            }
        }

        impl<T0> RequestSysPropBuilder<(T0,)> {
            /// Setter for the [`object` field](RequestSysProp#structfield.object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn object<T1>(self, value: T1) -> RequestSysPropBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            {
                let (v0,) = self.0;
                RequestSysPropBuilder((v0, value))
            }
        }

        impl<T0, T1> RequestSysPropBuilder<(T0, T1)> {
            /// Setter for the [`property` field](RequestSysProp#structfield.property).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn property<T2>(self, value: T2) -> RequestSysPropBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0, v1) = self.0;
                RequestSysPropBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> RequestSysPropBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RequestSysProp].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestSysProp>
            where
                Self: ::planus::WriteAsOffset<RequestSysProp>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<RequestSysProp>>
            for RequestSysPropBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RequestSysProp>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestSysProp> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<RequestSysProp>>
            for RequestSysPropBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RequestSysProp>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestSysProp>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<RequestSysProp> for RequestSysPropBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestSysProp> {
                let (v0, v1, v2) = &self.0;
                RequestSysProp::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [RequestSysProp].
        #[derive(Copy, Clone)]
        pub struct RequestSysPropRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RequestSysPropRef<'a> {
            /// Getter for the [`client_token` field](RequestSysProp#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "RequestSysProp", "client_token")
            }

            /// Getter for the [`object` field](RequestSysProp#structfield.object).
            #[inline]
            pub fn object(&self) -> ::planus::Result<self::ObjectRefRef<'a>> {
                self.0.access_required(1, "RequestSysProp", "object")
            }

            /// Getter for the [`property` field](RequestSysProp#structfield.property).
            #[inline]
            pub fn property(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(2, "RequestSysProp", "property")
            }
        }

        impl<'a> ::core::fmt::Debug for RequestSysPropRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RequestSysPropRef");
                f.field("client_token", &self.client_token());
                f.field("object", &self.object());
                f.field("property", &self.property());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RequestSysPropRef<'a>> for RequestSysProp {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RequestSysPropRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    object: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.object()?,
                    )?),
                    property: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.property()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RequestSysPropRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RequestSysPropRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RequestSysPropRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RequestSysProp>> for RequestSysProp {
            type Value = ::planus::Offset<RequestSysProp>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RequestSysProp>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RequestSysPropRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RequestSysPropRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `LoginCommand` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `LoginCommand` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:837`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct LoginCommand {
            /// The field `client_token` in the table `LoginCommand`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `handler_object` in the table `LoginCommand`
            pub handler_object: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `connect_args` in the table `LoginCommand`
            pub connect_args: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
            /// The field `do_attach` in the table `LoginCommand`
            pub do_attach: bool,
        }

        impl LoginCommand {
            /// Creates a [LoginCommandBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> LoginCommandBuilder<()> {
                LoginCommandBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_handler_object: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_connect_args: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                field_do_attach: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_handler_object = field_handler_object.prepare(builder);
                let prepared_connect_args = field_connect_args.prepare(builder);
                let prepared_do_attach = field_do_attach.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(2);
                if prepared_do_attach.is_some() {
                    table_writer.write_entry::<bool>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_handler_object);
                        object_writer.write::<_, _, 4>(&prepared_connect_args);
                        if let ::core::option::Option::Some(prepared_do_attach) = prepared_do_attach
                        {
                            object_writer.write::<_, _, 1>(&prepared_do_attach);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<LoginCommand>> for LoginCommand {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LoginCommand> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<LoginCommand>> for LoginCommand {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<LoginCommand>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<LoginCommand> for LoginCommand {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LoginCommand> {
                LoginCommand::create(
                    builder,
                    &self.client_token,
                    &self.handler_object,
                    &self.connect_args,
                    self.do_attach,
                )
            }
        }

        /// Builder for serializing an instance of the [LoginCommand] type.
        ///
        /// Can be created using the [LoginCommand::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct LoginCommandBuilder<State>(State);

        impl LoginCommandBuilder<()> {
            /// Setter for the [`client_token` field](LoginCommand#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> LoginCommandBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                LoginCommandBuilder((value,))
            }
        }

        impl<T0> LoginCommandBuilder<(T0,)> {
            /// Setter for the [`handler_object` field](LoginCommand#structfield.handler_object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn handler_object<T1>(self, value: T1) -> LoginCommandBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                LoginCommandBuilder((v0, value))
            }
        }

        impl<T0, T1> LoginCommandBuilder<(T0, T1)> {
            /// Setter for the [`connect_args` field](LoginCommand#structfield.connect_args).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connect_args<T2>(self, value: T2) -> LoginCommandBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
            {
                let (v0, v1) = self.0;
                LoginCommandBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> LoginCommandBuilder<(T0, T1, T2)> {
            /// Setter for the [`do_attach` field](LoginCommand#structfield.do_attach).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn do_attach<T3>(self, value: T3) -> LoginCommandBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2) = self.0;
                LoginCommandBuilder((v0, v1, v2, value))
            }

            /// Sets the [`do_attach` field](LoginCommand#structfield.do_attach) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn do_attach_as_default(
                self,
            ) -> LoginCommandBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.do_attach(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> LoginCommandBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [LoginCommand].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<LoginCommand>
            where
                Self: ::planus::WriteAsOffset<LoginCommand>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAs<::planus::Offset<LoginCommand>>
            for LoginCommandBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<LoginCommand>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LoginCommand> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOptional<::planus::Offset<LoginCommand>>
            for LoginCommandBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<LoginCommand>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<LoginCommand>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOffset<LoginCommand> for LoginCommandBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LoginCommand> {
                let (v0, v1, v2, v3) = &self.0;
                LoginCommand::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [LoginCommand].
        #[derive(Copy, Clone)]
        pub struct LoginCommandRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> LoginCommandRef<'a> {
            /// Getter for the [`client_token` field](LoginCommand#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "LoginCommand", "client_token")
            }

            /// Getter for the [`handler_object` field](LoginCommand#structfield.handler_object).
            #[inline]
            pub fn handler_object(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "LoginCommand", "handler_object")
            }

            /// Getter for the [`connect_args` field](LoginCommand#structfield.connect_args).
            #[inline]
            pub fn connect_args(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>>
            {
                self.0.access_required(2, "LoginCommand", "connect_args")
            }

            /// Getter for the [`do_attach` field](LoginCommand#structfield.do_attach).
            #[inline]
            pub fn do_attach(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "LoginCommand", "do_attach")?
                        .unwrap_or(false),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for LoginCommandRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("LoginCommandRef");
                f.field("client_token", &self.client_token());
                f.field("handler_object", &self.handler_object());
                f.field("connect_args", &self.connect_args());
                f.field("do_attach", &self.do_attach());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<LoginCommandRef<'a>> for LoginCommand {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: LoginCommandRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    handler_object: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.handler_object()?)?,
                    ),
                    connect_args: value.connect_args()?.to_vec_result()?,
                    do_attach: ::core::convert::TryInto::try_into(value.do_attach()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for LoginCommandRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for LoginCommandRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[LoginCommandRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<LoginCommand>> for LoginCommand {
            type Value = ::planus::Offset<LoginCommand>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<LoginCommand>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for LoginCommandRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[LoginCommandRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Attach` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Attach` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:844`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Attach {
            /// The field `auth_token` in the table `Attach`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `connect_type` in the table `Attach`
            pub connect_type: self::ConnectType,
            /// The field `handler_object` in the table `Attach`
            pub handler_object: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `peer_addr` in the table `Attach`
            pub peer_addr: ::planus::alloc::string::String,
            /// The field `local_port` in the table `Attach`
            pub local_port: u16,
            /// The field `remote_port` in the table `Attach`
            pub remote_port: u16,
            /// The field `acceptable_content_types` in the table `Attach`
            pub acceptable_content_types:
                ::core::option::Option<::planus::alloc::vec::Vec<self::Symbol>>,
        }

        impl Attach {
            /// Creates a [AttachBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AttachBuilder<()> {
                AttachBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_connect_type: impl ::planus::WriteAsDefault<self::ConnectType, self::ConnectType>,
                field_handler_object: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_peer_addr: impl ::planus::WriteAs<::planus::Offset<str>>,
                field_local_port: impl ::planus::WriteAsDefault<u16, u16>,
                field_remote_port: impl ::planus::WriteAsDefault<u16, u16>,
                field_acceptable_content_types: impl ::planus::WriteAsOptional<
                    ::planus::Offset<[::planus::Offset<self::Symbol>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_connect_type =
                    field_connect_type.prepare(builder, &self::ConnectType::Connected);
                let prepared_handler_object = field_handler_object.prepare(builder);
                let prepared_peer_addr = field_peer_addr.prepare(builder);
                let prepared_local_port = field_local_port.prepare(builder, &0);
                let prepared_remote_port = field_remote_port.prepare(builder, &0);
                let prepared_acceptable_content_types =
                    field_acceptable_content_types.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<18> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(2);
                table_writer.write_entry::<::planus::Offset<str>>(3);
                if prepared_acceptable_content_types.is_some() {
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::Symbol>]>>(6);
                }
                if prepared_local_port.is_some() {
                    table_writer.write_entry::<u16>(4);
                }
                if prepared_remote_port.is_some() {
                    table_writer.write_entry::<u16>(5);
                }
                if prepared_connect_type.is_some() {
                    table_writer.write_entry::<self::ConnectType>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_handler_object);
                        object_writer.write::<_, _, 4>(&prepared_peer_addr);
                        if let ::core::option::Option::Some(prepared_acceptable_content_types) =
                            prepared_acceptable_content_types
                        {
                            object_writer.write::<_, _, 4>(&prepared_acceptable_content_types);
                        }
                        if let ::core::option::Option::Some(prepared_local_port) =
                            prepared_local_port
                        {
                            object_writer.write::<_, _, 2>(&prepared_local_port);
                        }
                        if let ::core::option::Option::Some(prepared_remote_port) =
                            prepared_remote_port
                        {
                            object_writer.write::<_, _, 2>(&prepared_remote_port);
                        }
                        if let ::core::option::Option::Some(prepared_connect_type) =
                            prepared_connect_type
                        {
                            object_writer.write::<_, _, 1>(&prepared_connect_type);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Attach>> for Attach {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Attach> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Attach>> for Attach {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Attach>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Attach> for Attach {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Attach> {
                Attach::create(
                    builder,
                    &self.auth_token,
                    self.connect_type,
                    &self.handler_object,
                    &self.peer_addr,
                    self.local_port,
                    self.remote_port,
                    &self.acceptable_content_types,
                )
            }
        }

        /// Builder for serializing an instance of the [Attach] type.
        ///
        /// Can be created using the [Attach::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AttachBuilder<State>(State);

        impl AttachBuilder<()> {
            /// Setter for the [`auth_token` field](Attach#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T0>(self, value: T0) -> AttachBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                AttachBuilder((value,))
            }
        }

        impl<T0> AttachBuilder<(T0,)> {
            /// Setter for the [`connect_type` field](Attach#structfield.connect_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connect_type<T1>(self, value: T1) -> AttachBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<self::ConnectType, self::ConnectType>,
            {
                let (v0,) = self.0;
                AttachBuilder((v0, value))
            }

            /// Sets the [`connect_type` field](Attach#structfield.connect_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connect_type_as_default(self) -> AttachBuilder<(T0, ::planus::DefaultValue)> {
                self.connect_type(::planus::DefaultValue)
            }
        }

        impl<T0, T1> AttachBuilder<(T0, T1)> {
            /// Setter for the [`handler_object` field](Attach#structfield.handler_object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn handler_object<T2>(self, value: T2) -> AttachBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1) = self.0;
                AttachBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> AttachBuilder<(T0, T1, T2)> {
            /// Setter for the [`peer_addr` field](Attach#structfield.peer_addr).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn peer_addr<T3>(self, value: T3) -> AttachBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1, v2) = self.0;
                AttachBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> AttachBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`local_port` field](Attach#structfield.local_port).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn local_port<T4>(self, value: T4) -> AttachBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1, v2, v3) = self.0;
                AttachBuilder((v0, v1, v2, v3, value))
            }

            /// Sets the [`local_port` field](Attach#structfield.local_port) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn local_port_as_default(
                self,
            ) -> AttachBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                self.local_port(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4> AttachBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`remote_port` field](Attach#structfield.remote_port).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn remote_port<T5>(self, value: T5) -> AttachBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAsDefault<u16, u16>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                AttachBuilder((v0, v1, v2, v3, v4, value))
            }

            /// Sets the [`remote_port` field](Attach#structfield.remote_port) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn remote_port_as_default(
                self,
            ) -> AttachBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                self.remote_port(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5> AttachBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Setter for the [`acceptable_content_types` field](Attach#structfield.acceptable_content_types).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn acceptable_content_types<T6>(
                self,
                value: T6,
            ) -> AttachBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            where
                T6: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
            {
                let (v0, v1, v2, v3, v4, v5) = self.0;
                AttachBuilder((v0, v1, v2, v3, v4, v5, value))
            }

            /// Sets the [`acceptable_content_types` field](Attach#structfield.acceptable_content_types) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn acceptable_content_types_as_null(
                self,
            ) -> AttachBuilder<(T0, T1, T2, T3, T4, T5, ())> {
                self.acceptable_content_types(())
            }
        }

        impl<T0, T1, T2, T3, T4, T5, T6> AttachBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Attach].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Attach>
            where
                Self: ::planus::WriteAsOffset<Attach>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T1: ::planus::WriteAsDefault<self::ConnectType, self::ConnectType>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
            T4: ::planus::WriteAsDefault<u16, u16>,
            T5: ::planus::WriteAsDefault<u16, u16>,
            T6: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
        > ::planus::WriteAs<::planus::Offset<Attach>>
            for AttachBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            type Prepared = ::planus::Offset<Attach>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Attach> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T1: ::planus::WriteAsDefault<self::ConnectType, self::ConnectType>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
            T4: ::planus::WriteAsDefault<u16, u16>,
            T5: ::planus::WriteAsDefault<u16, u16>,
            T6: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<Attach>>
            for AttachBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            type Prepared = ::planus::Offset<Attach>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Attach>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T1: ::planus::WriteAsDefault<self::ConnectType, self::ConnectType>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
            T4: ::planus::WriteAsDefault<u16, u16>,
            T5: ::planus::WriteAsDefault<u16, u16>,
            T6: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<self::Symbol>]>>,
        > ::planus::WriteAsOffset<Attach> for AttachBuilder<(T0, T1, T2, T3, T4, T5, T6)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Attach> {
                let (v0, v1, v2, v3, v4, v5, v6) = &self.0;
                Attach::create(builder, v0, v1, v2, v3, v4, v5, v6)
            }
        }

        /// Reference to a deserialized [Attach].
        #[derive(Copy, Clone)]
        pub struct AttachRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AttachRef<'a> {
            /// Getter for the [`auth_token` field](Attach#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(0, "Attach", "auth_token")
            }

            /// Getter for the [`connect_type` field](Attach#structfield.connect_type).
            #[inline]
            pub fn connect_type(&self) -> ::planus::Result<self::ConnectType> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "Attach", "connect_type")?
                        .unwrap_or(self::ConnectType::Connected),
                )
            }

            /// Getter for the [`handler_object` field](Attach#structfield.handler_object).
            #[inline]
            pub fn handler_object(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(2, "Attach", "handler_object")
            }

            /// Getter for the [`peer_addr` field](Attach#structfield.peer_addr).
            #[inline]
            pub fn peer_addr(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(3, "Attach", "peer_addr")
            }

            /// Getter for the [`local_port` field](Attach#structfield.local_port).
            #[inline]
            pub fn local_port(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(self.0.access(4, "Attach", "local_port")?.unwrap_or(0))
            }

            /// Getter for the [`remote_port` field](Attach#structfield.remote_port).
            #[inline]
            pub fn remote_port(&self) -> ::planus::Result<u16> {
                ::core::result::Result::Ok(self.0.access(5, "Attach", "remote_port")?.unwrap_or(0))
            }

            /// Getter for the [`acceptable_content_types` field](Attach#structfield.acceptable_content_types).
            #[inline]
            pub fn acceptable_content_types(
                &self,
            ) -> ::planus::Result<
                ::core::option::Option<::planus::Vector<'a, ::planus::Result<self::SymbolRef<'a>>>>,
            > {
                self.0.access(6, "Attach", "acceptable_content_types")
            }
        }

        impl<'a> ::core::fmt::Debug for AttachRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AttachRef");
                f.field("auth_token", &self.auth_token());
                f.field("connect_type", &self.connect_type());
                f.field("handler_object", &self.handler_object());
                f.field("peer_addr", &self.peer_addr());
                f.field("local_port", &self.local_port());
                f.field("remote_port", &self.remote_port());
                if let ::core::option::Option::Some(field_acceptable_content_types) =
                    self.acceptable_content_types().transpose()
                {
                    f.field("acceptable_content_types", &field_acceptable_content_types);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AttachRef<'a>> for Attach {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AttachRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    connect_type: ::core::convert::TryInto::try_into(value.connect_type()?)?,
                    handler_object: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.handler_object()?)?,
                    ),
                    peer_addr: ::core::convert::Into::into(value.peer_addr()?),
                    local_port: ::core::convert::TryInto::try_into(value.local_port()?)?,
                    remote_port: ::core::convert::TryInto::try_into(value.remote_port()?)?,
                    acceptable_content_types: if let ::core::option::Option::Some(
                        acceptable_content_types,
                    ) = value.acceptable_content_types()?
                    {
                        ::core::option::Option::Some(acceptable_content_types.to_vec_result()?)
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AttachRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AttachRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[AttachRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Attach>> for Attach {
            type Value = ::planus::Offset<Attach>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Attach>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AttachRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AttachRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Command` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Command` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:854`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Command {
            /// The field `client_token` in the table `Command`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `Command`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `handler_object` in the table `Command`
            pub handler_object: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `command` in the table `Command`
            pub command: ::planus::alloc::string::String,
        }

        impl Command {
            /// Creates a [CommandBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CommandBuilder<()> {
                CommandBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_handler_object: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_command: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_handler_object = field_handler_object.prepare(builder);
                let prepared_command = field_command.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(2);
                table_writer.write_entry::<::planus::Offset<str>>(3);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_handler_object);
                        object_writer.write::<_, _, 4>(&prepared_command);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Command>> for Command {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Command> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Command>> for Command {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Command>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Command> for Command {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Command> {
                Command::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.handler_object,
                    &self.command,
                )
            }
        }

        /// Builder for serializing an instance of the [Command] type.
        ///
        /// Can be created using the [Command::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CommandBuilder<State>(State);

        impl CommandBuilder<()> {
            /// Setter for the [`client_token` field](Command#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> CommandBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                CommandBuilder((value,))
            }
        }

        impl<T0> CommandBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](Command#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> CommandBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                CommandBuilder((v0, value))
            }
        }

        impl<T0, T1> CommandBuilder<(T0, T1)> {
            /// Setter for the [`handler_object` field](Command#structfield.handler_object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn handler_object<T2>(self, value: T2) -> CommandBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1) = self.0;
                CommandBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> CommandBuilder<(T0, T1, T2)> {
            /// Setter for the [`command` field](Command#structfield.command).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn command<T3>(self, value: T3) -> CommandBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1, v2) = self.0;
                CommandBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> CommandBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Command].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Command>
            where
                Self: ::planus::WriteAsOffset<Command>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<Command>> for CommandBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<Command>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Command> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<Command>>
            for CommandBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<Command>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Command>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<Command> for CommandBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Command> {
                let (v0, v1, v2, v3) = &self.0;
                Command::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [Command].
        #[derive(Copy, Clone)]
        pub struct CommandRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CommandRef<'a> {
            /// Getter for the [`client_token` field](Command#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "Command", "client_token")
            }

            /// Getter for the [`auth_token` field](Command#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "Command", "auth_token")
            }

            /// Getter for the [`handler_object` field](Command#structfield.handler_object).
            #[inline]
            pub fn handler_object(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(2, "Command", "handler_object")
            }

            /// Getter for the [`command` field](Command#structfield.command).
            #[inline]
            pub fn command(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(3, "Command", "command")
            }
        }

        impl<'a> ::core::fmt::Debug for CommandRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CommandRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("handler_object", &self.handler_object());
                f.field("command", &self.command());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CommandRef<'a>> for Command {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CommandRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    handler_object: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.handler_object()?)?,
                    ),
                    command: ::core::convert::Into::into(value.command()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CommandRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CommandRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[CommandRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Command>> for Command {
            type Value = ::planus::Offset<Command>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Command>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CommandRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CommandRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Verbs` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Verbs` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:861`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Verbs {
            /// The field `client_token` in the table `Verbs`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `Verbs`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `object` in the table `Verbs`
            pub object: ::planus::alloc::boxed::Box<self::ObjectRef>,
            /// The field `inherited` in the table `Verbs`
            pub inherited: bool,
        }

        impl Verbs {
            /// Creates a [VerbsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbsBuilder<()> {
                VerbsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_object: impl ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
                field_inherited: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_object = field_object.prepare(builder);
                let prepared_inherited = field_inherited.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::ObjectRef>>(2);
                if prepared_inherited.is_some() {
                    table_writer.write_entry::<bool>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_object);
                        if let ::core::option::Option::Some(prepared_inherited) = prepared_inherited
                        {
                            object_writer.write::<_, _, 1>(&prepared_inherited);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Verbs>> for Verbs {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Verbs> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Verbs>> for Verbs {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Verbs>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Verbs> for Verbs {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Verbs> {
                Verbs::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.object,
                    self.inherited,
                )
            }
        }

        /// Builder for serializing an instance of the [Verbs] type.
        ///
        /// Can be created using the [Verbs::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbsBuilder<State>(State);

        impl VerbsBuilder<()> {
            /// Setter for the [`client_token` field](Verbs#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> VerbsBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                VerbsBuilder((value,))
            }
        }

        impl<T0> VerbsBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](Verbs#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> VerbsBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                VerbsBuilder((v0, value))
            }
        }

        impl<T0, T1> VerbsBuilder<(T0, T1)> {
            /// Setter for the [`object` field](Verbs#structfield.object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn object<T2>(self, value: T2) -> VerbsBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            {
                let (v0, v1) = self.0;
                VerbsBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> VerbsBuilder<(T0, T1, T2)> {
            /// Setter for the [`inherited` field](Verbs#structfield.inherited).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn inherited<T3>(self, value: T3) -> VerbsBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2) = self.0;
                VerbsBuilder((v0, v1, v2, value))
            }

            /// Sets the [`inherited` field](Verbs#structfield.inherited) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn inherited_as_default(
                self,
            ) -> VerbsBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.inherited(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> VerbsBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Verbs].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Verbs>
            where
                Self: ::planus::WriteAsOffset<Verbs>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAs<::planus::Offset<Verbs>> for VerbsBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<Verbs>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Verbs> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOptional<::planus::Offset<Verbs>> for VerbsBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<Verbs>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Verbs>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOffset<Verbs> for VerbsBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Verbs> {
                let (v0, v1, v2, v3) = &self.0;
                Verbs::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [Verbs].
        #[derive(Copy, Clone)]
        pub struct VerbsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbsRef<'a> {
            /// Getter for the [`client_token` field](Verbs#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "Verbs", "client_token")
            }

            /// Getter for the [`auth_token` field](Verbs#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "Verbs", "auth_token")
            }

            /// Getter for the [`object` field](Verbs#structfield.object).
            #[inline]
            pub fn object(&self) -> ::planus::Result<self::ObjectRefRef<'a>> {
                self.0.access_required(2, "Verbs", "object")
            }

            /// Getter for the [`inherited` field](Verbs#structfield.inherited).
            #[inline]
            pub fn inherited(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(self.0.access(3, "Verbs", "inherited")?.unwrap_or(false))
            }
        }

        impl<'a> ::core::fmt::Debug for VerbsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbsRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("object", &self.object());
                f.field("inherited", &self.inherited());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbsRef<'a>> for Verbs {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    object: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.object()?,
                    )?),
                    inherited: ::core::convert::TryInto::try_into(value.inherited()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[VerbsRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Verbs>> for Verbs {
            type Value = ::planus::Offset<Verbs>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Verbs>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbsRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `InvokeVerb` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `InvokeVerb` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:868`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct InvokeVerb {
            /// The field `client_token` in the table `InvokeVerb`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `InvokeVerb`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `object` in the table `InvokeVerb`
            pub object: ::planus::alloc::boxed::Box<self::ObjectRef>,
            /// The field `verb` in the table `InvokeVerb`
            pub verb: ::planus::alloc::boxed::Box<self::Symbol>,
            /// The field `args` in the table `InvokeVerb`
            pub args: ::planus::alloc::vec::Vec<self::VarBytes>,
        }

        impl InvokeVerb {
            /// Creates a [InvokeVerbBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> InvokeVerbBuilder<()> {
                InvokeVerbBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_object: impl ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
                field_verb: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
                field_args: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_object = field_object.prepare(builder);
                let prepared_verb = field_verb.prepare(builder);
                let prepared_args = field_args.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<14> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::ObjectRef>>(2);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(3);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::VarBytes>]>>(4);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_object);
                        object_writer.write::<_, _, 4>(&prepared_verb);
                        object_writer.write::<_, _, 4>(&prepared_args);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<InvokeVerb>> for InvokeVerb {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvokeVerb> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<InvokeVerb>> for InvokeVerb {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvokeVerb>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<InvokeVerb> for InvokeVerb {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvokeVerb> {
                InvokeVerb::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.object,
                    &self.verb,
                    &self.args,
                )
            }
        }

        /// Builder for serializing an instance of the [InvokeVerb] type.
        ///
        /// Can be created using the [InvokeVerb::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct InvokeVerbBuilder<State>(State);

        impl InvokeVerbBuilder<()> {
            /// Setter for the [`client_token` field](InvokeVerb#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> InvokeVerbBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                InvokeVerbBuilder((value,))
            }
        }

        impl<T0> InvokeVerbBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](InvokeVerb#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> InvokeVerbBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                InvokeVerbBuilder((v0, value))
            }
        }

        impl<T0, T1> InvokeVerbBuilder<(T0, T1)> {
            /// Setter for the [`object` field](InvokeVerb#structfield.object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn object<T2>(self, value: T2) -> InvokeVerbBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            {
                let (v0, v1) = self.0;
                InvokeVerbBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> InvokeVerbBuilder<(T0, T1, T2)> {
            /// Setter for the [`verb` field](InvokeVerb#structfield.verb).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verb<T3>(self, value: T3) -> InvokeVerbBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0, v1, v2) = self.0;
                InvokeVerbBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> InvokeVerbBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`args` field](InvokeVerb#structfield.args).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn args<T4>(self, value: T4) -> InvokeVerbBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            {
                let (v0, v1, v2, v3) = self.0;
                InvokeVerbBuilder((v0, v1, v2, v3, value))
            }
        }

        impl<T0, T1, T2, T3, T4> InvokeVerbBuilder<(T0, T1, T2, T3, T4)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [InvokeVerb].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvokeVerb>
            where
                Self: ::planus::WriteAsOffset<InvokeVerb>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
        > ::planus::WriteAs<::planus::Offset<InvokeVerb>>
            for InvokeVerbBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<InvokeVerb>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvokeVerb> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<InvokeVerb>>
            for InvokeVerbBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<InvokeVerb>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InvokeVerb>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
        > ::planus::WriteAsOffset<InvokeVerb> for InvokeVerbBuilder<(T0, T1, T2, T3, T4)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InvokeVerb> {
                let (v0, v1, v2, v3, v4) = &self.0;
                InvokeVerb::create(builder, v0, v1, v2, v3, v4)
            }
        }

        /// Reference to a deserialized [InvokeVerb].
        #[derive(Copy, Clone)]
        pub struct InvokeVerbRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> InvokeVerbRef<'a> {
            /// Getter for the [`client_token` field](InvokeVerb#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "InvokeVerb", "client_token")
            }

            /// Getter for the [`auth_token` field](InvokeVerb#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "InvokeVerb", "auth_token")
            }

            /// Getter for the [`object` field](InvokeVerb#structfield.object).
            #[inline]
            pub fn object(&self) -> ::planus::Result<self::ObjectRefRef<'a>> {
                self.0.access_required(2, "InvokeVerb", "object")
            }

            /// Getter for the [`verb` field](InvokeVerb#structfield.verb).
            #[inline]
            pub fn verb(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(3, "InvokeVerb", "verb")
            }

            /// Getter for the [`args` field](InvokeVerb#structfield.args).
            #[inline]
            pub fn args(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VarBytesRef<'a>>>>
            {
                self.0.access_required(4, "InvokeVerb", "args")
            }
        }

        impl<'a> ::core::fmt::Debug for InvokeVerbRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("InvokeVerbRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("object", &self.object());
                f.field("verb", &self.verb());
                f.field("args", &self.args());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<InvokeVerbRef<'a>> for InvokeVerb {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: InvokeVerbRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    object: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.object()?,
                    )?),
                    verb: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.verb()?,
                    )?),
                    args: value.args()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for InvokeVerbRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for InvokeVerbRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[InvokeVerbRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<InvokeVerb>> for InvokeVerb {
            type Value = ::planus::Offset<InvokeVerb>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<InvokeVerb>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for InvokeVerbRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[InvokeVerbRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Properties` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Properties` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:876`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Properties {
            /// The field `client_token` in the table `Properties`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `Properties`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `object` in the table `Properties`
            pub object: ::planus::alloc::boxed::Box<self::ObjectRef>,
            /// The field `inherited` in the table `Properties`
            pub inherited: bool,
        }

        impl Properties {
            /// Creates a [PropertiesBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertiesBuilder<()> {
                PropertiesBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_object: impl ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
                field_inherited: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_object = field_object.prepare(builder);
                let prepared_inherited = field_inherited.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::ObjectRef>>(2);
                if prepared_inherited.is_some() {
                    table_writer.write_entry::<bool>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_object);
                        if let ::core::option::Option::Some(prepared_inherited) = prepared_inherited
                        {
                            object_writer.write::<_, _, 1>(&prepared_inherited);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Properties>> for Properties {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Properties> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Properties>> for Properties {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Properties>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Properties> for Properties {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Properties> {
                Properties::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.object,
                    self.inherited,
                )
            }
        }

        /// Builder for serializing an instance of the [Properties] type.
        ///
        /// Can be created using the [Properties::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertiesBuilder<State>(State);

        impl PropertiesBuilder<()> {
            /// Setter for the [`client_token` field](Properties#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> PropertiesBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                PropertiesBuilder((value,))
            }
        }

        impl<T0> PropertiesBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](Properties#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> PropertiesBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                PropertiesBuilder((v0, value))
            }
        }

        impl<T0, T1> PropertiesBuilder<(T0, T1)> {
            /// Setter for the [`object` field](Properties#structfield.object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn object<T2>(self, value: T2) -> PropertiesBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            {
                let (v0, v1) = self.0;
                PropertiesBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> PropertiesBuilder<(T0, T1, T2)> {
            /// Setter for the [`inherited` field](Properties#structfield.inherited).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn inherited<T3>(self, value: T3) -> PropertiesBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0, v1, v2) = self.0;
                PropertiesBuilder((v0, v1, v2, value))
            }

            /// Sets the [`inherited` field](Properties#structfield.inherited) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn inherited_as_default(
                self,
            ) -> PropertiesBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.inherited(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> PropertiesBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Properties].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Properties>
            where
                Self: ::planus::WriteAsOffset<Properties>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAs<::planus::Offset<Properties>> for PropertiesBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<Properties>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Properties> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOptional<::planus::Offset<Properties>>
            for PropertiesBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<Properties>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Properties>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOffset<Properties> for PropertiesBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Properties> {
                let (v0, v1, v2, v3) = &self.0;
                Properties::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [Properties].
        #[derive(Copy, Clone)]
        pub struct PropertiesRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertiesRef<'a> {
            /// Getter for the [`client_token` field](Properties#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "Properties", "client_token")
            }

            /// Getter for the [`auth_token` field](Properties#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "Properties", "auth_token")
            }

            /// Getter for the [`object` field](Properties#structfield.object).
            #[inline]
            pub fn object(&self) -> ::planus::Result<self::ObjectRefRef<'a>> {
                self.0.access_required(2, "Properties", "object")
            }

            /// Getter for the [`inherited` field](Properties#structfield.inherited).
            #[inline]
            pub fn inherited(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "Properties", "inherited")?
                        .unwrap_or(false),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for PropertiesRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertiesRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("object", &self.object());
                f.field("inherited", &self.inherited());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertiesRef<'a>> for Properties {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropertiesRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    object: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.object()?,
                    )?),
                    inherited: ::core::convert::TryInto::try_into(value.inherited()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertiesRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertiesRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertiesRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Properties>> for Properties {
            type Value = ::planus::Offset<Properties>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Properties>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertiesRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropertiesRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Retrieve` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Retrieve` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:883`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Retrieve {
            /// The field `client_token` in the table `Retrieve`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `Retrieve`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `object` in the table `Retrieve`
            pub object: ::planus::alloc::boxed::Box<self::ObjectRef>,
            /// The field `entity_type` in the table `Retrieve`
            pub entity_type: self::EntityType,
            /// The field `name` in the table `Retrieve`
            pub name: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        impl Retrieve {
            /// Creates a [RetrieveBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RetrieveBuilder<()> {
                RetrieveBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_object: impl ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
                field_entity_type: impl ::planus::WriteAsDefault<self::EntityType, self::EntityType>,
                field_name: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_object = field_object.prepare(builder);
                let prepared_entity_type =
                    field_entity_type.prepare(builder, &self::EntityType::Property);
                let prepared_name = field_name.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<14> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::ObjectRef>>(2);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(4);
                if prepared_entity_type.is_some() {
                    table_writer.write_entry::<self::EntityType>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_object);
                        object_writer.write::<_, _, 4>(&prepared_name);
                        if let ::core::option::Option::Some(prepared_entity_type) =
                            prepared_entity_type
                        {
                            object_writer.write::<_, _, 1>(&prepared_entity_type);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Retrieve>> for Retrieve {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Retrieve> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Retrieve>> for Retrieve {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Retrieve>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Retrieve> for Retrieve {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Retrieve> {
                Retrieve::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.object,
                    self.entity_type,
                    &self.name,
                )
            }
        }

        /// Builder for serializing an instance of the [Retrieve] type.
        ///
        /// Can be created using the [Retrieve::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RetrieveBuilder<State>(State);

        impl RetrieveBuilder<()> {
            /// Setter for the [`client_token` field](Retrieve#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> RetrieveBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                RetrieveBuilder((value,))
            }
        }

        impl<T0> RetrieveBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](Retrieve#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> RetrieveBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                RetrieveBuilder((v0, value))
            }
        }

        impl<T0, T1> RetrieveBuilder<(T0, T1)> {
            /// Setter for the [`object` field](Retrieve#structfield.object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn object<T2>(self, value: T2) -> RetrieveBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            {
                let (v0, v1) = self.0;
                RetrieveBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> RetrieveBuilder<(T0, T1, T2)> {
            /// Setter for the [`entity_type` field](Retrieve#structfield.entity_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn entity_type<T3>(self, value: T3) -> RetrieveBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<self::EntityType, self::EntityType>,
            {
                let (v0, v1, v2) = self.0;
                RetrieveBuilder((v0, v1, v2, value))
            }

            /// Sets the [`entity_type` field](Retrieve#structfield.entity_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn entity_type_as_default(
                self,
            ) -> RetrieveBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.entity_type(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> RetrieveBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`name` field](Retrieve#structfield.name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn name<T4>(self, value: T4) -> RetrieveBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0, v1, v2, v3) = self.0;
                RetrieveBuilder((v0, v1, v2, v3, value))
            }
        }

        impl<T0, T1, T2, T3, T4> RetrieveBuilder<(T0, T1, T2, T3, T4)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Retrieve].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Retrieve>
            where
                Self: ::planus::WriteAsOffset<Retrieve>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAsDefault<self::EntityType, self::EntityType>,
            T4: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<Retrieve>> for RetrieveBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<Retrieve>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Retrieve> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAsDefault<self::EntityType, self::EntityType>,
            T4: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<Retrieve>>
            for RetrieveBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<Retrieve>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Retrieve>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAsDefault<self::EntityType, self::EntityType>,
            T4: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<Retrieve> for RetrieveBuilder<(T0, T1, T2, T3, T4)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Retrieve> {
                let (v0, v1, v2, v3, v4) = &self.0;
                Retrieve::create(builder, v0, v1, v2, v3, v4)
            }
        }

        /// Reference to a deserialized [Retrieve].
        #[derive(Copy, Clone)]
        pub struct RetrieveRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RetrieveRef<'a> {
            /// Getter for the [`client_token` field](Retrieve#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "Retrieve", "client_token")
            }

            /// Getter for the [`auth_token` field](Retrieve#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "Retrieve", "auth_token")
            }

            /// Getter for the [`object` field](Retrieve#structfield.object).
            #[inline]
            pub fn object(&self) -> ::planus::Result<self::ObjectRefRef<'a>> {
                self.0.access_required(2, "Retrieve", "object")
            }

            /// Getter for the [`entity_type` field](Retrieve#structfield.entity_type).
            #[inline]
            pub fn entity_type(&self) -> ::planus::Result<self::EntityType> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "Retrieve", "entity_type")?
                        .unwrap_or(self::EntityType::Property),
                )
            }

            /// Getter for the [`name` field](Retrieve#structfield.name).
            #[inline]
            pub fn name(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(4, "Retrieve", "name")
            }
        }

        impl<'a> ::core::fmt::Debug for RetrieveRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RetrieveRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("object", &self.object());
                f.field("entity_type", &self.entity_type());
                f.field("name", &self.name());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RetrieveRef<'a>> for Retrieve {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RetrieveRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    object: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.object()?,
                    )?),
                    entity_type: ::core::convert::TryInto::try_into(value.entity_type()?)?,
                    name: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.name()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RetrieveRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RetrieveRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[RetrieveRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Retrieve>> for Retrieve {
            type Value = ::planus::Offset<Retrieve>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Retrieve>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RetrieveRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RetrieveRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Program` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Program` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:891`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Program {
            /// The field `client_token` in the table `Program`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `Program`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `object` in the table `Program`
            pub object: ::planus::alloc::boxed::Box<self::ObjectRef>,
            /// The field `verb` in the table `Program`
            pub verb: ::planus::alloc::boxed::Box<self::Symbol>,
            /// The field `code` in the table `Program`
            pub code: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
        }

        impl Program {
            /// Creates a [ProgramBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ProgramBuilder<()> {
                ProgramBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_object: impl ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
                field_verb: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
                field_code: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_object = field_object.prepare(builder);
                let prepared_verb = field_verb.prepare(builder);
                let prepared_code = field_code.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<14> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::ObjectRef>>(2);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(3);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(4);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_object);
                        object_writer.write::<_, _, 4>(&prepared_verb);
                        object_writer.write::<_, _, 4>(&prepared_code);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Program>> for Program {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Program> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Program>> for Program {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Program>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Program> for Program {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Program> {
                Program::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.object,
                    &self.verb,
                    &self.code,
                )
            }
        }

        /// Builder for serializing an instance of the [Program] type.
        ///
        /// Can be created using the [Program::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ProgramBuilder<State>(State);

        impl ProgramBuilder<()> {
            /// Setter for the [`client_token` field](Program#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> ProgramBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                ProgramBuilder((value,))
            }
        }

        impl<T0> ProgramBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](Program#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> ProgramBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                ProgramBuilder((v0, value))
            }
        }

        impl<T0, T1> ProgramBuilder<(T0, T1)> {
            /// Setter for the [`object` field](Program#structfield.object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn object<T2>(self, value: T2) -> ProgramBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            {
                let (v0, v1) = self.0;
                ProgramBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> ProgramBuilder<(T0, T1, T2)> {
            /// Setter for the [`verb` field](Program#structfield.verb).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verb<T3>(self, value: T3) -> ProgramBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0, v1, v2) = self.0;
                ProgramBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> ProgramBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`code` field](Program#structfield.code).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn code<T4>(self, value: T4) -> ProgramBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
            {
                let (v0, v1, v2, v3) = self.0;
                ProgramBuilder((v0, v1, v2, v3, value))
            }
        }

        impl<T0, T1, T2, T3, T4> ProgramBuilder<(T0, T1, T2, T3, T4)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Program].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Program>
            where
                Self: ::planus::WriteAsOffset<Program>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
        > ::planus::WriteAs<::planus::Offset<Program>> for ProgramBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<Program>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Program> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<Program>>
            for ProgramBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<Program>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Program>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
        > ::planus::WriteAsOffset<Program> for ProgramBuilder<(T0, T1, T2, T3, T4)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Program> {
                let (v0, v1, v2, v3, v4) = &self.0;
                Program::create(builder, v0, v1, v2, v3, v4)
            }
        }

        /// Reference to a deserialized [Program].
        #[derive(Copy, Clone)]
        pub struct ProgramRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ProgramRef<'a> {
            /// Getter for the [`client_token` field](Program#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "Program", "client_token")
            }

            /// Getter for the [`auth_token` field](Program#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "Program", "auth_token")
            }

            /// Getter for the [`object` field](Program#structfield.object).
            #[inline]
            pub fn object(&self) -> ::planus::Result<self::ObjectRefRef<'a>> {
                self.0.access_required(2, "Program", "object")
            }

            /// Getter for the [`verb` field](Program#structfield.verb).
            #[inline]
            pub fn verb(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(3, "Program", "verb")
            }

            /// Getter for the [`code` field](Program#structfield.code).
            #[inline]
            pub fn code(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>>
            {
                self.0.access_required(4, "Program", "code")
            }
        }

        impl<'a> ::core::fmt::Debug for ProgramRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ProgramRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("object", &self.object());
                f.field("verb", &self.verb());
                f.field("code", &self.code());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ProgramRef<'a>> for Program {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ProgramRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    object: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.object()?,
                    )?),
                    verb: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.verb()?,
                    )?),
                    code: value.code()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ProgramRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ProgramRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[ProgramRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Program>> for Program {
            type Value = ::planus::Offset<Program>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Program>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ProgramRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ProgramRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `RequestedInput` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RequestedInput` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:899`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RequestedInput {
            /// The field `client_token` in the table `RequestedInput`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `RequestedInput`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `request_id` in the table `RequestedInput`
            pub request_id: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `input` in the table `RequestedInput`
            pub input: ::planus::alloc::boxed::Box<self::VarBytes>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for RequestedInput {
            fn default() -> Self {
                Self {
                    client_token: ::core::default::Default::default(),
                    auth_token: ::core::default::Default::default(),
                    request_id: ::core::default::Default::default(),
                    input: ::core::default::Default::default(),
                }
            }
        }

        impl RequestedInput {
            /// Creates a [RequestedInputBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RequestedInputBuilder<()> {
                RequestedInputBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_request_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_input: impl ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_request_id = field_request_id.prepare(builder);
                let prepared_input = field_input.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(2);
                table_writer.write_entry::<::planus::Offset<self::VarBytes>>(3);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_request_id);
                        object_writer.write::<_, _, 4>(&prepared_input);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RequestedInput>> for RequestedInput {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestedInput> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RequestedInput>> for RequestedInput {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestedInput>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RequestedInput> for RequestedInput {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestedInput> {
                RequestedInput::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.request_id,
                    &self.input,
                )
            }
        }

        /// Builder for serializing an instance of the [RequestedInput] type.
        ///
        /// Can be created using the [RequestedInput::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RequestedInputBuilder<State>(State);

        impl RequestedInputBuilder<()> {
            /// Setter for the [`client_token` field](RequestedInput#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> RequestedInputBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                RequestedInputBuilder((value,))
            }
        }

        impl<T0> RequestedInputBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](RequestedInput#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> RequestedInputBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                RequestedInputBuilder((v0, value))
            }
        }

        impl<T0, T1> RequestedInputBuilder<(T0, T1)> {
            /// Setter for the [`request_id` field](RequestedInput#structfield.request_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn request_id<T2>(self, value: T2) -> RequestedInputBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                let (v0, v1) = self.0;
                RequestedInputBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> RequestedInputBuilder<(T0, T1, T2)> {
            /// Setter for the [`input` field](RequestedInput#structfield.input).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn input<T3>(self, value: T3) -> RequestedInputBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            {
                let (v0, v1, v2) = self.0;
                RequestedInputBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> RequestedInputBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RequestedInput].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestedInput>
            where
                Self: ::planus::WriteAsOffset<RequestedInput>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T3: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAs<::planus::Offset<RequestedInput>>
            for RequestedInputBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<RequestedInput>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestedInput> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T3: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOptional<::planus::Offset<RequestedInput>>
            for RequestedInputBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<RequestedInput>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestedInput>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T3: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOffset<RequestedInput> for RequestedInputBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestedInput> {
                let (v0, v1, v2, v3) = &self.0;
                RequestedInput::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [RequestedInput].
        #[derive(Copy, Clone)]
        pub struct RequestedInputRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RequestedInputRef<'a> {
            /// Getter for the [`client_token` field](RequestedInput#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "RequestedInput", "client_token")
            }

            /// Getter for the [`auth_token` field](RequestedInput#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "RequestedInput", "auth_token")
            }

            /// Getter for the [`request_id` field](RequestedInput#structfield.request_id).
            #[inline]
            pub fn request_id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(2, "RequestedInput", "request_id")
            }

            /// Getter for the [`input` field](RequestedInput#structfield.input).
            #[inline]
            pub fn input(&self) -> ::planus::Result<self::VarBytesRef<'a>> {
                self.0.access_required(3, "RequestedInput", "input")
            }
        }

        impl<'a> ::core::fmt::Debug for RequestedInputRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RequestedInputRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("request_id", &self.request_id());
                f.field("input", &self.input());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RequestedInputRef<'a>> for RequestedInput {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RequestedInputRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    request_id: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.request_id()?)?,
                    ),
                    input: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.input()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RequestedInputRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RequestedInputRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RequestedInputRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RequestedInput>> for RequestedInput {
            type Value = ::planus::Offset<RequestedInput>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RequestedInput>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RequestedInputRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RequestedInputRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `OutOfBand` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `OutOfBand` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:906`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct OutOfBand {
            /// The field `client_token` in the table `OutOfBand`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `OutOfBand`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `handler_object` in the table `OutOfBand`
            pub handler_object: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `command` in the table `OutOfBand`
            pub command: ::planus::alloc::string::String,
        }

        impl OutOfBand {
            /// Creates a [OutOfBandBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> OutOfBandBuilder<()> {
                OutOfBandBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_handler_object: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_command: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_handler_object = field_handler_object.prepare(builder);
                let prepared_command = field_command.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(2);
                table_writer.write_entry::<::planus::Offset<str>>(3);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_handler_object);
                        object_writer.write::<_, _, 4>(&prepared_command);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<OutOfBand>> for OutOfBand {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<OutOfBand> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<OutOfBand>> for OutOfBand {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<OutOfBand>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<OutOfBand> for OutOfBand {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<OutOfBand> {
                OutOfBand::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.handler_object,
                    &self.command,
                )
            }
        }

        /// Builder for serializing an instance of the [OutOfBand] type.
        ///
        /// Can be created using the [OutOfBand::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct OutOfBandBuilder<State>(State);

        impl OutOfBandBuilder<()> {
            /// Setter for the [`client_token` field](OutOfBand#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> OutOfBandBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                OutOfBandBuilder((value,))
            }
        }

        impl<T0> OutOfBandBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](OutOfBand#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> OutOfBandBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                OutOfBandBuilder((v0, value))
            }
        }

        impl<T0, T1> OutOfBandBuilder<(T0, T1)> {
            /// Setter for the [`handler_object` field](OutOfBand#structfield.handler_object).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn handler_object<T2>(self, value: T2) -> OutOfBandBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1) = self.0;
                OutOfBandBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> OutOfBandBuilder<(T0, T1, T2)> {
            /// Setter for the [`command` field](OutOfBand#structfield.command).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn command<T3>(self, value: T3) -> OutOfBandBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1, v2) = self.0;
                OutOfBandBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> OutOfBandBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [OutOfBand].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<OutOfBand>
            where
                Self: ::planus::WriteAsOffset<OutOfBand>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<OutOfBand>> for OutOfBandBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<OutOfBand>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<OutOfBand> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<OutOfBand>>
            for OutOfBandBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<OutOfBand>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<OutOfBand>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<OutOfBand> for OutOfBandBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<OutOfBand> {
                let (v0, v1, v2, v3) = &self.0;
                OutOfBand::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [OutOfBand].
        #[derive(Copy, Clone)]
        pub struct OutOfBandRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> OutOfBandRef<'a> {
            /// Getter for the [`client_token` field](OutOfBand#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "OutOfBand", "client_token")
            }

            /// Getter for the [`auth_token` field](OutOfBand#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "OutOfBand", "auth_token")
            }

            /// Getter for the [`handler_object` field](OutOfBand#structfield.handler_object).
            #[inline]
            pub fn handler_object(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(2, "OutOfBand", "handler_object")
            }

            /// Getter for the [`command` field](OutOfBand#structfield.command).
            #[inline]
            pub fn command(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(3, "OutOfBand", "command")
            }
        }

        impl<'a> ::core::fmt::Debug for OutOfBandRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("OutOfBandRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("handler_object", &self.handler_object());
                f.field("command", &self.command());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<OutOfBandRef<'a>> for OutOfBand {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: OutOfBandRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    handler_object: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.handler_object()?)?,
                    ),
                    command: ::core::convert::Into::into(value.command()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for OutOfBandRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for OutOfBandRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[OutOfBandRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<OutOfBand>> for OutOfBand {
            type Value = ::planus::Offset<OutOfBand>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<OutOfBand>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for OutOfBandRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[OutOfBandRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Eval` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Eval` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:913`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Eval {
            /// The field `client_token` in the table `Eval`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `Eval`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `expression` in the table `Eval`
            pub expression: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Eval {
            fn default() -> Self {
                Self {
                    client_token: ::core::default::Default::default(),
                    auth_token: ::core::default::Default::default(),
                    expression: ::core::default::Default::default(),
                }
            }
        }

        impl Eval {
            /// Creates a [EvalBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> EvalBuilder<()> {
                EvalBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_expression: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_expression = field_expression.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<str>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_expression);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Eval>> for Eval {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Eval> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Eval>> for Eval {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Eval>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Eval> for Eval {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Eval> {
                Eval::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.expression,
                )
            }
        }

        /// Builder for serializing an instance of the [Eval] type.
        ///
        /// Can be created using the [Eval::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct EvalBuilder<State>(State);

        impl EvalBuilder<()> {
            /// Setter for the [`client_token` field](Eval#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> EvalBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                EvalBuilder((value,))
            }
        }

        impl<T0> EvalBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](Eval#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> EvalBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                EvalBuilder((v0, value))
            }
        }

        impl<T0, T1> EvalBuilder<(T0, T1)> {
            /// Setter for the [`expression` field](Eval#structfield.expression).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn expression<T2>(self, value: T2) -> EvalBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1) = self.0;
                EvalBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> EvalBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Eval].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Eval>
            where
                Self: ::planus::WriteAsOffset<Eval>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<Eval>> for EvalBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<Eval>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Eval> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<Eval>> for EvalBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<Eval>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Eval>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<Eval> for EvalBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Eval> {
                let (v0, v1, v2) = &self.0;
                Eval::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [Eval].
        #[derive(Copy, Clone)]
        pub struct EvalRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> EvalRef<'a> {
            /// Getter for the [`client_token` field](Eval#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "Eval", "client_token")
            }

            /// Getter for the [`auth_token` field](Eval#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "Eval", "auth_token")
            }

            /// Getter for the [`expression` field](Eval#structfield.expression).
            #[inline]
            pub fn expression(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(2, "Eval", "expression")
            }
        }

        impl<'a> ::core::fmt::Debug for EvalRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("EvalRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("expression", &self.expression());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<EvalRef<'a>> for Eval {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: EvalRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    expression: ::core::convert::Into::into(value.expression()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for EvalRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for EvalRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[EvalRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Eval>> for Eval {
            type Value = ::planus::Offset<Eval>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Eval>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for EvalRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[EvalRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Resolve` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Resolve` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:919`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Resolve {
            /// The field `client_token` in the table `Resolve`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `Resolve`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `objref` in the table `Resolve`
            pub objref: ::planus::alloc::boxed::Box<self::ObjectRef>,
        }

        impl Resolve {
            /// Creates a [ResolveBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ResolveBuilder<()> {
                ResolveBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_objref: impl ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_objref = field_objref.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::ObjectRef>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_objref);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Resolve>> for Resolve {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Resolve> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Resolve>> for Resolve {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Resolve>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Resolve> for Resolve {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Resolve> {
                Resolve::create(builder, &self.client_token, &self.auth_token, &self.objref)
            }
        }

        /// Builder for serializing an instance of the [Resolve] type.
        ///
        /// Can be created using the [Resolve::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ResolveBuilder<State>(State);

        impl ResolveBuilder<()> {
            /// Setter for the [`client_token` field](Resolve#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> ResolveBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                ResolveBuilder((value,))
            }
        }

        impl<T0> ResolveBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](Resolve#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> ResolveBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                ResolveBuilder((v0, value))
            }
        }

        impl<T0, T1> ResolveBuilder<(T0, T1)> {
            /// Setter for the [`objref` field](Resolve#structfield.objref).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn objref<T2>(self, value: T2) -> ResolveBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
            {
                let (v0, v1) = self.0;
                ResolveBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> ResolveBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Resolve].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Resolve>
            where
                Self: ::planus::WriteAsOffset<Resolve>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
        > ::planus::WriteAs<::planus::Offset<Resolve>> for ResolveBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<Resolve>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Resolve> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
        > ::planus::WriteAsOptional<::planus::Offset<Resolve>> for ResolveBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<Resolve>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Resolve>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::ObjectRef>>,
        > ::planus::WriteAsOffset<Resolve> for ResolveBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Resolve> {
                let (v0, v1, v2) = &self.0;
                Resolve::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [Resolve].
        #[derive(Copy, Clone)]
        pub struct ResolveRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ResolveRef<'a> {
            /// Getter for the [`client_token` field](Resolve#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "Resolve", "client_token")
            }

            /// Getter for the [`auth_token` field](Resolve#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "Resolve", "auth_token")
            }

            /// Getter for the [`objref` field](Resolve#structfield.objref).
            #[inline]
            pub fn objref(&self) -> ::planus::Result<self::ObjectRefRef<'a>> {
                self.0.access_required(2, "Resolve", "objref")
            }
        }

        impl<'a> ::core::fmt::Debug for ResolveRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ResolveRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("objref", &self.objref());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ResolveRef<'a>> for Resolve {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ResolveRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    objref: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.objref()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ResolveRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ResolveRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[ResolveRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Resolve>> for Resolve {
            type Value = ::planus::Offset<Resolve>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Resolve>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ResolveRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ResolveRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ClientPong` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ClientPong` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:925`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ClientPong {
            /// The field `client_token` in the table `ClientPong`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `client_sys_time` in the table `ClientPong`
            pub client_sys_time: u64,
            /// The field `player` in the table `ClientPong`
            pub player: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `host_type` in the table `ClientPong`
            pub host_type: self::HostType,
            /// The field `socket_addr` in the table `ClientPong`
            pub socket_addr: ::planus::alloc::string::String,
        }

        impl ClientPong {
            /// Creates a [ClientPongBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ClientPongBuilder<()> {
                ClientPongBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_client_sys_time: impl ::planus::WriteAsDefault<u64, u64>,
                field_player: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_host_type: impl ::planus::WriteAsDefault<self::HostType, self::HostType>,
                field_socket_addr: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_client_sys_time = field_client_sys_time.prepare(builder, &0);
                let prepared_player = field_player.prepare(builder);
                let prepared_host_type = field_host_type.prepare(builder, &self::HostType::Tcp);
                let prepared_socket_addr = field_socket_addr.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<14> =
                    ::core::default::Default::default();
                if prepared_client_sys_time.is_some() {
                    table_writer.write_entry::<u64>(1);
                }
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(2);
                table_writer.write_entry::<::planus::Offset<str>>(4);
                if prepared_host_type.is_some() {
                    table_writer.write_entry::<self::HostType>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_client_sys_time) =
                            prepared_client_sys_time
                        {
                            object_writer.write::<_, _, 8>(&prepared_client_sys_time);
                        }
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_player);
                        object_writer.write::<_, _, 4>(&prepared_socket_addr);
                        if let ::core::option::Option::Some(prepared_host_type) = prepared_host_type
                        {
                            object_writer.write::<_, _, 1>(&prepared_host_type);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ClientPong>> for ClientPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ClientPong>> for ClientPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ClientPong> for ClientPong {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientPong> {
                ClientPong::create(
                    builder,
                    &self.client_token,
                    self.client_sys_time,
                    &self.player,
                    self.host_type,
                    &self.socket_addr,
                )
            }
        }

        /// Builder for serializing an instance of the [ClientPong] type.
        ///
        /// Can be created using the [ClientPong::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ClientPongBuilder<State>(State);

        impl ClientPongBuilder<()> {
            /// Setter for the [`client_token` field](ClientPong#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> ClientPongBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                ClientPongBuilder((value,))
            }
        }

        impl<T0> ClientPongBuilder<(T0,)> {
            /// Setter for the [`client_sys_time` field](ClientPong#structfield.client_sys_time).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_sys_time<T1>(self, value: T1) -> ClientPongBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0,) = self.0;
                ClientPongBuilder((v0, value))
            }

            /// Sets the [`client_sys_time` field](ClientPong#structfield.client_sys_time) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_sys_time_as_default(
                self,
            ) -> ClientPongBuilder<(T0, ::planus::DefaultValue)> {
                self.client_sys_time(::planus::DefaultValue)
            }
        }

        impl<T0, T1> ClientPongBuilder<(T0, T1)> {
            /// Setter for the [`player` field](ClientPong#structfield.player).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn player<T2>(self, value: T2) -> ClientPongBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1) = self.0;
                ClientPongBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> ClientPongBuilder<(T0, T1, T2)> {
            /// Setter for the [`host_type` field](ClientPong#structfield.host_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_type<T3>(self, value: T3) -> ClientPongBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            {
                let (v0, v1, v2) = self.0;
                ClientPongBuilder((v0, v1, v2, value))
            }

            /// Sets the [`host_type` field](ClientPong#structfield.host_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_type_as_default(
                self,
            ) -> ClientPongBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                self.host_type(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3> ClientPongBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`socket_addr` field](ClientPong#structfield.socket_addr).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn socket_addr<T4>(self, value: T4) -> ClientPongBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1, v2, v3) = self.0;
                ClientPongBuilder((v0, v1, v2, v3, value))
            }
        }

        impl<T0, T1, T2, T3, T4> ClientPongBuilder<(T0, T1, T2, T3, T4)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ClientPong].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientPong>
            where
                Self: ::planus::WriteAsOffset<ClientPong>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T4: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<ClientPong>>
            for ClientPongBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<ClientPong>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T4: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<ClientPong>>
            for ClientPongBuilder<(T0, T1, T2, T3, T4)>
        {
            type Prepared = ::planus::Offset<ClientPong>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAsDefault<u64, u64>,
            T2: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T3: ::planus::WriteAsDefault<self::HostType, self::HostType>,
            T4: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<ClientPong> for ClientPongBuilder<(T0, T1, T2, T3, T4)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientPong> {
                let (v0, v1, v2, v3, v4) = &self.0;
                ClientPong::create(builder, v0, v1, v2, v3, v4)
            }
        }

        /// Reference to a deserialized [ClientPong].
        #[derive(Copy, Clone)]
        pub struct ClientPongRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ClientPongRef<'a> {
            /// Getter for the [`client_token` field](ClientPong#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "ClientPong", "client_token")
            }

            /// Getter for the [`client_sys_time` field](ClientPong#structfield.client_sys_time).
            #[inline]
            pub fn client_sys_time(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(1, "ClientPong", "client_sys_time")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`player` field](ClientPong#structfield.player).
            #[inline]
            pub fn player(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(2, "ClientPong", "player")
            }

            /// Getter for the [`host_type` field](ClientPong#structfield.host_type).
            #[inline]
            pub fn host_type(&self) -> ::planus::Result<self::HostType> {
                ::core::result::Result::Ok(
                    self.0
                        .access(3, "ClientPong", "host_type")?
                        .unwrap_or(self::HostType::Tcp),
                )
            }

            /// Getter for the [`socket_addr` field](ClientPong#structfield.socket_addr).
            #[inline]
            pub fn socket_addr(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(4, "ClientPong", "socket_addr")
            }
        }

        impl<'a> ::core::fmt::Debug for ClientPongRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ClientPongRef");
                f.field("client_token", &self.client_token());
                f.field("client_sys_time", &self.client_sys_time());
                f.field("player", &self.player());
                f.field("host_type", &self.host_type());
                f.field("socket_addr", &self.socket_addr());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ClientPongRef<'a>> for ClientPong {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ClientPongRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    client_sys_time: ::core::convert::TryInto::try_into(value.client_sys_time()?)?,
                    player: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.player()?,
                    )?),
                    host_type: ::core::convert::TryInto::try_into(value.host_type()?)?,
                    socket_addr: ::core::convert::Into::into(value.socket_addr()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ClientPongRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ClientPongRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ClientPongRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ClientPong>> for ClientPong {
            type Value = ::planus::Offset<ClientPong>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ClientPong>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ClientPongRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ClientPongRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `RequestHistory` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RequestHistory` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:933`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RequestHistory {
            /// The field `client_token` in the table `RequestHistory`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `RequestHistory`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `history_recall` in the table `RequestHistory`
            pub history_recall: ::planus::alloc::boxed::Box<self::HistoryRecall>,
        }

        impl RequestHistory {
            /// Creates a [RequestHistoryBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RequestHistoryBuilder<()> {
                RequestHistoryBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_history_recall: impl ::planus::WriteAs<::planus::Offset<self::HistoryRecall>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_history_recall = field_history_recall.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::HistoryRecall>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_history_recall);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RequestHistory>> for RequestHistory {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestHistory> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RequestHistory>> for RequestHistory {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestHistory>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RequestHistory> for RequestHistory {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestHistory> {
                RequestHistory::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.history_recall,
                )
            }
        }

        /// Builder for serializing an instance of the [RequestHistory] type.
        ///
        /// Can be created using the [RequestHistory::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RequestHistoryBuilder<State>(State);

        impl RequestHistoryBuilder<()> {
            /// Setter for the [`client_token` field](RequestHistory#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> RequestHistoryBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                RequestHistoryBuilder((value,))
            }
        }

        impl<T0> RequestHistoryBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](RequestHistory#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> RequestHistoryBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                RequestHistoryBuilder((v0, value))
            }
        }

        impl<T0, T1> RequestHistoryBuilder<(T0, T1)> {
            /// Setter for the [`history_recall` field](RequestHistory#structfield.history_recall).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn history_recall<T2>(self, value: T2) -> RequestHistoryBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::HistoryRecall>>,
            {
                let (v0, v1) = self.0;
                RequestHistoryBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> RequestHistoryBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RequestHistory].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestHistory>
            where
                Self: ::planus::WriteAsOffset<RequestHistory>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::HistoryRecall>>,
        > ::planus::WriteAs<::planus::Offset<RequestHistory>>
            for RequestHistoryBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RequestHistory>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestHistory> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::HistoryRecall>>,
        > ::planus::WriteAsOptional<::planus::Offset<RequestHistory>>
            for RequestHistoryBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RequestHistory>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestHistory>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::HistoryRecall>>,
        > ::planus::WriteAsOffset<RequestHistory> for RequestHistoryBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestHistory> {
                let (v0, v1, v2) = &self.0;
                RequestHistory::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [RequestHistory].
        #[derive(Copy, Clone)]
        pub struct RequestHistoryRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RequestHistoryRef<'a> {
            /// Getter for the [`client_token` field](RequestHistory#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "RequestHistory", "client_token")
            }

            /// Getter for the [`auth_token` field](RequestHistory#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0.access_required(1, "RequestHistory", "auth_token")
            }

            /// Getter for the [`history_recall` field](RequestHistory#structfield.history_recall).
            #[inline]
            pub fn history_recall(&self) -> ::planus::Result<self::HistoryRecallRef<'a>> {
                self.0
                    .access_required(2, "RequestHistory", "history_recall")
            }
        }

        impl<'a> ::core::fmt::Debug for RequestHistoryRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RequestHistoryRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("history_recall", &self.history_recall());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RequestHistoryRef<'a>> for RequestHistory {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RequestHistoryRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    history_recall: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.history_recall()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RequestHistoryRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RequestHistoryRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RequestHistoryRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RequestHistory>> for RequestHistory {
            type Value = ::planus::Offset<RequestHistory>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RequestHistory>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RequestHistoryRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RequestHistoryRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `RequestCurrentPresentations` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RequestCurrentPresentations` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:939`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RequestCurrentPresentations {
            /// The field `client_token` in the table `RequestCurrentPresentations`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `RequestCurrentPresentations`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for RequestCurrentPresentations {
            fn default() -> Self {
                Self {
                    client_token: ::core::default::Default::default(),
                    auth_token: ::core::default::Default::default(),
                }
            }
        }

        impl RequestCurrentPresentations {
            /// Creates a [RequestCurrentPresentationsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RequestCurrentPresentationsBuilder<()> {
                RequestCurrentPresentationsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RequestCurrentPresentations>>
            for RequestCurrentPresentations
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestCurrentPresentations> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RequestCurrentPresentations>>
            for RequestCurrentPresentations
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestCurrentPresentations>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RequestCurrentPresentations> for RequestCurrentPresentations {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestCurrentPresentations> {
                RequestCurrentPresentations::create(builder, &self.client_token, &self.auth_token)
            }
        }

        /// Builder for serializing an instance of the [RequestCurrentPresentations] type.
        ///
        /// Can be created using the [RequestCurrentPresentations::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RequestCurrentPresentationsBuilder<State>(State);

        impl RequestCurrentPresentationsBuilder<()> {
            /// Setter for the [`client_token` field](RequestCurrentPresentations#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> RequestCurrentPresentationsBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                RequestCurrentPresentationsBuilder((value,))
            }
        }

        impl<T0> RequestCurrentPresentationsBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](RequestCurrentPresentations#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> RequestCurrentPresentationsBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                RequestCurrentPresentationsBuilder((v0, value))
            }
        }

        impl<T0, T1> RequestCurrentPresentationsBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RequestCurrentPresentations].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestCurrentPresentations>
            where
                Self: ::planus::WriteAsOffset<RequestCurrentPresentations>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
        > ::planus::WriteAs<::planus::Offset<RequestCurrentPresentations>>
            for RequestCurrentPresentationsBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<RequestCurrentPresentations>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestCurrentPresentations> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
        > ::planus::WriteAsOptional<::planus::Offset<RequestCurrentPresentations>>
            for RequestCurrentPresentationsBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<RequestCurrentPresentations>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestCurrentPresentations>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
        > ::planus::WriteAsOffset<RequestCurrentPresentations>
            for RequestCurrentPresentationsBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestCurrentPresentations> {
                let (v0, v1) = &self.0;
                RequestCurrentPresentations::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [RequestCurrentPresentations].
        #[derive(Copy, Clone)]
        pub struct RequestCurrentPresentationsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RequestCurrentPresentationsRef<'a> {
            /// Getter for the [`client_token` field](RequestCurrentPresentations#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0
                    .access_required(0, "RequestCurrentPresentations", "client_token")
            }

            /// Getter for the [`auth_token` field](RequestCurrentPresentations#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0
                    .access_required(1, "RequestCurrentPresentations", "auth_token")
            }
        }

        impl<'a> ::core::fmt::Debug for RequestCurrentPresentationsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RequestCurrentPresentationsRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RequestCurrentPresentationsRef<'a>>
            for RequestCurrentPresentations
        {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RequestCurrentPresentationsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RequestCurrentPresentationsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RequestCurrentPresentationsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RequestCurrentPresentationsRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RequestCurrentPresentations>>
            for RequestCurrentPresentations
        {
            type Value = ::planus::Offset<RequestCurrentPresentations>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RequestCurrentPresentations>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RequestCurrentPresentationsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RequestCurrentPresentationsRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `DismissPresentation` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DismissPresentation` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:944`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DismissPresentation {
            /// The field `client_token` in the table `DismissPresentation`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `DismissPresentation`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `presentation_id` in the table `DismissPresentation`
            pub presentation_id: ::planus::alloc::string::String,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DismissPresentation {
            fn default() -> Self {
                Self {
                    client_token: ::core::default::Default::default(),
                    auth_token: ::core::default::Default::default(),
                    presentation_id: ::core::default::Default::default(),
                }
            }
        }

        impl DismissPresentation {
            /// Creates a [DismissPresentationBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DismissPresentationBuilder<()> {
                DismissPresentationBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_presentation_id: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_presentation_id = field_presentation_id.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<str>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_presentation_id);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DismissPresentation>> for DismissPresentation {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DismissPresentation> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DismissPresentation>> for DismissPresentation {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DismissPresentation>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DismissPresentation> for DismissPresentation {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DismissPresentation> {
                DismissPresentation::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.presentation_id,
                )
            }
        }

        /// Builder for serializing an instance of the [DismissPresentation] type.
        ///
        /// Can be created using the [DismissPresentation::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DismissPresentationBuilder<State>(State);

        impl DismissPresentationBuilder<()> {
            /// Setter for the [`client_token` field](DismissPresentation#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> DismissPresentationBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                DismissPresentationBuilder((value,))
            }
        }

        impl<T0> DismissPresentationBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](DismissPresentation#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> DismissPresentationBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                DismissPresentationBuilder((v0, value))
            }
        }

        impl<T0, T1> DismissPresentationBuilder<(T0, T1)> {
            /// Setter for the [`presentation_id` field](DismissPresentation#structfield.presentation_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn presentation_id<T2>(self, value: T2) -> DismissPresentationBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0, v1) = self.0;
                DismissPresentationBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> DismissPresentationBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DismissPresentation].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DismissPresentation>
            where
                Self: ::planus::WriteAsOffset<DismissPresentation>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<DismissPresentation>>
            for DismissPresentationBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<DismissPresentation>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DismissPresentation> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<DismissPresentation>>
            for DismissPresentationBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<DismissPresentation>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DismissPresentation>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<DismissPresentation>
            for DismissPresentationBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DismissPresentation> {
                let (v0, v1, v2) = &self.0;
                DismissPresentation::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [DismissPresentation].
        #[derive(Copy, Clone)]
        pub struct DismissPresentationRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DismissPresentationRef<'a> {
            /// Getter for the [`client_token` field](DismissPresentation#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0
                    .access_required(0, "DismissPresentation", "client_token")
            }

            /// Getter for the [`auth_token` field](DismissPresentation#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0
                    .access_required(1, "DismissPresentation", "auth_token")
            }

            /// Getter for the [`presentation_id` field](DismissPresentation#structfield.presentation_id).
            #[inline]
            pub fn presentation_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0
                    .access_required(2, "DismissPresentation", "presentation_id")
            }
        }

        impl<'a> ::core::fmt::Debug for DismissPresentationRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DismissPresentationRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("presentation_id", &self.presentation_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DismissPresentationRef<'a>> for DismissPresentation {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DismissPresentationRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    presentation_id: ::core::convert::Into::into(value.presentation_id()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DismissPresentationRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DismissPresentationRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DismissPresentationRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DismissPresentation>> for DismissPresentation {
            type Value = ::planus::Offset<DismissPresentation>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DismissPresentation>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DismissPresentationRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DismissPresentationRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `SetClientAttribute` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `SetClientAttribute` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:950`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct SetClientAttribute {
            /// The field `client_token` in the table `SetClientAttribute`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `auth_token` in the table `SetClientAttribute`
            pub auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
            /// The field `key` in the table `SetClientAttribute`
            pub key: ::planus::alloc::boxed::Box<self::Symbol>,
            /// The field `value` in the table `SetClientAttribute`
            pub value: ::core::option::Option<::planus::alloc::boxed::Box<self::VarBytes>>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for SetClientAttribute {
            fn default() -> Self {
                Self {
                    client_token: ::core::default::Default::default(),
                    auth_token: ::core::default::Default::default(),
                    key: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                }
            }
        }

        impl SetClientAttribute {
            /// Creates a [SetClientAttributeBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> SetClientAttributeBuilder<()> {
                SetClientAttributeBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
                field_key: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
                field_value: impl ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_key = field_key.prepare(builder);
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(2);
                if prepared_value.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::VarBytes>>(3);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_auth_token);
                        object_writer.write::<_, _, 4>(&prepared_key);
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            object_writer.write::<_, _, 4>(&prepared_value);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<SetClientAttribute>> for SetClientAttribute {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SetClientAttribute> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<SetClientAttribute>> for SetClientAttribute {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SetClientAttribute>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<SetClientAttribute> for SetClientAttribute {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SetClientAttribute> {
                SetClientAttribute::create(
                    builder,
                    &self.client_token,
                    &self.auth_token,
                    &self.key,
                    &self.value,
                )
            }
        }

        /// Builder for serializing an instance of the [SetClientAttribute] type.
        ///
        /// Can be created using the [SetClientAttribute::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct SetClientAttributeBuilder<State>(State);

        impl SetClientAttributeBuilder<()> {
            /// Setter for the [`client_token` field](SetClientAttribute#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> SetClientAttributeBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                SetClientAttributeBuilder((value,))
            }
        }

        impl<T0> SetClientAttributeBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](SetClientAttribute#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> SetClientAttributeBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                SetClientAttributeBuilder((v0, value))
            }
        }

        impl<T0, T1> SetClientAttributeBuilder<(T0, T1)> {
            /// Setter for the [`key` field](SetClientAttribute#structfield.key).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn key<T2>(self, value: T2) -> SetClientAttributeBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0, v1) = self.0;
                SetClientAttributeBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> SetClientAttributeBuilder<(T0, T1, T2)> {
            /// Setter for the [`value` field](SetClientAttribute#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T3>(self, value: T3) -> SetClientAttributeBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
            {
                let (v0, v1, v2) = self.0;
                SetClientAttributeBuilder((v0, v1, v2, value))
            }

            /// Sets the [`value` field](SetClientAttribute#structfield.value) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value_as_null(self) -> SetClientAttributeBuilder<(T0, T1, T2, ())> {
                self.value(())
            }
        }

        impl<T0, T1, T2, T3> SetClientAttributeBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetClientAttribute].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SetClientAttribute>
            where
                Self: ::planus::WriteAsOffset<SetClientAttribute>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAs<::planus::Offset<SetClientAttribute>>
            for SetClientAttributeBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<SetClientAttribute>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SetClientAttribute> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOptional<::planus::Offset<SetClientAttribute>>
            for SetClientAttributeBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<SetClientAttribute>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SetClientAttribute>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOffset<SetClientAttribute>
            for SetClientAttributeBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SetClientAttribute> {
                let (v0, v1, v2, v3) = &self.0;
                SetClientAttribute::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [SetClientAttribute].
        #[derive(Copy, Clone)]
        pub struct SetClientAttributeRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> SetClientAttributeRef<'a> {
            /// Getter for the [`client_token` field](SetClientAttribute#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0
                    .access_required(0, "SetClientAttribute", "client_token")
            }

            /// Getter for the [`auth_token` field](SetClientAttribute#structfield.auth_token).
            #[inline]
            pub fn auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0
                    .access_required(1, "SetClientAttribute", "auth_token")
            }

            /// Getter for the [`key` field](SetClientAttribute#structfield.key).
            #[inline]
            pub fn key(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(2, "SetClientAttribute", "key")
            }

            /// Getter for the [`value` field](SetClientAttribute#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<::core::option::Option<self::VarBytesRef<'a>>> {
                self.0.access(3, "SetClientAttribute", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for SetClientAttributeRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("SetClientAttributeRef");
                f.field("client_token", &self.client_token());
                f.field("auth_token", &self.auth_token());
                f.field("key", &self.key());
                if let ::core::option::Option::Some(field_value) = self.value().transpose() {
                    f.field("value", &field_value);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<SetClientAttributeRef<'a>> for SetClientAttribute {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: SetClientAttributeRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.auth_token()?)?,
                    ),
                    key: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.key()?,
                    )?),
                    value: if let ::core::option::Option::Some(value) = value.value()? {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for SetClientAttributeRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for SetClientAttributeRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[SetClientAttributeRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<SetClientAttribute>> for SetClientAttribute {
            type Value = ::planus::Offset<SetClientAttribute>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<SetClientAttribute>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for SetClientAttributeRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[SetClientAttributeRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Detach` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Detach` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:957`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Detach {
            /// The field `client_token` in the table `Detach`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `disconnected` in the table `Detach`
            pub disconnected: bool,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Detach {
            fn default() -> Self {
                Self {
                    client_token: ::core::default::Default::default(),
                    disconnected: false,
                }
            }
        }

        impl Detach {
            /// Creates a [DetachBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DetachBuilder<()> {
                DetachBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_disconnected: impl ::planus::WriteAsDefault<bool, bool>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_disconnected = field_disconnected.prepare(builder, &false);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                if prepared_disconnected.is_some() {
                    table_writer.write_entry::<bool>(1);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        if let ::core::option::Option::Some(prepared_disconnected) =
                            prepared_disconnected
                        {
                            object_writer.write::<_, _, 1>(&prepared_disconnected);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Detach>> for Detach {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Detach> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Detach>> for Detach {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Detach>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Detach> for Detach {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Detach> {
                Detach::create(builder, &self.client_token, self.disconnected)
            }
        }

        /// Builder for serializing an instance of the [Detach] type.
        ///
        /// Can be created using the [Detach::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DetachBuilder<State>(State);

        impl DetachBuilder<()> {
            /// Setter for the [`client_token` field](Detach#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> DetachBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                DetachBuilder((value,))
            }
        }

        impl<T0> DetachBuilder<(T0,)> {
            /// Setter for the [`disconnected` field](Detach#structfield.disconnected).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn disconnected<T1>(self, value: T1) -> DetachBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsDefault<bool, bool>,
            {
                let (v0,) = self.0;
                DetachBuilder((v0, value))
            }

            /// Sets the [`disconnected` field](Detach#structfield.disconnected) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn disconnected_as_default(self) -> DetachBuilder<(T0, ::planus::DefaultValue)> {
                self.disconnected(::planus::DefaultValue)
            }
        }

        impl<T0, T1> DetachBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Detach].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Detach>
            where
                Self: ::planus::WriteAsOffset<Detach>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAs<::planus::Offset<Detach>> for DetachBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<Detach>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Detach> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOptional<::planus::Offset<Detach>> for DetachBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<Detach>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Detach>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAsDefault<bool, bool>,
        > ::planus::WriteAsOffset<Detach> for DetachBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Detach> {
                let (v0, v1) = &self.0;
                Detach::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [Detach].
        #[derive(Copy, Clone)]
        pub struct DetachRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DetachRef<'a> {
            /// Getter for the [`client_token` field](Detach#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "Detach", "client_token")
            }

            /// Getter for the [`disconnected` field](Detach#structfield.disconnected).
            #[inline]
            pub fn disconnected(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0.access(1, "Detach", "disconnected")?.unwrap_or(false),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for DetachRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DetachRef");
                f.field("client_token", &self.client_token());
                f.field("disconnected", &self.disconnected());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DetachRef<'a>> for Detach {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DetachRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    disconnected: ::core::convert::TryInto::try_into(value.disconnected()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DetachRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DetachRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[DetachRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Detach>> for Detach {
            type Value = ::planus::Offset<Detach>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Detach>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DetachRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DetachRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `HostClientToDaemonMessage` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostClientToDaemonMessage` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:962`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostClientToDaemonMessage {
            /// The field `message` in the table `HostClientToDaemonMessage`
            pub message: self::HostClientToDaemonMessageUnion,
        }

        impl HostClientToDaemonMessage {
            /// Creates a [HostClientToDaemonMessageBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostClientToDaemonMessageBuilder<()> {
                HostClientToDaemonMessageBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAsUnion<self::HostClientToDaemonMessageUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer
                    .write_entry::<::planus::Offset<self::HostClientToDaemonMessageUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message.offset());
                        object_writer.write::<_, _, 1>(&prepared_message.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostClientToDaemonMessage>> for HostClientToDaemonMessage {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostClientToDaemonMessage> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostClientToDaemonMessage>>
            for HostClientToDaemonMessage
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostClientToDaemonMessage>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostClientToDaemonMessage> for HostClientToDaemonMessage {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostClientToDaemonMessage> {
                HostClientToDaemonMessage::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [HostClientToDaemonMessage] type.
        ///
        /// Can be created using the [HostClientToDaemonMessage::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostClientToDaemonMessageBuilder<State>(State);

        impl HostClientToDaemonMessageBuilder<()> {
            /// Setter for the [`message` field](HostClientToDaemonMessage#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> HostClientToDaemonMessageBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::HostClientToDaemonMessageUnion>,
            {
                HostClientToDaemonMessageBuilder((value,))
            }
        }

        impl<T0> HostClientToDaemonMessageBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostClientToDaemonMessage].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostClientToDaemonMessage>
            where
                Self: ::planus::WriteAsOffset<HostClientToDaemonMessage>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HostClientToDaemonMessageUnion>>
            ::planus::WriteAs<::planus::Offset<HostClientToDaemonMessage>>
            for HostClientToDaemonMessageBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostClientToDaemonMessage>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostClientToDaemonMessage> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HostClientToDaemonMessageUnion>>
            ::planus::WriteAsOptional<::planus::Offset<HostClientToDaemonMessage>>
            for HostClientToDaemonMessageBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostClientToDaemonMessage>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostClientToDaemonMessage>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::HostClientToDaemonMessageUnion>>
            ::planus::WriteAsOffset<HostClientToDaemonMessage>
            for HostClientToDaemonMessageBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostClientToDaemonMessage> {
                let (v0,) = &self.0;
                HostClientToDaemonMessage::create(builder, v0)
            }
        }

        /// Reference to a deserialized [HostClientToDaemonMessage].
        #[derive(Copy, Clone)]
        pub struct HostClientToDaemonMessageRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostClientToDaemonMessageRef<'a> {
            /// Getter for the [`message` field](HostClientToDaemonMessage#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<self::HostClientToDaemonMessageUnionRef<'a>> {
                self.0
                    .access_union_required(0, "HostClientToDaemonMessage", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for HostClientToDaemonMessageRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostClientToDaemonMessageRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostClientToDaemonMessageRef<'a>> for HostClientToDaemonMessage {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostClientToDaemonMessageRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::TryInto::try_into(value.message()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostClientToDaemonMessageRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostClientToDaemonMessageRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostClientToDaemonMessageRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostClientToDaemonMessage>>
            for HostClientToDaemonMessage
        {
            type Value = ::planus::Offset<HostClientToDaemonMessage>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostClientToDaemonMessage>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostClientToDaemonMessageRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostClientToDaemonMessageRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The union `DaemonToClientReplyUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `DaemonToClientReplyUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:970`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum DaemonToClientReplyUnion {
            /// The variant of type `NewConnection` in the union `DaemonToClientReplyUnion`
            NewConnection(::planus::alloc::boxed::Box<self::NewConnection>),

            /// The variant of type `LoginResult` in the union `DaemonToClientReplyUnion`
            LoginResult(::planus::alloc::boxed::Box<self::LoginResult>),

            /// The variant of type `AttachResult` in the union `DaemonToClientReplyUnion`
            AttachResult(::planus::alloc::boxed::Box<self::AttachResult>),

            /// The variant of type `SysPropValue` in the union `DaemonToClientReplyUnion`
            SysPropValue(::planus::alloc::boxed::Box<self::SysPropValue>),

            /// The variant of type `TaskSubmitted` in the union `DaemonToClientReplyUnion`
            TaskSubmitted(::planus::alloc::boxed::Box<self::TaskSubmitted>),

            /// The variant of type `InputThanks` in the union `DaemonToClientReplyUnion`
            InputThanks(::planus::alloc::boxed::Box<self::InputThanks>),

            /// The variant of type `EvalResult` in the union `DaemonToClientReplyUnion`
            EvalResult(::planus::alloc::boxed::Box<self::EvalResult>),

            /// The variant of type `ThanksPong` in the union `DaemonToClientReplyUnion`
            ThanksPong(::planus::alloc::boxed::Box<self::ThanksPong>),

            /// The variant of type `VerbsReply` in the union `DaemonToClientReplyUnion`
            VerbsReply(::planus::alloc::boxed::Box<self::VerbsReply>),

            /// The variant of type `PropertiesReply` in the union `DaemonToClientReplyUnion`
            PropertiesReply(::planus::alloc::boxed::Box<self::PropertiesReply>),

            /// The variant of type `VerbProgramResponseReply` in the union `DaemonToClientReplyUnion`
            VerbProgramResponseReply(::planus::alloc::boxed::Box<self::VerbProgramResponseReply>),

            /// The variant of type `PropertyValue` in the union `DaemonToClientReplyUnion`
            PropertyValue(::planus::alloc::boxed::Box<self::PropertyValue>),

            /// The variant of type `VerbValue` in the union `DaemonToClientReplyUnion`
            VerbValue(::planus::alloc::boxed::Box<self::VerbValue>),

            /// The variant of type `ResolveResult` in the union `DaemonToClientReplyUnion`
            ResolveResult(::planus::alloc::boxed::Box<self::ResolveResult>),

            /// The variant of type `HistoryResponse` in the union `DaemonToClientReplyUnion`
            HistoryResponse(::planus::alloc::boxed::Box<self::HistoryResponse>),

            /// The variant of type `CurrentPresentations` in the union `DaemonToClientReplyUnion`
            CurrentPresentations(::planus::alloc::boxed::Box<self::CurrentPresentations>),

            /// The variant of type `PresentationDismissed` in the union `DaemonToClientReplyUnion`
            PresentationDismissed(::planus::alloc::boxed::Box<self::PresentationDismissed>),

            /// The variant of type `ClientAttributeSet` in the union `DaemonToClientReplyUnion`
            ClientAttributeSet(::planus::alloc::boxed::Box<self::ClientAttributeSet>),

            /// The variant of type `Disconnected` in the union `DaemonToClientReplyUnion`
            Disconnected(::planus::alloc::boxed::Box<self::Disconnected>),
        }

        impl DaemonToClientReplyUnion {
            /// Creates a [DaemonToClientReplyUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToClientReplyUnionBuilder<::planus::Uninitialized> {
                DaemonToClientReplyUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_new_connection(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::NewConnection>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_login_result(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::LoginResult>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_attach_result(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::AttachResult>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_sys_prop_value(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::SysPropValue>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_task_submitted(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::TaskSubmitted>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_input_thanks(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::InputThanks>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_eval_result(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::EvalResult>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_thanks_pong(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ThanksPong>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verbs_reply(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbsReply>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_properties_reply(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertiesReply>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_program_response_reply(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbProgramResponseReply>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_property_value(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PropertyValue>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_verb_value(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::VerbValue>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_resolve_result(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ResolveResult>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(14, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_history_response(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HistoryResponse>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(15, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_current_presentations(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::CurrentPresentations>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(16, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_presentation_dismissed(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PresentationDismissed>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(17, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_client_attribute_set(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ClientAttributeSet>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(18, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_disconnected(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Disconnected>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(19, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<DaemonToClientReplyUnion> for DaemonToClientReplyUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::NewConnection(value) => Self::create_new_connection(builder, value),
                    Self::LoginResult(value) => Self::create_login_result(builder, value),
                    Self::AttachResult(value) => Self::create_attach_result(builder, value),
                    Self::SysPropValue(value) => Self::create_sys_prop_value(builder, value),
                    Self::TaskSubmitted(value) => Self::create_task_submitted(builder, value),
                    Self::InputThanks(value) => Self::create_input_thanks(builder, value),
                    Self::EvalResult(value) => Self::create_eval_result(builder, value),
                    Self::ThanksPong(value) => Self::create_thanks_pong(builder, value),
                    Self::VerbsReply(value) => Self::create_verbs_reply(builder, value),
                    Self::PropertiesReply(value) => Self::create_properties_reply(builder, value),
                    Self::VerbProgramResponseReply(value) => {
                        Self::create_verb_program_response_reply(builder, value)
                    }
                    Self::PropertyValue(value) => Self::create_property_value(builder, value),
                    Self::VerbValue(value) => Self::create_verb_value(builder, value),
                    Self::ResolveResult(value) => Self::create_resolve_result(builder, value),
                    Self::HistoryResponse(value) => Self::create_history_response(builder, value),
                    Self::CurrentPresentations(value) => {
                        Self::create_current_presentations(builder, value)
                    }
                    Self::PresentationDismissed(value) => {
                        Self::create_presentation_dismissed(builder, value)
                    }
                    Self::ClientAttributeSet(value) => {
                        Self::create_client_attribute_set(builder, value)
                    }
                    Self::Disconnected(value) => Self::create_disconnected(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion> for DaemonToClientReplyUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [DaemonToClientReplyUnion] type.
        ///
        /// Can be created using the [DaemonToClientReplyUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToClientReplyUnionBuilder<T>(T);

        impl DaemonToClientReplyUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`NewConnection` variant](DaemonToClientReplyUnion#variant.NewConnection).
            #[inline]
            pub fn new_connection<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::NewConnection>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`LoginResult` variant](DaemonToClientReplyUnion#variant.LoginResult).
            #[inline]
            pub fn login_result<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::LoginResult>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`AttachResult` variant](DaemonToClientReplyUnion#variant.AttachResult).
            #[inline]
            pub fn attach_result<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::AttachResult>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`SysPropValue` variant](DaemonToClientReplyUnion#variant.SysPropValue).
            #[inline]
            pub fn sys_prop_value<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::SysPropValue>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`TaskSubmitted` variant](DaemonToClientReplyUnion#variant.TaskSubmitted).
            #[inline]
            pub fn task_submitted<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::TaskSubmitted>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`InputThanks` variant](DaemonToClientReplyUnion#variant.InputThanks).
            #[inline]
            pub fn input_thanks<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::InputThanks>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`EvalResult` variant](DaemonToClientReplyUnion#variant.EvalResult).
            #[inline]
            pub fn eval_result<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<self::EvalResult>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ThanksPong` variant](DaemonToClientReplyUnion#variant.ThanksPong).
            #[inline]
            pub fn thanks_pong<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<self::ThanksPong>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbsReply` variant](DaemonToClientReplyUnion#variant.VerbsReply).
            #[inline]
            pub fn verbs_reply<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbsReply>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertiesReply` variant](DaemonToClientReplyUnion#variant.PropertiesReply).
            #[inline]
            pub fn properties_reply<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertiesReply>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbProgramResponseReply` variant](DaemonToClientReplyUnion#variant.VerbProgramResponseReply).
            #[inline]
            pub fn verb_program_response_reply<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbProgramResponseReply>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PropertyValue` variant](DaemonToClientReplyUnion#variant.PropertyValue).
            #[inline]
            pub fn property_value<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<self::PropertyValue>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`VerbValue` variant](DaemonToClientReplyUnion#variant.VerbValue).
            #[inline]
            pub fn verb_value<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<self::VerbValue>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ResolveResult` variant](DaemonToClientReplyUnion#variant.ResolveResult).
            #[inline]
            pub fn resolve_result<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<self::ResolveResult>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`HistoryResponse` variant](DaemonToClientReplyUnion#variant.HistoryResponse).
            #[inline]
            pub fn history_response<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<self::HistoryResponse>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`CurrentPresentations` variant](DaemonToClientReplyUnion#variant.CurrentPresentations).
            #[inline]
            pub fn current_presentations<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<16, T>>
            where
                T: ::planus::WriteAsOffset<self::CurrentPresentations>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PresentationDismissed` variant](DaemonToClientReplyUnion#variant.PresentationDismissed).
            #[inline]
            pub fn presentation_dismissed<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<17, T>>
            where
                T: ::planus::WriteAsOffset<self::PresentationDismissed>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ClientAttributeSet` variant](DaemonToClientReplyUnion#variant.ClientAttributeSet).
            #[inline]
            pub fn client_attribute_set<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<18, T>>
            where
                T: ::planus::WriteAsOffset<self::ClientAttributeSet>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Disconnected` variant](DaemonToClientReplyUnion#variant.Disconnected).
            #[inline]
            pub fn disconnected<T>(
                self,
                value: T,
            ) -> DaemonToClientReplyUnionBuilder<::planus::Initialized<19, T>>
            where
                T: ::planus::WriteAsOffset<self::Disconnected>,
            {
                DaemonToClientReplyUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> DaemonToClientReplyUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [DaemonToClientReplyUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion>
            where
                Self: ::planus::WriteAsUnion<DaemonToClientReplyUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::NewConnection>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::NewConnection>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::LoginResult>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::LoginResult>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::AttachResult>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::AttachResult>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::SysPropValue>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::SysPropValue>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskSubmitted>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskSubmitted>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::InputThanks>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::InputThanks>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::EvalResult>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::EvalResult>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::ThanksPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::ThanksPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbsReply>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<9, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbsReply>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertiesReply>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<10, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertiesReply>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbProgramResponseReply>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(11, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<11, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbProgramResponseReply>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyValue>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(12, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<12, T>>
        where
            T: ::planus::WriteAsOffset<self::PropertyValue>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbValue>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(13, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<13, T>>
        where
            T: ::planus::WriteAsOffset<self::VerbValue>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<14, T>>
        where
            T: ::planus::WriteAsOffset<self::ResolveResult>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(14, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<14, T>>
        where
            T: ::planus::WriteAsOffset<self::ResolveResult>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<15, T>>
        where
            T: ::planus::WriteAsOffset<self::HistoryResponse>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(15, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<15, T>>
        where
            T: ::planus::WriteAsOffset<self::HistoryResponse>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<16, T>>
        where
            T: ::planus::WriteAsOffset<self::CurrentPresentations>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(16, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<16, T>>
        where
            T: ::planus::WriteAsOffset<self::CurrentPresentations>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<17, T>>
        where
            T: ::planus::WriteAsOffset<self::PresentationDismissed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(17, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<17, T>>
        where
            T: ::planus::WriteAsOffset<self::PresentationDismissed>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<18, T>>
        where
            T: ::planus::WriteAsOffset<self::ClientAttributeSet>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(18, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<18, T>>
        where
            T: ::planus::WriteAsOffset<self::ClientAttributeSet>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<19, T>>
        where
            T: ::planus::WriteAsOffset<self::Disconnected>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToClientReplyUnion> {
                ::planus::UnionOffset::new(19, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToClientReplyUnion>
            for DaemonToClientReplyUnionBuilder<::planus::Initialized<19, T>>
        where
            T: ::planus::WriteAsOffset<self::Disconnected>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToClientReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [DaemonToClientReplyUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum DaemonToClientReplyUnionRef<'a> {
            NewConnection(self::NewConnectionRef<'a>),
            LoginResult(self::LoginResultRef<'a>),
            AttachResult(self::AttachResultRef<'a>),
            SysPropValue(self::SysPropValueRef<'a>),
            TaskSubmitted(self::TaskSubmittedRef<'a>),
            InputThanks(self::InputThanksRef<'a>),
            EvalResult(self::EvalResultRef<'a>),
            ThanksPong(self::ThanksPongRef<'a>),
            VerbsReply(self::VerbsReplyRef<'a>),
            PropertiesReply(self::PropertiesReplyRef<'a>),
            VerbProgramResponseReply(self::VerbProgramResponseReplyRef<'a>),
            PropertyValue(self::PropertyValueRef<'a>),
            VerbValue(self::VerbValueRef<'a>),
            ResolveResult(self::ResolveResultRef<'a>),
            HistoryResponse(self::HistoryResponseRef<'a>),
            CurrentPresentations(self::CurrentPresentationsRef<'a>),
            PresentationDismissed(self::PresentationDismissedRef<'a>),
            ClientAttributeSet(self::ClientAttributeSetRef<'a>),
            Disconnected(self::DisconnectedRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<DaemonToClientReplyUnionRef<'a>> for DaemonToClientReplyUnion {
            type Error = ::planus::Error;

            fn try_from(value: DaemonToClientReplyUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    DaemonToClientReplyUnionRef::NewConnection(value) => {
                        Self::NewConnection(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::LoginResult(value) => {
                        Self::LoginResult(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::AttachResult(value) => {
                        Self::AttachResult(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::SysPropValue(value) => {
                        Self::SysPropValue(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::TaskSubmitted(value) => {
                        Self::TaskSubmitted(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::InputThanks(value) => {
                        Self::InputThanks(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::EvalResult(value) => {
                        Self::EvalResult(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::ThanksPong(value) => {
                        Self::ThanksPong(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::VerbsReply(value) => {
                        Self::VerbsReply(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::PropertiesReply(value) => {
                        Self::PropertiesReply(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::VerbProgramResponseReply(value) => {
                        Self::VerbProgramResponseReply(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::PropertyValue(value) => {
                        Self::PropertyValue(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::VerbValue(value) => {
                        Self::VerbValue(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::ResolveResult(value) => {
                        Self::ResolveResult(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::HistoryResponse(value) => {
                        Self::HistoryResponse(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::CurrentPresentations(value) => {
                        Self::CurrentPresentations(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::PresentationDismissed(value) => {
                        Self::PresentationDismissed(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::ClientAttributeSet(value) => {
                        Self::ClientAttributeSet(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToClientReplyUnionRef::Disconnected(value) => {
                        Self::Disconnected(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for DaemonToClientReplyUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::NewConnection(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::LoginResult(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::AttachResult(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::SysPropValue(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::TaskSubmitted(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    6 => ::core::result::Result::Ok(Self::InputThanks(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    7 => ::core::result::Result::Ok(Self::EvalResult(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    8 => ::core::result::Result::Ok(Self::ThanksPong(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    9 => ::core::result::Result::Ok(Self::VerbsReply(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    10 => ::core::result::Result::Ok(Self::PropertiesReply(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    11 => ::core::result::Result::Ok(Self::VerbProgramResponseReply(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    12 => ::core::result::Result::Ok(Self::PropertyValue(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    13 => ::core::result::Result::Ok(Self::VerbValue(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    14 => ::core::result::Result::Ok(Self::ResolveResult(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    15 => ::core::result::Result::Ok(Self::HistoryResponse(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    16 => ::core::result::Result::Ok(Self::CurrentPresentations(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    17 => ::core::result::Result::Ok(Self::PresentationDismissed(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    18 => ::core::result::Result::Ok(Self::ClientAttributeSet(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    19 => ::core::result::Result::Ok(Self::Disconnected(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for DaemonToClientReplyUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[DaemonToClientReplyUnionRef]";
        }

        /// The table `NewConnection` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `NewConnection` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:992`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct NewConnection {
            /// The field `client_token` in the table `NewConnection`
            pub client_token: ::planus::alloc::boxed::Box<self::ClientToken>,
            /// The field `connection_obj` in the table `NewConnection`
            pub connection_obj: ::planus::alloc::boxed::Box<self::Obj>,
        }

        impl NewConnection {
            /// Creates a [NewConnectionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> NewConnectionBuilder<()> {
                NewConnectionBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_token: impl ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
                field_connection_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_connection_obj = field_connection_obj.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_token);
                        object_writer.write::<_, _, 4>(&prepared_connection_obj);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NewConnection>> for NewConnection {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NewConnection> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NewConnection>> for NewConnection {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NewConnection>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NewConnection> for NewConnection {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NewConnection> {
                NewConnection::create(builder, &self.client_token, &self.connection_obj)
            }
        }

        /// Builder for serializing an instance of the [NewConnection] type.
        ///
        /// Can be created using the [NewConnection::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct NewConnectionBuilder<State>(State);

        impl NewConnectionBuilder<()> {
            /// Setter for the [`client_token` field](NewConnection#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T0>(self, value: T0) -> NewConnectionBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            {
                NewConnectionBuilder((value,))
            }
        }

        impl<T0> NewConnectionBuilder<(T0,)> {
            /// Setter for the [`connection_obj` field](NewConnection#structfield.connection_obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connection_obj<T1>(self, value: T1) -> NewConnectionBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0,) = self.0;
                NewConnectionBuilder((v0, value))
            }
        }

        impl<T0, T1> NewConnectionBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NewConnection].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<NewConnection>
            where
                Self: ::planus::WriteAsOffset<NewConnection>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAs<::planus::Offset<NewConnection>> for NewConnectionBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<NewConnection>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NewConnection> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOptional<::planus::Offset<NewConnection>>
            for NewConnectionBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<NewConnection>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NewConnection>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::ClientToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOffset<NewConnection> for NewConnectionBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<NewConnection> {
                let (v0, v1) = &self.0;
                NewConnection::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [NewConnection].
        #[derive(Copy, Clone)]
        pub struct NewConnectionRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> NewConnectionRef<'a> {
            /// Getter for the [`client_token` field](NewConnection#structfield.client_token).
            #[inline]
            pub fn client_token(&self) -> ::planus::Result<self::ClientTokenRef<'a>> {
                self.0.access_required(0, "NewConnection", "client_token")
            }

            /// Getter for the [`connection_obj` field](NewConnection#structfield.connection_obj).
            #[inline]
            pub fn connection_obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(1, "NewConnection", "connection_obj")
            }
        }

        impl<'a> ::core::fmt::Debug for NewConnectionRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("NewConnectionRef");
                f.field("client_token", &self.client_token());
                f.field("connection_obj", &self.connection_obj());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<NewConnectionRef<'a>> for NewConnection {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: NewConnectionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.client_token()?)?,
                    ),
                    connection_obj: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.connection_obj()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for NewConnectionRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for NewConnectionRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[NewConnectionRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<NewConnection>> for NewConnection {
            type Value = ::planus::Offset<NewConnection>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<NewConnection>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for NewConnectionRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[NewConnectionRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `LoginResult` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `LoginResult` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:997`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct LoginResult {
            /// The field `success` in the table `LoginResult`
            pub success: bool,
            /// The field `auth_token` in the table `LoginResult`
            pub auth_token: ::core::option::Option<::planus::alloc::boxed::Box<self::AuthToken>>,
            /// The field `connect_type` in the table `LoginResult`
            pub connect_type: self::ConnectType,
            /// The field `player` in the table `LoginResult`
            pub player: ::core::option::Option<::planus::alloc::boxed::Box<self::Obj>>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for LoginResult {
            fn default() -> Self {
                Self {
                    success: false,
                    auth_token: ::core::default::Default::default(),
                    connect_type: self::ConnectType::Connected,
                    player: ::core::default::Default::default(),
                }
            }
        }

        impl LoginResult {
            /// Creates a [LoginResultBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> LoginResultBuilder<()> {
                LoginResultBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_success: impl ::planus::WriteAsDefault<bool, bool>,
                field_auth_token: impl ::planus::WriteAsOptional<::planus::Offset<self::AuthToken>>,
                field_connect_type: impl ::planus::WriteAsDefault<self::ConnectType, self::ConnectType>,
                field_player: impl ::planus::WriteAsOptional<::planus::Offset<self::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_success = field_success.prepare(builder, &false);
                let prepared_auth_token = field_auth_token.prepare(builder);
                let prepared_connect_type =
                    field_connect_type.prepare(builder, &self::ConnectType::Connected);
                let prepared_player = field_player.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<12> =
                    ::core::default::Default::default();
                if prepared_auth_token.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);
                }
                if prepared_player.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::Obj>>(3);
                }
                if prepared_success.is_some() {
                    table_writer.write_entry::<bool>(0);
                }
                if prepared_connect_type.is_some() {
                    table_writer.write_entry::<self::ConnectType>(2);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_auth_token) =
                            prepared_auth_token
                        {
                            object_writer.write::<_, _, 4>(&prepared_auth_token);
                        }
                        if let ::core::option::Option::Some(prepared_player) = prepared_player {
                            object_writer.write::<_, _, 4>(&prepared_player);
                        }
                        if let ::core::option::Option::Some(prepared_success) = prepared_success {
                            object_writer.write::<_, _, 1>(&prepared_success);
                        }
                        if let ::core::option::Option::Some(prepared_connect_type) =
                            prepared_connect_type
                        {
                            object_writer.write::<_, _, 1>(&prepared_connect_type);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<LoginResult>> for LoginResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LoginResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<LoginResult>> for LoginResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<LoginResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<LoginResult> for LoginResult {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LoginResult> {
                LoginResult::create(
                    builder,
                    self.success,
                    &self.auth_token,
                    self.connect_type,
                    &self.player,
                )
            }
        }

        /// Builder for serializing an instance of the [LoginResult] type.
        ///
        /// Can be created using the [LoginResult::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct LoginResultBuilder<State>(State);

        impl LoginResultBuilder<()> {
            /// Setter for the [`success` field](LoginResult#structfield.success).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn success<T0>(self, value: T0) -> LoginResultBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<bool, bool>,
            {
                LoginResultBuilder((value,))
            }

            /// Sets the [`success` field](LoginResult#structfield.success) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn success_as_default(self) -> LoginResultBuilder<(::planus::DefaultValue,)> {
                self.success(::planus::DefaultValue)
            }
        }

        impl<T0> LoginResultBuilder<(T0,)> {
            /// Setter for the [`auth_token` field](LoginResult#structfield.auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token<T1>(self, value: T1) -> LoginResultBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsOptional<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                LoginResultBuilder((v0, value))
            }

            /// Sets the [`auth_token` field](LoginResult#structfield.auth_token) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn auth_token_as_null(self) -> LoginResultBuilder<(T0, ())> {
                self.auth_token(())
            }
        }

        impl<T0, T1> LoginResultBuilder<(T0, T1)> {
            /// Setter for the [`connect_type` field](LoginResult#structfield.connect_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connect_type<T2>(self, value: T2) -> LoginResultBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsDefault<self::ConnectType, self::ConnectType>,
            {
                let (v0, v1) = self.0;
                LoginResultBuilder((v0, v1, value))
            }

            /// Sets the [`connect_type` field](LoginResult#structfield.connect_type) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connect_type_as_default(
                self,
            ) -> LoginResultBuilder<(T0, T1, ::planus::DefaultValue)> {
                self.connect_type(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2> LoginResultBuilder<(T0, T1, T2)> {
            /// Setter for the [`player` field](LoginResult#structfield.player).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn player<T3>(self, value: T3) -> LoginResultBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAsOptional<::planus::Offset<self::Obj>>,
            {
                let (v0, v1, v2) = self.0;
                LoginResultBuilder((v0, v1, v2, value))
            }

            /// Sets the [`player` field](LoginResult#structfield.player) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn player_as_null(self) -> LoginResultBuilder<(T0, T1, T2, ())> {
                self.player(())
            }
        }

        impl<T0, T1, T2, T3> LoginResultBuilder<(T0, T1, T2, T3)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [LoginResult].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<LoginResult>
            where
                Self: ::planus::WriteAsOffset<LoginResult>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<bool, bool>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAsDefault<self::ConnectType, self::ConnectType>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::Obj>>,
        > ::planus::WriteAs<::planus::Offset<LoginResult>>
            for LoginResultBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<LoginResult>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LoginResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<bool, bool>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAsDefault<self::ConnectType, self::ConnectType>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOptional<::planus::Offset<LoginResult>>
            for LoginResultBuilder<(T0, T1, T2, T3)>
        {
            type Prepared = ::planus::Offset<LoginResult>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<LoginResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<bool, bool>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::AuthToken>>,
            T2: ::planus::WriteAsDefault<self::ConnectType, self::ConnectType>,
            T3: ::planus::WriteAsOptional<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOffset<LoginResult> for LoginResultBuilder<(T0, T1, T2, T3)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<LoginResult> {
                let (v0, v1, v2, v3) = &self.0;
                LoginResult::create(builder, v0, v1, v2, v3)
            }
        }

        /// Reference to a deserialized [LoginResult].
        #[derive(Copy, Clone)]
        pub struct LoginResultRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> LoginResultRef<'a> {
            /// Getter for the [`success` field](LoginResult#structfield.success).
            #[inline]
            pub fn success(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0.access(0, "LoginResult", "success")?.unwrap_or(false),
                )
            }

            /// Getter for the [`auth_token` field](LoginResult#structfield.auth_token).
            #[inline]
            pub fn auth_token(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::AuthTokenRef<'a>>> {
                self.0.access(1, "LoginResult", "auth_token")
            }

            /// Getter for the [`connect_type` field](LoginResult#structfield.connect_type).
            #[inline]
            pub fn connect_type(&self) -> ::planus::Result<self::ConnectType> {
                ::core::result::Result::Ok(
                    self.0
                        .access(2, "LoginResult", "connect_type")?
                        .unwrap_or(self::ConnectType::Connected),
                )
            }

            /// Getter for the [`player` field](LoginResult#structfield.player).
            #[inline]
            pub fn player(&self) -> ::planus::Result<::core::option::Option<self::ObjRef<'a>>> {
                self.0.access(3, "LoginResult", "player")
            }
        }

        impl<'a> ::core::fmt::Debug for LoginResultRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("LoginResultRef");
                f.field("success", &self.success());
                if let ::core::option::Option::Some(field_auth_token) =
                    self.auth_token().transpose()
                {
                    f.field("auth_token", &field_auth_token);
                }
                f.field("connect_type", &self.connect_type());
                if let ::core::option::Option::Some(field_player) = self.player().transpose() {
                    f.field("player", &field_player);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<LoginResultRef<'a>> for LoginResult {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: LoginResultRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    success: ::core::convert::TryInto::try_into(value.success()?)?,
                    auth_token: if let ::core::option::Option::Some(auth_token) =
                        value.auth_token()?
                    {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(auth_token)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                    connect_type: ::core::convert::TryInto::try_into(value.connect_type()?)?,
                    player: if let ::core::option::Option::Some(player) = value.player()? {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(player)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for LoginResultRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for LoginResultRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[LoginResultRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<LoginResult>> for LoginResult {
            type Value = ::planus::Offset<LoginResult>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<LoginResult>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for LoginResultRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[LoginResultRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `AttachResult` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `AttachResult` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1004`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct AttachResult {
            /// The field `success` in the table `AttachResult`
            pub success: bool,
            /// The field `client_token` in the table `AttachResult`
            pub client_token:
                ::core::option::Option<::planus::alloc::boxed::Box<self::ClientToken>>,
            /// The field `player` in the table `AttachResult`
            pub player: ::core::option::Option<::planus::alloc::boxed::Box<self::Obj>>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for AttachResult {
            fn default() -> Self {
                Self {
                    success: false,
                    client_token: ::core::default::Default::default(),
                    player: ::core::default::Default::default(),
                }
            }
        }

        impl AttachResult {
            /// Creates a [AttachResultBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AttachResultBuilder<()> {
                AttachResultBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_success: impl ::planus::WriteAsDefault<bool, bool>,
                field_client_token: impl ::planus::WriteAsOptional<::planus::Offset<self::ClientToken>>,
                field_player: impl ::planus::WriteAsOptional<::planus::Offset<self::Obj>>,
            ) -> ::planus::Offset<Self> {
                let prepared_success = field_success.prepare(builder, &false);
                let prepared_client_token = field_client_token.prepare(builder);
                let prepared_player = field_player.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                if prepared_client_token.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::ClientToken>>(1);
                }
                if prepared_player.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::Obj>>(2);
                }
                if prepared_success.is_some() {
                    table_writer.write_entry::<bool>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_client_token) =
                            prepared_client_token
                        {
                            object_writer.write::<_, _, 4>(&prepared_client_token);
                        }
                        if let ::core::option::Option::Some(prepared_player) = prepared_player {
                            object_writer.write::<_, _, 4>(&prepared_player);
                        }
                        if let ::core::option::Option::Some(prepared_success) = prepared_success {
                            object_writer.write::<_, _, 1>(&prepared_success);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<AttachResult>> for AttachResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AttachResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<AttachResult>> for AttachResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AttachResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<AttachResult> for AttachResult {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AttachResult> {
                AttachResult::create(builder, self.success, &self.client_token, &self.player)
            }
        }

        /// Builder for serializing an instance of the [AttachResult] type.
        ///
        /// Can be created using the [AttachResult::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AttachResultBuilder<State>(State);

        impl AttachResultBuilder<()> {
            /// Setter for the [`success` field](AttachResult#structfield.success).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn success<T0>(self, value: T0) -> AttachResultBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<bool, bool>,
            {
                AttachResultBuilder((value,))
            }

            /// Sets the [`success` field](AttachResult#structfield.success) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn success_as_default(self) -> AttachResultBuilder<(::planus::DefaultValue,)> {
                self.success(::planus::DefaultValue)
            }
        }

        impl<T0> AttachResultBuilder<(T0,)> {
            /// Setter for the [`client_token` field](AttachResult#structfield.client_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token<T1>(self, value: T1) -> AttachResultBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsOptional<::planus::Offset<self::ClientToken>>,
            {
                let (v0,) = self.0;
                AttachResultBuilder((v0, value))
            }

            /// Sets the [`client_token` field](AttachResult#structfield.client_token) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_token_as_null(self) -> AttachResultBuilder<(T0, ())> {
                self.client_token(())
            }
        }

        impl<T0, T1> AttachResultBuilder<(T0, T1)> {
            /// Setter for the [`player` field](AttachResult#structfield.player).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn player<T2>(self, value: T2) -> AttachResultBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsOptional<::planus::Offset<self::Obj>>,
            {
                let (v0, v1) = self.0;
                AttachResultBuilder((v0, v1, value))
            }

            /// Sets the [`player` field](AttachResult#structfield.player) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn player_as_null(self) -> AttachResultBuilder<(T0, T1, ())> {
                self.player(())
            }
        }

        impl<T0, T1, T2> AttachResultBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AttachResult].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<AttachResult>
            where
                Self: ::planus::WriteAsOffset<AttachResult>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<bool, bool>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::ClientToken>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::Obj>>,
        > ::planus::WriteAs<::planus::Offset<AttachResult>> for AttachResultBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<AttachResult>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AttachResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<bool, bool>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::ClientToken>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOptional<::planus::Offset<AttachResult>>
            for AttachResultBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<AttachResult>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AttachResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<bool, bool>,
            T1: ::planus::WriteAsOptional<::planus::Offset<self::ClientToken>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::Obj>>,
        > ::planus::WriteAsOffset<AttachResult> for AttachResultBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AttachResult> {
                let (v0, v1, v2) = &self.0;
                AttachResult::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [AttachResult].
        #[derive(Copy, Clone)]
        pub struct AttachResultRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AttachResultRef<'a> {
            /// Getter for the [`success` field](AttachResult#structfield.success).
            #[inline]
            pub fn success(&self) -> ::planus::Result<bool> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "AttachResult", "success")?
                        .unwrap_or(false),
                )
            }

            /// Getter for the [`client_token` field](AttachResult#structfield.client_token).
            #[inline]
            pub fn client_token(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::ClientTokenRef<'a>>> {
                self.0.access(1, "AttachResult", "client_token")
            }

            /// Getter for the [`player` field](AttachResult#structfield.player).
            #[inline]
            pub fn player(&self) -> ::planus::Result<::core::option::Option<self::ObjRef<'a>>> {
                self.0.access(2, "AttachResult", "player")
            }
        }

        impl<'a> ::core::fmt::Debug for AttachResultRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AttachResultRef");
                f.field("success", &self.success());
                if let ::core::option::Option::Some(field_client_token) =
                    self.client_token().transpose()
                {
                    f.field("client_token", &field_client_token);
                }
                if let ::core::option::Option::Some(field_player) = self.player().transpose() {
                    f.field("player", &field_player);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AttachResultRef<'a>> for AttachResult {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AttachResultRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    success: ::core::convert::TryInto::try_into(value.success()?)?,
                    client_token: if let ::core::option::Option::Some(client_token) =
                        value.client_token()?
                    {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(client_token)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                    player: if let ::core::option::Option::Some(player) = value.player()? {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(player)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AttachResultRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AttachResultRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[AttachResultRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<AttachResult>> for AttachResult {
            type Value = ::planus::Offset<AttachResult>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<AttachResult>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AttachResultRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AttachResultRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `SysPropValue` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `SysPropValue` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1010`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct SysPropValue {
            /// The field `value` in the table `SysPropValue`
            pub value: ::core::option::Option<::planus::alloc::boxed::Box<self::VarBytes>>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for SysPropValue {
            fn default() -> Self {
                Self {
                    value: ::core::default::Default::default(),
                }
            }
        }

        impl SysPropValue {
            /// Creates a [SysPropValueBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> SysPropValueBuilder<()> {
                SysPropValueBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_value: impl ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
            ) -> ::planus::Offset<Self> {
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_value.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::VarBytes>>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            object_writer.write::<_, _, 4>(&prepared_value);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<SysPropValue>> for SysPropValue {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SysPropValue> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<SysPropValue>> for SysPropValue {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SysPropValue>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<SysPropValue> for SysPropValue {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SysPropValue> {
                SysPropValue::create(builder, &self.value)
            }
        }

        /// Builder for serializing an instance of the [SysPropValue] type.
        ///
        /// Can be created using the [SysPropValue::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct SysPropValueBuilder<State>(State);

        impl SysPropValueBuilder<()> {
            /// Setter for the [`value` field](SysPropValue#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T0>(self, value: T0) -> SysPropValueBuilder<(T0,)>
            where
                T0: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>,
            {
                SysPropValueBuilder((value,))
            }

            /// Sets the [`value` field](SysPropValue#structfield.value) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value_as_null(self) -> SysPropValueBuilder<((),)> {
                self.value(())
            }
        }

        impl<T0> SysPropValueBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SysPropValue].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<SysPropValue>
            where
                Self: ::planus::WriteAsOffset<SysPropValue>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>>
            ::planus::WriteAs<::planus::Offset<SysPropValue>> for SysPropValueBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<SysPropValue>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SysPropValue> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>>
            ::planus::WriteAsOptional<::planus::Offset<SysPropValue>>
            for SysPropValueBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<SysPropValue>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SysPropValue>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsOptional<::planus::Offset<self::VarBytes>>>
            ::planus::WriteAsOffset<SysPropValue> for SysPropValueBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SysPropValue> {
                let (v0,) = &self.0;
                SysPropValue::create(builder, v0)
            }
        }

        /// Reference to a deserialized [SysPropValue].
        #[derive(Copy, Clone)]
        pub struct SysPropValueRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> SysPropValueRef<'a> {
            /// Getter for the [`value` field](SysPropValue#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<::core::option::Option<self::VarBytesRef<'a>>> {
                self.0.access(0, "SysPropValue", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for SysPropValueRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("SysPropValueRef");
                if let ::core::option::Option::Some(field_value) = self.value().transpose() {
                    f.field("value", &field_value);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<SysPropValueRef<'a>> for SysPropValue {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: SysPropValueRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    value: if let ::core::option::Option::Some(value) = value.value()? {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for SysPropValueRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for SysPropValueRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[SysPropValueRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<SysPropValue>> for SysPropValue {
            type Value = ::planus::Offset<SysPropValue>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<SysPropValue>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for SysPropValueRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[SysPropValueRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `TaskSubmitted` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `TaskSubmitted` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1014`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct TaskSubmitted {
            /// The field `task_id` in the table `TaskSubmitted`
            pub task_id: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for TaskSubmitted {
            fn default() -> Self {
                Self { task_id: 0 }
            }
        }

        impl TaskSubmitted {
            /// Creates a [TaskSubmittedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> TaskSubmittedBuilder<()> {
                TaskSubmittedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_task_id: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_task_id = field_task_id.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_task_id.is_some() {
                    table_writer.write_entry::<u64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_task_id) = prepared_task_id {
                            object_writer.write::<_, _, 8>(&prepared_task_id);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TaskSubmitted>> for TaskSubmitted {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskSubmitted> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TaskSubmitted>> for TaskSubmitted {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskSubmitted>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TaskSubmitted> for TaskSubmitted {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskSubmitted> {
                TaskSubmitted::create(builder, self.task_id)
            }
        }

        /// Builder for serializing an instance of the [TaskSubmitted] type.
        ///
        /// Can be created using the [TaskSubmitted::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct TaskSubmittedBuilder<State>(State);

        impl TaskSubmittedBuilder<()> {
            /// Setter for the [`task_id` field](TaskSubmitted#structfield.task_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn task_id<T0>(self, value: T0) -> TaskSubmittedBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                TaskSubmittedBuilder((value,))
            }

            /// Sets the [`task_id` field](TaskSubmitted#structfield.task_id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn task_id_as_default(self) -> TaskSubmittedBuilder<(::planus::DefaultValue,)> {
                self.task_id(::planus::DefaultValue)
            }
        }

        impl<T0> TaskSubmittedBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TaskSubmitted].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskSubmitted>
            where
                Self: ::planus::WriteAsOffset<TaskSubmitted>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAs<::planus::Offset<TaskSubmitted>> for TaskSubmittedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TaskSubmitted>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskSubmitted> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<TaskSubmitted>>
            for TaskSubmittedBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<TaskSubmitted>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskSubmitted>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAsOffset<TaskSubmitted>
            for TaskSubmittedBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskSubmitted> {
                let (v0,) = &self.0;
                TaskSubmitted::create(builder, v0)
            }
        }

        /// Reference to a deserialized [TaskSubmitted].
        #[derive(Copy, Clone)]
        pub struct TaskSubmittedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> TaskSubmittedRef<'a> {
            /// Getter for the [`task_id` field](TaskSubmitted#structfield.task_id).
            #[inline]
            pub fn task_id(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0.access(0, "TaskSubmitted", "task_id")?.unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for TaskSubmittedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("TaskSubmittedRef");
                f.field("task_id", &self.task_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<TaskSubmittedRef<'a>> for TaskSubmitted {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: TaskSubmittedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    task_id: ::core::convert::TryInto::try_into(value.task_id()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for TaskSubmittedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for TaskSubmittedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[TaskSubmittedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<TaskSubmitted>> for TaskSubmitted {
            type Value = ::planus::Offset<TaskSubmitted>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<TaskSubmitted>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for TaskSubmittedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[TaskSubmittedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `InputThanks` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `InputThanks` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1018`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct InputThanks {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for InputThanks {
            fn default() -> Self {
                Self {}
            }
        }

        impl InputThanks {
            /// Creates a [InputThanksBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> InputThanksBuilder<()> {
                InputThanksBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<InputThanks>> for InputThanks {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InputThanks> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<InputThanks>> for InputThanks {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InputThanks>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<InputThanks> for InputThanks {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InputThanks> {
                InputThanks::create(builder)
            }
        }

        /// Builder for serializing an instance of the [InputThanks] type.
        ///
        /// Can be created using the [InputThanks::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct InputThanksBuilder<State>(State);

        impl InputThanksBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [InputThanks].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<InputThanks>
            where
                Self: ::planus::WriteAsOffset<InputThanks>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<InputThanks>> for InputThanksBuilder<()> {
            type Prepared = ::planus::Offset<InputThanks>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InputThanks> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<InputThanks>> for InputThanksBuilder<()> {
            type Prepared = ::planus::Offset<InputThanks>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<InputThanks>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<InputThanks> for InputThanksBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<InputThanks> {
                InputThanks::create(builder)
            }
        }

        /// Reference to a deserialized [InputThanks].
        #[derive(Copy, Clone)]
        pub struct InputThanksRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> InputThanksRef<'a> {}

        impl<'a> ::core::fmt::Debug for InputThanksRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("InputThanksRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<InputThanksRef<'a>> for InputThanks {
            type Error = ::planus::Error;

            fn try_from(_value: InputThanksRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for InputThanksRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for InputThanksRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[InputThanksRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<InputThanks>> for InputThanks {
            type Value = ::planus::Offset<InputThanks>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<InputThanks>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for InputThanksRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[InputThanksRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `EvalResult` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `EvalResult` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1021`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct EvalResult {
            /// The field `result` in the table `EvalResult`
            pub result: ::planus::alloc::boxed::Box<self::VarBytes>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for EvalResult {
            fn default() -> Self {
                Self {
                    result: ::core::default::Default::default(),
                }
            }
        }

        impl EvalResult {
            /// Creates a [EvalResultBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> EvalResultBuilder<()> {
                EvalResultBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_result: impl ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            ) -> ::planus::Offset<Self> {
                let prepared_result = field_result.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::VarBytes>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_result);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<EvalResult>> for EvalResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<EvalResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<EvalResult>> for EvalResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<EvalResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<EvalResult> for EvalResult {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<EvalResult> {
                EvalResult::create(builder, &self.result)
            }
        }

        /// Builder for serializing an instance of the [EvalResult] type.
        ///
        /// Can be created using the [EvalResult::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct EvalResultBuilder<State>(State);

        impl EvalResultBuilder<()> {
            /// Setter for the [`result` field](EvalResult#structfield.result).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn result<T0>(self, value: T0) -> EvalResultBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            {
                EvalResultBuilder((value,))
            }
        }

        impl<T0> EvalResultBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [EvalResult].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<EvalResult>
            where
                Self: ::planus::WriteAsOffset<EvalResult>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>>
            ::planus::WriteAs<::planus::Offset<EvalResult>> for EvalResultBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<EvalResult>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<EvalResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>>
            ::planus::WriteAsOptional<::planus::Offset<EvalResult>> for EvalResultBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<EvalResult>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<EvalResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>>
            ::planus::WriteAsOffset<EvalResult> for EvalResultBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<EvalResult> {
                let (v0,) = &self.0;
                EvalResult::create(builder, v0)
            }
        }

        /// Reference to a deserialized [EvalResult].
        #[derive(Copy, Clone)]
        pub struct EvalResultRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> EvalResultRef<'a> {
            /// Getter for the [`result` field](EvalResult#structfield.result).
            #[inline]
            pub fn result(&self) -> ::planus::Result<self::VarBytesRef<'a>> {
                self.0.access_required(0, "EvalResult", "result")
            }
        }

        impl<'a> ::core::fmt::Debug for EvalResultRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("EvalResultRef");
                f.field("result", &self.result());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<EvalResultRef<'a>> for EvalResult {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: EvalResultRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    result: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.result()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for EvalResultRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for EvalResultRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[EvalResultRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<EvalResult>> for EvalResult {
            type Value = ::planus::Offset<EvalResult>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<EvalResult>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for EvalResultRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[EvalResultRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ThanksPong` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ThanksPong` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1025`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ThanksPong {
            /// The field `timestamp` in the table `ThanksPong`
            pub timestamp: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ThanksPong {
            fn default() -> Self {
                Self { timestamp: 0 }
            }
        }

        impl ThanksPong {
            /// Creates a [ThanksPongBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ThanksPongBuilder<()> {
                ThanksPongBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_timestamp = field_timestamp.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_timestamp.is_some() {
                    table_writer.write_entry::<u64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            object_writer.write::<_, _, 8>(&prepared_timestamp);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ThanksPong>> for ThanksPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ThanksPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ThanksPong>> for ThanksPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ThanksPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ThanksPong> for ThanksPong {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ThanksPong> {
                ThanksPong::create(builder, self.timestamp)
            }
        }

        /// Builder for serializing an instance of the [ThanksPong] type.
        ///
        /// Can be created using the [ThanksPong::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ThanksPongBuilder<State>(State);

        impl ThanksPongBuilder<()> {
            /// Setter for the [`timestamp` field](ThanksPong#structfield.timestamp).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp<T0>(self, value: T0) -> ThanksPongBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                ThanksPongBuilder((value,))
            }

            /// Sets the [`timestamp` field](ThanksPong#structfield.timestamp) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp_as_default(self) -> ThanksPongBuilder<(::planus::DefaultValue,)> {
                self.timestamp(::planus::DefaultValue)
            }
        }

        impl<T0> ThanksPongBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ThanksPong].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ThanksPong>
            where
                Self: ::planus::WriteAsOffset<ThanksPong>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAs<::planus::Offset<ThanksPong>>
            for ThanksPongBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ThanksPong>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ThanksPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<ThanksPong>> for ThanksPongBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ThanksPong>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ThanksPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>> ::planus::WriteAsOffset<ThanksPong>
            for ThanksPongBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ThanksPong> {
                let (v0,) = &self.0;
                ThanksPong::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ThanksPong].
        #[derive(Copy, Clone)]
        pub struct ThanksPongRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ThanksPongRef<'a> {
            /// Getter for the [`timestamp` field](ThanksPong#structfield.timestamp).
            #[inline]
            pub fn timestamp(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0.access(0, "ThanksPong", "timestamp")?.unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for ThanksPongRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ThanksPongRef");
                f.field("timestamp", &self.timestamp());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ThanksPongRef<'a>> for ThanksPong {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ThanksPongRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ThanksPongRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ThanksPongRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ThanksPongRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ThanksPong>> for ThanksPong {
            type Value = ::planus::Offset<ThanksPong>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ThanksPong>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ThanksPongRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ThanksPongRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbsReply` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbsReply` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1029`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbsReply {
            /// The field `verbs` in the table `VerbsReply`
            pub verbs: ::planus::alloc::vec::Vec<self::VerbInfo>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for VerbsReply {
            fn default() -> Self {
                Self {
                    verbs: ::core::default::Default::default(),
                }
            }
        }

        impl VerbsReply {
            /// Creates a [VerbsReplyBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbsReplyBuilder<()> {
                VerbsReplyBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_verbs: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::VerbInfo>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_verbs = field_verbs.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::VerbInfo>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_verbs);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbsReply>> for VerbsReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbsReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbsReply>> for VerbsReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbsReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbsReply> for VerbsReply {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbsReply> {
                VerbsReply::create(builder, &self.verbs)
            }
        }

        /// Builder for serializing an instance of the [VerbsReply] type.
        ///
        /// Can be created using the [VerbsReply::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbsReplyBuilder<State>(State);

        impl VerbsReplyBuilder<()> {
            /// Setter for the [`verbs` field](VerbsReply#structfield.verbs).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verbs<T0>(self, value: T0) -> VerbsReplyBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VerbInfo>]>>,
            {
                VerbsReplyBuilder((value,))
            }
        }

        impl<T0> VerbsReplyBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbsReply].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbsReply>
            where
                Self: ::planus::WriteAsOffset<VerbsReply>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VerbInfo>]>>>
            ::planus::WriteAs<::planus::Offset<VerbsReply>> for VerbsReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbsReply>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbsReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VerbInfo>]>>>
            ::planus::WriteAsOptional<::planus::Offset<VerbsReply>> for VerbsReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbsReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbsReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VerbInfo>]>>>
            ::planus::WriteAsOffset<VerbsReply> for VerbsReplyBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbsReply> {
                let (v0,) = &self.0;
                VerbsReply::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VerbsReply].
        #[derive(Copy, Clone)]
        pub struct VerbsReplyRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbsReplyRef<'a> {
            /// Getter for the [`verbs` field](VerbsReply#structfield.verbs).
            #[inline]
            pub fn verbs(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VerbInfoRef<'a>>>>
            {
                self.0.access_required(0, "VerbsReply", "verbs")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbsReplyRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbsReplyRef");
                f.field("verbs", &self.verbs());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbsReplyRef<'a>> for VerbsReply {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbsReplyRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    verbs: value.verbs()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbsReplyRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbsReplyRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbsReplyRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbsReply>> for VerbsReply {
            type Value = ::planus::Offset<VerbsReply>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbsReply>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbsReplyRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbsReplyRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PropertiesReply` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PropertiesReply` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1033`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertiesReply {
            /// The field `properties` in the table `PropertiesReply`
            pub properties: ::planus::alloc::vec::Vec<self::PropInfo>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PropertiesReply {
            fn default() -> Self {
                Self {
                    properties: ::core::default::Default::default(),
                }
            }
        }

        impl PropertiesReply {
            /// Creates a [PropertiesReplyBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertiesReplyBuilder<()> {
                PropertiesReplyBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_properties: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::PropInfo>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_properties = field_properties.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::PropInfo>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_properties);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertiesReply>> for PropertiesReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertiesReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertiesReply>> for PropertiesReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertiesReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertiesReply> for PropertiesReply {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertiesReply> {
                PropertiesReply::create(builder, &self.properties)
            }
        }

        /// Builder for serializing an instance of the [PropertiesReply] type.
        ///
        /// Can be created using the [PropertiesReply::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertiesReplyBuilder<State>(State);

        impl PropertiesReplyBuilder<()> {
            /// Setter for the [`properties` field](PropertiesReply#structfield.properties).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn properties<T0>(self, value: T0) -> PropertiesReplyBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PropInfo>]>>,
            {
                PropertiesReplyBuilder((value,))
            }
        }

        impl<T0> PropertiesReplyBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertiesReply].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertiesReply>
            where
                Self: ::planus::WriteAsOffset<PropertiesReply>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PropInfo>]>>>
            ::planus::WriteAs<::planus::Offset<PropertiesReply>> for PropertiesReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PropertiesReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertiesReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PropInfo>]>>>
            ::planus::WriteAsOptional<::planus::Offset<PropertiesReply>>
            for PropertiesReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<PropertiesReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertiesReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PropInfo>]>>>
            ::planus::WriteAsOffset<PropertiesReply> for PropertiesReplyBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PropertiesReply> {
                let (v0,) = &self.0;
                PropertiesReply::create(builder, v0)
            }
        }

        /// Reference to a deserialized [PropertiesReply].
        #[derive(Copy, Clone)]
        pub struct PropertiesReplyRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertiesReplyRef<'a> {
            /// Getter for the [`properties` field](PropertiesReply#structfield.properties).
            #[inline]
            pub fn properties(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::PropInfoRef<'a>>>>
            {
                self.0.access_required(0, "PropertiesReply", "properties")
            }
        }

        impl<'a> ::core::fmt::Debug for PropertiesReplyRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertiesReplyRef");
                f.field("properties", &self.properties());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertiesReplyRef<'a>> for PropertiesReply {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropertiesReplyRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    properties: value.properties()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertiesReplyRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertiesReplyRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertiesReplyRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertiesReply>> for PropertiesReply {
            type Value = ::planus::Offset<PropertiesReply>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertiesReply>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertiesReplyRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropertiesReplyRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbProgramResponseReply` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbProgramResponseReply` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1037`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbProgramResponseReply {
            /// The field `response` in the table `VerbProgramResponseReply`
            pub response: ::planus::alloc::boxed::Box<self::VerbProgramResponse>,
        }

        impl VerbProgramResponseReply {
            /// Creates a [VerbProgramResponseReplyBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbProgramResponseReplyBuilder<()> {
                VerbProgramResponseReplyBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_response: impl ::planus::WriteAs<::planus::Offset<self::VerbProgramResponse>>,
            ) -> ::planus::Offset<Self> {
                let prepared_response = field_response.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::VerbProgramResponse>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_response);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbProgramResponseReply>> for VerbProgramResponseReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramResponseReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbProgramResponseReply>>
            for VerbProgramResponseReply
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramResponseReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbProgramResponseReply> for VerbProgramResponseReply {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramResponseReply> {
                VerbProgramResponseReply::create(builder, &self.response)
            }
        }

        /// Builder for serializing an instance of the [VerbProgramResponseReply] type.
        ///
        /// Can be created using the [VerbProgramResponseReply::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbProgramResponseReplyBuilder<State>(State);

        impl VerbProgramResponseReplyBuilder<()> {
            /// Setter for the [`response` field](VerbProgramResponseReply#structfield.response).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn response<T0>(self, value: T0) -> VerbProgramResponseReplyBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramResponse>>,
            {
                VerbProgramResponseReplyBuilder((value,))
            }
        }

        impl<T0> VerbProgramResponseReplyBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbProgramResponseReply].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramResponseReply>
            where
                Self: ::planus::WriteAsOffset<VerbProgramResponseReply>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramResponse>>>
            ::planus::WriteAs<::planus::Offset<VerbProgramResponseReply>>
            for VerbProgramResponseReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbProgramResponseReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramResponseReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramResponse>>>
            ::planus::WriteAsOptional<::planus::Offset<VerbProgramResponseReply>>
            for VerbProgramResponseReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<VerbProgramResponseReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbProgramResponseReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VerbProgramResponse>>>
            ::planus::WriteAsOffset<VerbProgramResponseReply>
            for VerbProgramResponseReplyBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<VerbProgramResponseReply> {
                let (v0,) = &self.0;
                VerbProgramResponseReply::create(builder, v0)
            }
        }

        /// Reference to a deserialized [VerbProgramResponseReply].
        #[derive(Copy, Clone)]
        pub struct VerbProgramResponseReplyRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbProgramResponseReplyRef<'a> {
            /// Getter for the [`response` field](VerbProgramResponseReply#structfield.response).
            #[inline]
            pub fn response(&self) -> ::planus::Result<self::VerbProgramResponseRef<'a>> {
                self.0
                    .access_required(0, "VerbProgramResponseReply", "response")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbProgramResponseReplyRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbProgramResponseReplyRef");
                f.field("response", &self.response());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbProgramResponseReplyRef<'a>> for VerbProgramResponseReply {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbProgramResponseReplyRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    response: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.response()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbProgramResponseReplyRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbProgramResponseReplyRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbProgramResponseReplyRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbProgramResponseReply>>
            for VerbProgramResponseReply
        {
            type Value = ::planus::Offset<VerbProgramResponseReply>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbProgramResponseReply>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbProgramResponseReplyRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbProgramResponseReplyRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `PropertyValue` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PropertyValue` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1041`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PropertyValue {
            /// The field `prop_info` in the table `PropertyValue`
            pub prop_info: ::planus::alloc::boxed::Box<self::PropInfo>,
            /// The field `value` in the table `PropertyValue`
            pub value: ::planus::alloc::boxed::Box<self::VarBytes>,
        }

        impl PropertyValue {
            /// Creates a [PropertyValueBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PropertyValueBuilder<()> {
                PropertyValueBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_prop_info: impl ::planus::WriteAs<::planus::Offset<self::PropInfo>>,
                field_value: impl ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            ) -> ::planus::Offset<Self> {
                let prepared_prop_info = field_prop_info.prepare(builder);
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::PropInfo>>(0);
                table_writer.write_entry::<::planus::Offset<self::VarBytes>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_prop_info);
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PropertyValue>> for PropertyValue {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropertyValue> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PropertyValue>> for PropertyValue {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyValue>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PropertyValue> for PropertyValue {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropertyValue> {
                PropertyValue::create(builder, &self.prop_info, &self.value)
            }
        }

        /// Builder for serializing an instance of the [PropertyValue] type.
        ///
        /// Can be created using the [PropertyValue::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PropertyValueBuilder<State>(State);

        impl PropertyValueBuilder<()> {
            /// Setter for the [`prop_info` field](PropertyValue#structfield.prop_info).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn prop_info<T0>(self, value: T0) -> PropertyValueBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::PropInfo>>,
            {
                PropertyValueBuilder((value,))
            }
        }

        impl<T0> PropertyValueBuilder<(T0,)> {
            /// Setter for the [`value` field](PropertyValue#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T1>(self, value: T1) -> PropertyValueBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            {
                let (v0,) = self.0;
                PropertyValueBuilder((v0, value))
            }
        }

        impl<T0, T1> PropertyValueBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PropertyValue].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropertyValue>
            where
                Self: ::planus::WriteAsOffset<PropertyValue>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::PropInfo>>,
            T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAs<::planus::Offset<PropertyValue>> for PropertyValueBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PropertyValue>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropertyValue> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::PropInfo>>,
            T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOptional<::planus::Offset<PropertyValue>>
            for PropertyValueBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PropertyValue>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PropertyValue>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::PropInfo>>,
            T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOffset<PropertyValue> for PropertyValueBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PropertyValue> {
                let (v0, v1) = &self.0;
                PropertyValue::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [PropertyValue].
        #[derive(Copy, Clone)]
        pub struct PropertyValueRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PropertyValueRef<'a> {
            /// Getter for the [`prop_info` field](PropertyValue#structfield.prop_info).
            #[inline]
            pub fn prop_info(&self) -> ::planus::Result<self::PropInfoRef<'a>> {
                self.0.access_required(0, "PropertyValue", "prop_info")
            }

            /// Getter for the [`value` field](PropertyValue#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<self::VarBytesRef<'a>> {
                self.0.access_required(1, "PropertyValue", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for PropertyValueRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PropertyValueRef");
                f.field("prop_info", &self.prop_info());
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PropertyValueRef<'a>> for PropertyValue {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PropertyValueRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    prop_info: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.prop_info()?)?,
                    ),
                    value: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.value()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PropertyValueRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PropertyValueRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PropertyValueRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PropertyValue>> for PropertyValue {
            type Value = ::planus::Offset<PropertyValue>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PropertyValue>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PropertyValueRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PropertyValueRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `VerbValue` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `VerbValue` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1046`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct VerbValue {
            /// The field `verb_info` in the table `VerbValue`
            pub verb_info: ::planus::alloc::boxed::Box<self::VerbInfo>,
            /// The field `code` in the table `VerbValue`
            pub code: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
        }

        impl VerbValue {
            /// Creates a [VerbValueBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> VerbValueBuilder<()> {
                VerbValueBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_verb_info: impl ::planus::WriteAs<::planus::Offset<self::VerbInfo>>,
                field_code: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
            ) -> ::planus::Offset<Self> {
                let prepared_verb_info = field_verb_info.prepare(builder);
                let prepared_code = field_code.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::VerbInfo>>(0);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_verb_info);
                        object_writer.write::<_, _, 4>(&prepared_code);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<VerbValue>> for VerbValue {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbValue> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<VerbValue>> for VerbValue {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbValue>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<VerbValue> for VerbValue {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbValue> {
                VerbValue::create(builder, &self.verb_info, &self.code)
            }
        }

        /// Builder for serializing an instance of the [VerbValue] type.
        ///
        /// Can be created using the [VerbValue::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct VerbValueBuilder<State>(State);

        impl VerbValueBuilder<()> {
            /// Setter for the [`verb_info` field](VerbValue#structfield.verb_info).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn verb_info<T0>(self, value: T0) -> VerbValueBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::VerbInfo>>,
            {
                VerbValueBuilder((value,))
            }
        }

        impl<T0> VerbValueBuilder<(T0,)> {
            /// Setter for the [`code` field](VerbValue#structfield.code).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn code<T1>(self, value: T1) -> VerbValueBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
            {
                let (v0,) = self.0;
                VerbValueBuilder((v0, value))
            }
        }

        impl<T0, T1> VerbValueBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VerbValue].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbValue>
            where
                Self: ::planus::WriteAsOffset<VerbValue>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::VerbInfo>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
        > ::planus::WriteAs<::planus::Offset<VerbValue>> for VerbValueBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbValue>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbValue> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::VerbInfo>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
        > ::planus::WriteAsOptional<::planus::Offset<VerbValue>> for VerbValueBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<VerbValue>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<VerbValue>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::VerbInfo>>,
            T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
        > ::planus::WriteAsOffset<VerbValue> for VerbValueBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<VerbValue> {
                let (v0, v1) = &self.0;
                VerbValue::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [VerbValue].
        #[derive(Copy, Clone)]
        pub struct VerbValueRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> VerbValueRef<'a> {
            /// Getter for the [`verb_info` field](VerbValue#structfield.verb_info).
            #[inline]
            pub fn verb_info(&self) -> ::planus::Result<self::VerbInfoRef<'a>> {
                self.0.access_required(0, "VerbValue", "verb_info")
            }

            /// Getter for the [`code` field](VerbValue#structfield.code).
            #[inline]
            pub fn code(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>>
            {
                self.0.access_required(1, "VerbValue", "code")
            }
        }

        impl<'a> ::core::fmt::Debug for VerbValueRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("VerbValueRef");
                f.field("verb_info", &self.verb_info());
                f.field("code", &self.code());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<VerbValueRef<'a>> for VerbValue {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: VerbValueRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    verb_info: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.verb_info()?)?,
                    ),
                    code: value.code()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for VerbValueRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for VerbValueRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[VerbValueRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<VerbValue>> for VerbValue {
            type Value = ::planus::Offset<VerbValue>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<VerbValue>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for VerbValueRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[VerbValueRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ResolveResult` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ResolveResult` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1051`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ResolveResult {
            /// The field `result` in the table `ResolveResult`
            pub result: ::planus::alloc::boxed::Box<self::VarBytes>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ResolveResult {
            fn default() -> Self {
                Self {
                    result: ::core::default::Default::default(),
                }
            }
        }

        impl ResolveResult {
            /// Creates a [ResolveResultBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ResolveResultBuilder<()> {
                ResolveResultBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_result: impl ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            ) -> ::planus::Offset<Self> {
                let prepared_result = field_result.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::VarBytes>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_result);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ResolveResult>> for ResolveResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ResolveResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ResolveResult>> for ResolveResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ResolveResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ResolveResult> for ResolveResult {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ResolveResult> {
                ResolveResult::create(builder, &self.result)
            }
        }

        /// Builder for serializing an instance of the [ResolveResult] type.
        ///
        /// Can be created using the [ResolveResult::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ResolveResultBuilder<State>(State);

        impl ResolveResultBuilder<()> {
            /// Setter for the [`result` field](ResolveResult#structfield.result).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn result<T0>(self, value: T0) -> ResolveResultBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            {
                ResolveResultBuilder((value,))
            }
        }

        impl<T0> ResolveResultBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ResolveResult].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ResolveResult>
            where
                Self: ::planus::WriteAsOffset<ResolveResult>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>>
            ::planus::WriteAs<::planus::Offset<ResolveResult>> for ResolveResultBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ResolveResult>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ResolveResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>>
            ::planus::WriteAsOptional<::planus::Offset<ResolveResult>>
            for ResolveResultBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ResolveResult>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ResolveResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::VarBytes>>>
            ::planus::WriteAsOffset<ResolveResult> for ResolveResultBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ResolveResult> {
                let (v0,) = &self.0;
                ResolveResult::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ResolveResult].
        #[derive(Copy, Clone)]
        pub struct ResolveResultRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ResolveResultRef<'a> {
            /// Getter for the [`result` field](ResolveResult#structfield.result).
            #[inline]
            pub fn result(&self) -> ::planus::Result<self::VarBytesRef<'a>> {
                self.0.access_required(0, "ResolveResult", "result")
            }
        }

        impl<'a> ::core::fmt::Debug for ResolveResultRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ResolveResultRef");
                f.field("result", &self.result());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ResolveResultRef<'a>> for ResolveResult {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ResolveResultRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    result: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.result()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ResolveResultRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ResolveResultRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ResolveResultRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ResolveResult>> for ResolveResult {
            type Value = ::planus::Offset<ResolveResult>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ResolveResult>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ResolveResultRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ResolveResultRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `CurrentPresentations` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `CurrentPresentations` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1055`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct CurrentPresentations {
            /// The field `presentations` in the table `CurrentPresentations`
            pub presentations: ::planus::alloc::vec::Vec<self::Presentation>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for CurrentPresentations {
            fn default() -> Self {
                Self {
                    presentations: ::core::default::Default::default(),
                }
            }
        }

        impl CurrentPresentations {
            /// Creates a [CurrentPresentationsBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> CurrentPresentationsBuilder<()> {
                CurrentPresentationsBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_presentations: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::Presentation>]>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_presentations = field_presentations.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer
                    .write_entry::<::planus::Offset<[::planus::Offset<self::Presentation>]>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_presentations);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<CurrentPresentations>> for CurrentPresentations {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CurrentPresentations> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<CurrentPresentations>> for CurrentPresentations {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CurrentPresentations>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<CurrentPresentations> for CurrentPresentations {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CurrentPresentations> {
                CurrentPresentations::create(builder, &self.presentations)
            }
        }

        /// Builder for serializing an instance of the [CurrentPresentations] type.
        ///
        /// Can be created using the [CurrentPresentations::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct CurrentPresentationsBuilder<State>(State);

        impl CurrentPresentationsBuilder<()> {
            /// Setter for the [`presentations` field](CurrentPresentations#structfield.presentations).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn presentations<T0>(self, value: T0) -> CurrentPresentationsBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Presentation>]>>,
            {
                CurrentPresentationsBuilder((value,))
            }
        }

        impl<T0> CurrentPresentationsBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CurrentPresentations].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CurrentPresentations>
            where
                Self: ::planus::WriteAsOffset<CurrentPresentations>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Presentation>]>>>
            ::planus::WriteAs<::planus::Offset<CurrentPresentations>>
            for CurrentPresentationsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CurrentPresentations>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CurrentPresentations> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Presentation>]>>>
            ::planus::WriteAsOptional<::planus::Offset<CurrentPresentations>>
            for CurrentPresentationsBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<CurrentPresentations>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<CurrentPresentations>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Presentation>]>>>
            ::planus::WriteAsOffset<CurrentPresentations> for CurrentPresentationsBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<CurrentPresentations> {
                let (v0,) = &self.0;
                CurrentPresentations::create(builder, v0)
            }
        }

        /// Reference to a deserialized [CurrentPresentations].
        #[derive(Copy, Clone)]
        pub struct CurrentPresentationsRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> CurrentPresentationsRef<'a> {
            /// Getter for the [`presentations` field](CurrentPresentations#structfield.presentations).
            #[inline]
            pub fn presentations(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::PresentationRef<'a>>>>
            {
                self.0
                    .access_required(0, "CurrentPresentations", "presentations")
            }
        }

        impl<'a> ::core::fmt::Debug for CurrentPresentationsRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("CurrentPresentationsRef");
                f.field("presentations", &self.presentations());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<CurrentPresentationsRef<'a>> for CurrentPresentations {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: CurrentPresentationsRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    presentations: value.presentations()?.to_vec_result()?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for CurrentPresentationsRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for CurrentPresentationsRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[CurrentPresentationsRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<CurrentPresentations>> for CurrentPresentations {
            type Value = ::planus::Offset<CurrentPresentations>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<CurrentPresentations>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for CurrentPresentationsRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[CurrentPresentationsRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PresentationDismissed` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PresentationDismissed` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1059`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PresentationDismissed {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PresentationDismissed {
            fn default() -> Self {
                Self {}
            }
        }

        impl PresentationDismissed {
            /// Creates a [PresentationDismissedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PresentationDismissedBuilder<()> {
                PresentationDismissedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PresentationDismissed>> for PresentationDismissed {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationDismissed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PresentationDismissed>> for PresentationDismissed {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PresentationDismissed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PresentationDismissed> for PresentationDismissed {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationDismissed> {
                PresentationDismissed::create(builder)
            }
        }

        /// Builder for serializing an instance of the [PresentationDismissed] type.
        ///
        /// Can be created using the [PresentationDismissed::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PresentationDismissedBuilder<State>(State);

        impl PresentationDismissedBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PresentationDismissed].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationDismissed>
            where
                Self: ::planus::WriteAsOffset<PresentationDismissed>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PresentationDismissed>>
            for PresentationDismissedBuilder<()>
        {
            type Prepared = ::planus::Offset<PresentationDismissed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationDismissed> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PresentationDismissed>>
            for PresentationDismissedBuilder<()>
        {
            type Prepared = ::planus::Offset<PresentationDismissed>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PresentationDismissed>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PresentationDismissed> for PresentationDismissedBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PresentationDismissed> {
                PresentationDismissed::create(builder)
            }
        }

        /// Reference to a deserialized [PresentationDismissed].
        #[derive(Copy, Clone)]
        pub struct PresentationDismissedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PresentationDismissedRef<'a> {}

        impl<'a> ::core::fmt::Debug for PresentationDismissedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PresentationDismissedRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PresentationDismissedRef<'a>> for PresentationDismissed {
            type Error = ::planus::Error;

            fn try_from(_value: PresentationDismissedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for PresentationDismissedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PresentationDismissedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PresentationDismissedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PresentationDismissed>>
            for PresentationDismissed
        {
            type Value = ::planus::Offset<PresentationDismissed>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PresentationDismissed>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PresentationDismissedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PresentationDismissedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ClientAttributeSet` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ClientAttributeSet` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1062`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ClientAttributeSet {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ClientAttributeSet {
            fn default() -> Self {
                Self {}
            }
        }

        impl ClientAttributeSet {
            /// Creates a [ClientAttributeSetBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ClientAttributeSetBuilder<()> {
                ClientAttributeSetBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ClientAttributeSet>> for ClientAttributeSet {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientAttributeSet> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ClientAttributeSet>> for ClientAttributeSet {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientAttributeSet>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ClientAttributeSet> for ClientAttributeSet {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientAttributeSet> {
                ClientAttributeSet::create(builder)
            }
        }

        /// Builder for serializing an instance of the [ClientAttributeSet] type.
        ///
        /// Can be created using the [ClientAttributeSet::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ClientAttributeSetBuilder<State>(State);

        impl ClientAttributeSetBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ClientAttributeSet].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientAttributeSet>
            where
                Self: ::planus::WriteAsOffset<ClientAttributeSet>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ClientAttributeSet>> for ClientAttributeSetBuilder<()> {
            type Prepared = ::planus::Offset<ClientAttributeSet>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientAttributeSet> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ClientAttributeSet>>
            for ClientAttributeSetBuilder<()>
        {
            type Prepared = ::planus::Offset<ClientAttributeSet>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientAttributeSet>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ClientAttributeSet> for ClientAttributeSetBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientAttributeSet> {
                ClientAttributeSet::create(builder)
            }
        }

        /// Reference to a deserialized [ClientAttributeSet].
        #[derive(Copy, Clone)]
        pub struct ClientAttributeSetRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ClientAttributeSetRef<'a> {}

        impl<'a> ::core::fmt::Debug for ClientAttributeSetRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ClientAttributeSetRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ClientAttributeSetRef<'a>> for ClientAttributeSet {
            type Error = ::planus::Error;

            fn try_from(_value: ClientAttributeSetRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for ClientAttributeSetRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ClientAttributeSetRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ClientAttributeSetRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ClientAttributeSet>> for ClientAttributeSet {
            type Value = ::planus::Offset<ClientAttributeSet>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ClientAttributeSet>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ClientAttributeSetRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ClientAttributeSetRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Disconnected` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Disconnected` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1065`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Disconnected {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Disconnected {
            fn default() -> Self {
                Self {}
            }
        }

        impl Disconnected {
            /// Creates a [DisconnectedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DisconnectedBuilder<()> {
                DisconnectedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Disconnected>> for Disconnected {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Disconnected> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Disconnected>> for Disconnected {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Disconnected>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Disconnected> for Disconnected {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Disconnected> {
                Disconnected::create(builder)
            }
        }

        /// Builder for serializing an instance of the [Disconnected] type.
        ///
        /// Can be created using the [Disconnected::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DisconnectedBuilder<State>(State);

        impl DisconnectedBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Disconnected].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Disconnected>
            where
                Self: ::planus::WriteAsOffset<Disconnected>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Disconnected>> for DisconnectedBuilder<()> {
            type Prepared = ::planus::Offset<Disconnected>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Disconnected> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Disconnected>> for DisconnectedBuilder<()> {
            type Prepared = ::planus::Offset<Disconnected>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Disconnected>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Disconnected> for DisconnectedBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Disconnected> {
                Disconnected::create(builder)
            }
        }

        /// Reference to a deserialized [Disconnected].
        #[derive(Copy, Clone)]
        pub struct DisconnectedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DisconnectedRef<'a> {}

        impl<'a> ::core::fmt::Debug for DisconnectedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DisconnectedRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DisconnectedRef<'a>> for Disconnected {
            type Error = ::planus::Error;

            fn try_from(_value: DisconnectedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for DisconnectedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DisconnectedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DisconnectedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Disconnected>> for Disconnected {
            type Value = ::planus::Offset<Disconnected>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Disconnected>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DisconnectedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DisconnectedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DaemonToClientReply` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DaemonToClientReply` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1068`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DaemonToClientReply {
            /// The field `reply` in the table `DaemonToClientReply`
            pub reply: self::DaemonToClientReplyUnion,
        }

        impl DaemonToClientReply {
            /// Creates a [DaemonToClientReplyBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToClientReplyBuilder<()> {
                DaemonToClientReplyBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_reply: impl ::planus::WriteAsUnion<self::DaemonToClientReplyUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_reply = field_reply.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::DaemonToClientReplyUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_reply.offset());
                        object_writer.write::<_, _, 1>(&prepared_reply.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DaemonToClientReply>> for DaemonToClientReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToClientReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DaemonToClientReply>> for DaemonToClientReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToClientReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DaemonToClientReply> for DaemonToClientReply {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToClientReply> {
                DaemonToClientReply::create(builder, &self.reply)
            }
        }

        /// Builder for serializing an instance of the [DaemonToClientReply] type.
        ///
        /// Can be created using the [DaemonToClientReply::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToClientReplyBuilder<State>(State);

        impl DaemonToClientReplyBuilder<()> {
            /// Setter for the [`reply` field](DaemonToClientReply#structfield.reply).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn reply<T0>(self, value: T0) -> DaemonToClientReplyBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::DaemonToClientReplyUnion>,
            {
                DaemonToClientReplyBuilder((value,))
            }
        }

        impl<T0> DaemonToClientReplyBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DaemonToClientReply].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToClientReply>
            where
                Self: ::planus::WriteAsOffset<DaemonToClientReply>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToClientReplyUnion>>
            ::planus::WriteAs<::planus::Offset<DaemonToClientReply>>
            for DaemonToClientReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DaemonToClientReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToClientReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToClientReplyUnion>>
            ::planus::WriteAsOptional<::planus::Offset<DaemonToClientReply>>
            for DaemonToClientReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DaemonToClientReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToClientReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToClientReplyUnion>>
            ::planus::WriteAsOffset<DaemonToClientReply> for DaemonToClientReplyBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToClientReply> {
                let (v0,) = &self.0;
                DaemonToClientReply::create(builder, v0)
            }
        }

        /// Reference to a deserialized [DaemonToClientReply].
        #[derive(Copy, Clone)]
        pub struct DaemonToClientReplyRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DaemonToClientReplyRef<'a> {
            /// Getter for the [`reply` field](DaemonToClientReply#structfield.reply).
            #[inline]
            pub fn reply(&self) -> ::planus::Result<self::DaemonToClientReplyUnionRef<'a>> {
                self.0
                    .access_union_required(0, "DaemonToClientReply", "reply")
            }
        }

        impl<'a> ::core::fmt::Debug for DaemonToClientReplyRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DaemonToClientReplyRef");
                f.field("reply", &self.reply());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DaemonToClientReplyRef<'a>> for DaemonToClientReply {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DaemonToClientReplyRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    reply: ::core::convert::TryInto::try_into(value.reply()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DaemonToClientReplyRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DaemonToClientReplyRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DaemonToClientReplyRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DaemonToClientReply>> for DaemonToClientReply {
            type Value = ::planus::Offset<DaemonToClientReply>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DaemonToClientReply>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DaemonToClientReplyRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DaemonToClientReplyRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `ClientEventUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `ClientEventUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1076`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum ClientEventUnion {
            /// The variant of type `NarrativeEventMessage` in the union `ClientEventUnion`
            NarrativeEventMessage(::planus::alloc::boxed::Box<self::NarrativeEventMessage>),

            /// The variant of type `RequestInputEvent` in the union `ClientEventUnion`
            RequestInputEvent(::planus::alloc::boxed::Box<self::RequestInputEvent>),

            /// The variant of type `SystemMessageEvent` in the union `ClientEventUnion`
            SystemMessageEvent(::planus::alloc::boxed::Box<self::SystemMessageEvent>),

            /// The variant of type `DisconnectEvent` in the union `ClientEventUnion`
            DisconnectEvent(::planus::alloc::boxed::Box<self::DisconnectEvent>),

            /// The variant of type `TaskErrorEvent` in the union `ClientEventUnion`
            TaskErrorEvent(::planus::alloc::boxed::Box<self::TaskErrorEvent>),

            /// The variant of type `TaskSuccessEvent` in the union `ClientEventUnion`
            TaskSuccessEvent(::planus::alloc::boxed::Box<self::TaskSuccessEvent>),

            /// The variant of type `PlayerSwitchedEvent` in the union `ClientEventUnion`
            PlayerSwitchedEvent(::planus::alloc::boxed::Box<self::PlayerSwitchedEvent>),

            /// The variant of type `SetConnectionOptionEvent` in the union `ClientEventUnion`
            SetConnectionOptionEvent(::planus::alloc::boxed::Box<self::SetConnectionOptionEvent>),
        }

        impl ClientEventUnion {
            /// Creates a [ClientEventUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ClientEventUnionBuilder<::planus::Uninitialized> {
                ClientEventUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_narrative_event_message(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::NarrativeEventMessage>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_request_input_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RequestInputEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_system_message_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::SystemMessageEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_disconnect_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DisconnectEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_task_error_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::TaskErrorEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_task_success_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::TaskSuccessEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_player_switched_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PlayerSwitchedEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_set_connection_option_event(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::SetConnectionOptionEvent>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<ClientEventUnion> for ClientEventUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::NarrativeEventMessage(value) => {
                        Self::create_narrative_event_message(builder, value)
                    }
                    Self::RequestInputEvent(value) => {
                        Self::create_request_input_event(builder, value)
                    }
                    Self::SystemMessageEvent(value) => {
                        Self::create_system_message_event(builder, value)
                    }
                    Self::DisconnectEvent(value) => Self::create_disconnect_event(builder, value),
                    Self::TaskErrorEvent(value) => Self::create_task_error_event(builder, value),
                    Self::TaskSuccessEvent(value) => {
                        Self::create_task_success_event(builder, value)
                    }
                    Self::PlayerSwitchedEvent(value) => {
                        Self::create_player_switched_event(builder, value)
                    }
                    Self::SetConnectionOptionEvent(value) => {
                        Self::create_set_connection_option_event(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<ClientEventUnion> for ClientEventUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [ClientEventUnion] type.
        ///
        /// Can be created using the [ClientEventUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ClientEventUnionBuilder<T>(T);

        impl ClientEventUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`NarrativeEventMessage` variant](ClientEventUnion#variant.NarrativeEventMessage).
            #[inline]
            pub fn narrative_event_message<T>(
                self,
                value: T,
            ) -> ClientEventUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::NarrativeEventMessage>,
            {
                ClientEventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RequestInputEvent` variant](ClientEventUnion#variant.RequestInputEvent).
            #[inline]
            pub fn request_input_event<T>(
                self,
                value: T,
            ) -> ClientEventUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::RequestInputEvent>,
            {
                ClientEventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`SystemMessageEvent` variant](ClientEventUnion#variant.SystemMessageEvent).
            #[inline]
            pub fn system_message_event<T>(
                self,
                value: T,
            ) -> ClientEventUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::SystemMessageEvent>,
            {
                ClientEventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DisconnectEvent` variant](ClientEventUnion#variant.DisconnectEvent).
            #[inline]
            pub fn disconnect_event<T>(
                self,
                value: T,
            ) -> ClientEventUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::DisconnectEvent>,
            {
                ClientEventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`TaskErrorEvent` variant](ClientEventUnion#variant.TaskErrorEvent).
            #[inline]
            pub fn task_error_event<T>(
                self,
                value: T,
            ) -> ClientEventUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::TaskErrorEvent>,
            {
                ClientEventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`TaskSuccessEvent` variant](ClientEventUnion#variant.TaskSuccessEvent).
            #[inline]
            pub fn task_success_event<T>(
                self,
                value: T,
            ) -> ClientEventUnionBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::TaskSuccessEvent>,
            {
                ClientEventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PlayerSwitchedEvent` variant](ClientEventUnion#variant.PlayerSwitchedEvent).
            #[inline]
            pub fn player_switched_event<T>(
                self,
                value: T,
            ) -> ClientEventUnionBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<self::PlayerSwitchedEvent>,
            {
                ClientEventUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`SetConnectionOptionEvent` variant](ClientEventUnion#variant.SetConnectionOptionEvent).
            #[inline]
            pub fn set_connection_option_event<T>(
                self,
                value: T,
            ) -> ClientEventUnionBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<self::SetConnectionOptionEvent>,
            {
                ClientEventUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> ClientEventUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [ClientEventUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientEventUnion>
            where
                Self: ::planus::WriteAsUnion<ClientEventUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::NarrativeEventMessage>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientEventUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::NarrativeEventMessage>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ClientEventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestInputEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientEventUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestInputEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ClientEventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::SystemMessageEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientEventUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::SystemMessageEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ClientEventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::DisconnectEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientEventUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::DisconnectEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ClientEventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskErrorEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientEventUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskErrorEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ClientEventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskSuccessEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientEventUnion> {
                ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<6, T>>
        where
            T: ::planus::WriteAsOffset<self::TaskSuccessEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ClientEventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::PlayerSwitchedEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientEventUnion> {
                ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<7, T>>
        where
            T: ::planus::WriteAsOffset<self::PlayerSwitchedEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ClientEventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::SetConnectionOptionEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientEventUnion> {
                ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ClientEventUnion>
            for ClientEventUnionBuilder<::planus::Initialized<8, T>>
        where
            T: ::planus::WriteAsOffset<self::SetConnectionOptionEvent>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ClientEventUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [ClientEventUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum ClientEventUnionRef<'a> {
            NarrativeEventMessage(self::NarrativeEventMessageRef<'a>),
            RequestInputEvent(self::RequestInputEventRef<'a>),
            SystemMessageEvent(self::SystemMessageEventRef<'a>),
            DisconnectEvent(self::DisconnectEventRef<'a>),
            TaskErrorEvent(self::TaskErrorEventRef<'a>),
            TaskSuccessEvent(self::TaskSuccessEventRef<'a>),
            PlayerSwitchedEvent(self::PlayerSwitchedEventRef<'a>),
            SetConnectionOptionEvent(self::SetConnectionOptionEventRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<ClientEventUnionRef<'a>> for ClientEventUnion {
            type Error = ::planus::Error;

            fn try_from(value: ClientEventUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    ClientEventUnionRef::NarrativeEventMessage(value) => {
                        Self::NarrativeEventMessage(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ClientEventUnionRef::RequestInputEvent(value) => {
                        Self::RequestInputEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ClientEventUnionRef::SystemMessageEvent(value) => {
                        Self::SystemMessageEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ClientEventUnionRef::DisconnectEvent(value) => {
                        Self::DisconnectEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ClientEventUnionRef::TaskErrorEvent(value) => {
                        Self::TaskErrorEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ClientEventUnionRef::TaskSuccessEvent(value) => {
                        Self::TaskSuccessEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ClientEventUnionRef::PlayerSwitchedEvent(value) => {
                        Self::PlayerSwitchedEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ClientEventUnionRef::SetConnectionOptionEvent(value) => {
                        Self::SetConnectionOptionEvent(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for ClientEventUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::NarrativeEventMessage(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::RequestInputEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::SystemMessageEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::DisconnectEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::TaskErrorEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    6 => ::core::result::Result::Ok(Self::TaskSuccessEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    7 => ::core::result::Result::Ok(Self::PlayerSwitchedEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    8 => ::core::result::Result::Ok(Self::SetConnectionOptionEvent(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for ClientEventUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[ClientEventUnionRef]";
        }

        /// The table `NarrativeEventMessage` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `NarrativeEventMessage` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1087`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct NarrativeEventMessage {
            /// The field `player` in the table `NarrativeEventMessage`
            pub player: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `event` in the table `NarrativeEventMessage`
            pub event: ::planus::alloc::boxed::Box<self::NarrativeEvent>,
        }

        impl NarrativeEventMessage {
            /// Creates a [NarrativeEventMessageBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> NarrativeEventMessageBuilder<()> {
                NarrativeEventMessageBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_player: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_event: impl ::planus::WriteAs<::planus::Offset<self::NarrativeEvent>>,
            ) -> ::planus::Offset<Self> {
                let prepared_player = field_player.prepare(builder);
                let prepared_event = field_event.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::NarrativeEvent>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_player);
                        object_writer.write::<_, _, 4>(&prepared_event);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<NarrativeEventMessage>> for NarrativeEventMessage {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NarrativeEventMessage> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<NarrativeEventMessage>> for NarrativeEventMessage {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NarrativeEventMessage>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<NarrativeEventMessage> for NarrativeEventMessage {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NarrativeEventMessage> {
                NarrativeEventMessage::create(builder, &self.player, &self.event)
            }
        }

        /// Builder for serializing an instance of the [NarrativeEventMessage] type.
        ///
        /// Can be created using the [NarrativeEventMessage::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct NarrativeEventMessageBuilder<State>(State);

        impl NarrativeEventMessageBuilder<()> {
            /// Setter for the [`player` field](NarrativeEventMessage#structfield.player).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn player<T0>(self, value: T0) -> NarrativeEventMessageBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                NarrativeEventMessageBuilder((value,))
            }
        }

        impl<T0> NarrativeEventMessageBuilder<(T0,)> {
            /// Setter for the [`event` field](NarrativeEventMessage#structfield.event).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event<T1>(self, value: T1) -> NarrativeEventMessageBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::NarrativeEvent>>,
            {
                let (v0,) = self.0;
                NarrativeEventMessageBuilder((v0, value))
            }
        }

        impl<T0, T1> NarrativeEventMessageBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NarrativeEventMessage].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NarrativeEventMessage>
            where
                Self: ::planus::WriteAsOffset<NarrativeEventMessage>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::NarrativeEvent>>,
        > ::planus::WriteAs<::planus::Offset<NarrativeEventMessage>>
            for NarrativeEventMessageBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<NarrativeEventMessage>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NarrativeEventMessage> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::NarrativeEvent>>,
        > ::planus::WriteAsOptional<::planus::Offset<NarrativeEventMessage>>
            for NarrativeEventMessageBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<NarrativeEventMessage>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<NarrativeEventMessage>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::NarrativeEvent>>,
        > ::planus::WriteAsOffset<NarrativeEventMessage>
            for NarrativeEventMessageBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<NarrativeEventMessage> {
                let (v0, v1) = &self.0;
                NarrativeEventMessage::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [NarrativeEventMessage].
        #[derive(Copy, Clone)]
        pub struct NarrativeEventMessageRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> NarrativeEventMessageRef<'a> {
            /// Getter for the [`player` field](NarrativeEventMessage#structfield.player).
            #[inline]
            pub fn player(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "NarrativeEventMessage", "player")
            }

            /// Getter for the [`event` field](NarrativeEventMessage#structfield.event).
            #[inline]
            pub fn event(&self) -> ::planus::Result<self::NarrativeEventRef<'a>> {
                self.0.access_required(1, "NarrativeEventMessage", "event")
            }
        }

        impl<'a> ::core::fmt::Debug for NarrativeEventMessageRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("NarrativeEventMessageRef");
                f.field("player", &self.player());
                f.field("event", &self.event());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<NarrativeEventMessageRef<'a>> for NarrativeEventMessage {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: NarrativeEventMessageRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    player: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.player()?,
                    )?),
                    event: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.event()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for NarrativeEventMessageRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for NarrativeEventMessageRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[NarrativeEventMessageRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<NarrativeEventMessage>>
            for NarrativeEventMessage
        {
            type Value = ::planus::Offset<NarrativeEventMessage>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<NarrativeEventMessage>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for NarrativeEventMessageRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[NarrativeEventMessageRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `RequestInputEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RequestInputEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1092`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RequestInputEvent {
            /// The field `request_id` in the table `RequestInputEvent`
            pub request_id: ::planus::alloc::boxed::Box<self::Uuid>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for RequestInputEvent {
            fn default() -> Self {
                Self {
                    request_id: ::core::default::Default::default(),
                }
            }
        }

        impl RequestInputEvent {
            /// Creates a [RequestInputEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RequestInputEventBuilder<()> {
                RequestInputEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_request_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            ) -> ::planus::Offset<Self> {
                let prepared_request_id = field_request_id.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_request_id);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RequestInputEvent>> for RequestInputEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestInputEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RequestInputEvent>> for RequestInputEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestInputEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RequestInputEvent> for RequestInputEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestInputEvent> {
                RequestInputEvent::create(builder, &self.request_id)
            }
        }

        /// Builder for serializing an instance of the [RequestInputEvent] type.
        ///
        /// Can be created using the [RequestInputEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RequestInputEventBuilder<State>(State);

        impl RequestInputEventBuilder<()> {
            /// Setter for the [`request_id` field](RequestInputEvent#structfield.request_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn request_id<T0>(self, value: T0) -> RequestInputEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                RequestInputEventBuilder((value,))
            }
        }

        impl<T0> RequestInputEventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RequestInputEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestInputEvent>
            where
                Self: ::planus::WriteAsOffset<RequestInputEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>>
            ::planus::WriteAs<::planus::Offset<RequestInputEvent>>
            for RequestInputEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<RequestInputEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestInputEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>>
            ::planus::WriteAsOptional<::planus::Offset<RequestInputEvent>>
            for RequestInputEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<RequestInputEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestInputEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>>
            ::planus::WriteAsOffset<RequestInputEvent> for RequestInputEventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RequestInputEvent> {
                let (v0,) = &self.0;
                RequestInputEvent::create(builder, v0)
            }
        }

        /// Reference to a deserialized [RequestInputEvent].
        #[derive(Copy, Clone)]
        pub struct RequestInputEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RequestInputEventRef<'a> {
            /// Getter for the [`request_id` field](RequestInputEvent#structfield.request_id).
            #[inline]
            pub fn request_id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(0, "RequestInputEvent", "request_id")
            }
        }

        impl<'a> ::core::fmt::Debug for RequestInputEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RequestInputEventRef");
                f.field("request_id", &self.request_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RequestInputEventRef<'a>> for RequestInputEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RequestInputEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    request_id: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.request_id()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RequestInputEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RequestInputEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RequestInputEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RequestInputEvent>> for RequestInputEvent {
            type Value = ::planus::Offset<RequestInputEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RequestInputEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RequestInputEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RequestInputEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `SystemMessageEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `SystemMessageEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1096`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct SystemMessageEvent {
            /// The field `player` in the table `SystemMessageEvent`
            pub player: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `message` in the table `SystemMessageEvent`
            pub message: ::planus::alloc::string::String,
        }

        impl SystemMessageEvent {
            /// Creates a [SystemMessageEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> SystemMessageEventBuilder<()> {
                SystemMessageEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_player: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_message: impl ::planus::WriteAs<::planus::Offset<str>>,
            ) -> ::planus::Offset<Self> {
                let prepared_player = field_player.prepare(builder);
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<str>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_player);
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<SystemMessageEvent>> for SystemMessageEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SystemMessageEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<SystemMessageEvent>> for SystemMessageEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SystemMessageEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<SystemMessageEvent> for SystemMessageEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SystemMessageEvent> {
                SystemMessageEvent::create(builder, &self.player, &self.message)
            }
        }

        /// Builder for serializing an instance of the [SystemMessageEvent] type.
        ///
        /// Can be created using the [SystemMessageEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct SystemMessageEventBuilder<State>(State);

        impl SystemMessageEventBuilder<()> {
            /// Setter for the [`player` field](SystemMessageEvent#structfield.player).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn player<T0>(self, value: T0) -> SystemMessageEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                SystemMessageEventBuilder((value,))
            }
        }

        impl<T0> SystemMessageEventBuilder<(T0,)> {
            /// Setter for the [`message` field](SystemMessageEvent#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T1>(self, value: T1) -> SystemMessageEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<str>>,
            {
                let (v0,) = self.0;
                SystemMessageEventBuilder((v0, value))
            }
        }

        impl<T0, T1> SystemMessageEventBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SystemMessageEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SystemMessageEvent>
            where
                Self: ::planus::WriteAsOffset<SystemMessageEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAs<::planus::Offset<SystemMessageEvent>>
            for SystemMessageEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<SystemMessageEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SystemMessageEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOptional<::planus::Offset<SystemMessageEvent>>
            for SystemMessageEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<SystemMessageEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SystemMessageEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<str>>,
        > ::planus::WriteAsOffset<SystemMessageEvent> for SystemMessageEventBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SystemMessageEvent> {
                let (v0, v1) = &self.0;
                SystemMessageEvent::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [SystemMessageEvent].
        #[derive(Copy, Clone)]
        pub struct SystemMessageEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> SystemMessageEventRef<'a> {
            /// Getter for the [`player` field](SystemMessageEvent#structfield.player).
            #[inline]
            pub fn player(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(0, "SystemMessageEvent", "player")
            }

            /// Getter for the [`message` field](SystemMessageEvent#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                self.0.access_required(1, "SystemMessageEvent", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for SystemMessageEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("SystemMessageEventRef");
                f.field("player", &self.player());
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<SystemMessageEventRef<'a>> for SystemMessageEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: SystemMessageEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    player: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.player()?,
                    )?),
                    message: ::core::convert::Into::into(value.message()?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for SystemMessageEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for SystemMessageEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[SystemMessageEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<SystemMessageEvent>> for SystemMessageEvent {
            type Value = ::planus::Offset<SystemMessageEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<SystemMessageEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for SystemMessageEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[SystemMessageEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DisconnectEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DisconnectEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1101`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DisconnectEvent {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DisconnectEvent {
            fn default() -> Self {
                Self {}
            }
        }

        impl DisconnectEvent {
            /// Creates a [DisconnectEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DisconnectEventBuilder<()> {
                DisconnectEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DisconnectEvent>> for DisconnectEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisconnectEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DisconnectEvent>> for DisconnectEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DisconnectEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DisconnectEvent> for DisconnectEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisconnectEvent> {
                DisconnectEvent::create(builder)
            }
        }

        /// Builder for serializing an instance of the [DisconnectEvent] type.
        ///
        /// Can be created using the [DisconnectEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DisconnectEventBuilder<State>(State);

        impl DisconnectEventBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DisconnectEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisconnectEvent>
            where
                Self: ::planus::WriteAsOffset<DisconnectEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DisconnectEvent>> for DisconnectEventBuilder<()> {
            type Prepared = ::planus::Offset<DisconnectEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisconnectEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DisconnectEvent>> for DisconnectEventBuilder<()> {
            type Prepared = ::planus::Offset<DisconnectEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DisconnectEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DisconnectEvent> for DisconnectEventBuilder<()> {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DisconnectEvent> {
                DisconnectEvent::create(builder)
            }
        }

        /// Reference to a deserialized [DisconnectEvent].
        #[derive(Copy, Clone)]
        pub struct DisconnectEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DisconnectEventRef<'a> {}

        impl<'a> ::core::fmt::Debug for DisconnectEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DisconnectEventRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DisconnectEventRef<'a>> for DisconnectEvent {
            type Error = ::planus::Error;

            fn try_from(_value: DisconnectEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for DisconnectEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DisconnectEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DisconnectEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DisconnectEvent>> for DisconnectEvent {
            type Value = ::planus::Offset<DisconnectEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DisconnectEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DisconnectEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DisconnectEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `TaskErrorEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `TaskErrorEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1104`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct TaskErrorEvent {
            /// The field `task_id` in the table `TaskErrorEvent`
            pub task_id: u64,
            /// The field `error` in the table `TaskErrorEvent`
            pub error: ::planus::alloc::boxed::Box<self::SchedulerError>,
        }

        impl TaskErrorEvent {
            /// Creates a [TaskErrorEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> TaskErrorEventBuilder<()> {
                TaskErrorEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_task_id: impl ::planus::WriteAsDefault<u64, u64>,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::SchedulerError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_task_id = field_task_id.prepare(builder, &0);
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_task_id.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                table_writer.write_entry::<::planus::Offset<self::SchedulerError>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_task_id) = prepared_task_id {
                            object_writer.write::<_, _, 8>(&prepared_task_id);
                        }
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TaskErrorEvent>> for TaskErrorEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskErrorEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TaskErrorEvent>> for TaskErrorEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskErrorEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TaskErrorEvent> for TaskErrorEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskErrorEvent> {
                TaskErrorEvent::create(builder, self.task_id, &self.error)
            }
        }

        /// Builder for serializing an instance of the [TaskErrorEvent] type.
        ///
        /// Can be created using the [TaskErrorEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct TaskErrorEventBuilder<State>(State);

        impl TaskErrorEventBuilder<()> {
            /// Setter for the [`task_id` field](TaskErrorEvent#structfield.task_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn task_id<T0>(self, value: T0) -> TaskErrorEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                TaskErrorEventBuilder((value,))
            }

            /// Sets the [`task_id` field](TaskErrorEvent#structfield.task_id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn task_id_as_default(self) -> TaskErrorEventBuilder<(::planus::DefaultValue,)> {
                self.task_id(::planus::DefaultValue)
            }
        }

        impl<T0> TaskErrorEventBuilder<(T0,)> {
            /// Setter for the [`error` field](TaskErrorEvent#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T1>(self, value: T1) -> TaskErrorEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::SchedulerError>>,
            {
                let (v0,) = self.0;
                TaskErrorEventBuilder((v0, value))
            }
        }

        impl<T0, T1> TaskErrorEventBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TaskErrorEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskErrorEvent>
            where
                Self: ::planus::WriteAsOffset<TaskErrorEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<self::SchedulerError>>,
        > ::planus::WriteAs<::planus::Offset<TaskErrorEvent>> for TaskErrorEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<TaskErrorEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskErrorEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<self::SchedulerError>>,
        > ::planus::WriteAsOptional<::planus::Offset<TaskErrorEvent>>
            for TaskErrorEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<TaskErrorEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskErrorEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<self::SchedulerError>>,
        > ::planus::WriteAsOffset<TaskErrorEvent> for TaskErrorEventBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TaskErrorEvent> {
                let (v0, v1) = &self.0;
                TaskErrorEvent::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [TaskErrorEvent].
        #[derive(Copy, Clone)]
        pub struct TaskErrorEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> TaskErrorEventRef<'a> {
            /// Getter for the [`task_id` field](TaskErrorEvent#structfield.task_id).
            #[inline]
            pub fn task_id(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0.access(0, "TaskErrorEvent", "task_id")?.unwrap_or(0),
                )
            }

            /// Getter for the [`error` field](TaskErrorEvent#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::SchedulerErrorRef<'a>> {
                self.0.access_required(1, "TaskErrorEvent", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for TaskErrorEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("TaskErrorEventRef");
                f.field("task_id", &self.task_id());
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<TaskErrorEventRef<'a>> for TaskErrorEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: TaskErrorEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    task_id: ::core::convert::TryInto::try_into(value.task_id()?)?,
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for TaskErrorEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for TaskErrorEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[TaskErrorEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<TaskErrorEvent>> for TaskErrorEvent {
            type Value = ::planus::Offset<TaskErrorEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<TaskErrorEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for TaskErrorEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[TaskErrorEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `TaskSuccessEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `TaskSuccessEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1109`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct TaskSuccessEvent {
            /// The field `task_id` in the table `TaskSuccessEvent`
            pub task_id: u64,
            /// The field `result` in the table `TaskSuccessEvent`
            pub result: ::planus::alloc::boxed::Box<self::VarBytes>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for TaskSuccessEvent {
            fn default() -> Self {
                Self {
                    task_id: 0,
                    result: ::core::default::Default::default(),
                }
            }
        }

        impl TaskSuccessEvent {
            /// Creates a [TaskSuccessEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> TaskSuccessEventBuilder<()> {
                TaskSuccessEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_task_id: impl ::planus::WriteAsDefault<u64, u64>,
                field_result: impl ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            ) -> ::planus::Offset<Self> {
                let prepared_task_id = field_task_id.prepare(builder, &0);
                let prepared_result = field_result.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                if prepared_task_id.is_some() {
                    table_writer.write_entry::<u64>(0);
                }
                table_writer.write_entry::<::planus::Offset<self::VarBytes>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_task_id) = prepared_task_id {
                            object_writer.write::<_, _, 8>(&prepared_task_id);
                        }
                        object_writer.write::<_, _, 4>(&prepared_result);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<TaskSuccessEvent>> for TaskSuccessEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskSuccessEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<TaskSuccessEvent>> for TaskSuccessEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskSuccessEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<TaskSuccessEvent> for TaskSuccessEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskSuccessEvent> {
                TaskSuccessEvent::create(builder, self.task_id, &self.result)
            }
        }

        /// Builder for serializing an instance of the [TaskSuccessEvent] type.
        ///
        /// Can be created using the [TaskSuccessEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct TaskSuccessEventBuilder<State>(State);

        impl TaskSuccessEventBuilder<()> {
            /// Setter for the [`task_id` field](TaskSuccessEvent#structfield.task_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn task_id<T0>(self, value: T0) -> TaskSuccessEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                TaskSuccessEventBuilder((value,))
            }

            /// Sets the [`task_id` field](TaskSuccessEvent#structfield.task_id) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn task_id_as_default(self) -> TaskSuccessEventBuilder<(::planus::DefaultValue,)> {
                self.task_id(::planus::DefaultValue)
            }
        }

        impl<T0> TaskSuccessEventBuilder<(T0,)> {
            /// Setter for the [`result` field](TaskSuccessEvent#structfield.result).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn result<T1>(self, value: T1) -> TaskSuccessEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            {
                let (v0,) = self.0;
                TaskSuccessEventBuilder((v0, value))
            }
        }

        impl<T0, T1> TaskSuccessEventBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TaskSuccessEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskSuccessEvent>
            where
                Self: ::planus::WriteAsOffset<TaskSuccessEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAs<::planus::Offset<TaskSuccessEvent>>
            for TaskSuccessEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<TaskSuccessEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskSuccessEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOptional<::planus::Offset<TaskSuccessEvent>>
            for TaskSuccessEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<TaskSuccessEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<TaskSuccessEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<u64, u64>,
            T1: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOffset<TaskSuccessEvent> for TaskSuccessEventBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<TaskSuccessEvent> {
                let (v0, v1) = &self.0;
                TaskSuccessEvent::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [TaskSuccessEvent].
        #[derive(Copy, Clone)]
        pub struct TaskSuccessEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> TaskSuccessEventRef<'a> {
            /// Getter for the [`task_id` field](TaskSuccessEvent#structfield.task_id).
            #[inline]
            pub fn task_id(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "TaskSuccessEvent", "task_id")?
                        .unwrap_or(0),
                )
            }

            /// Getter for the [`result` field](TaskSuccessEvent#structfield.result).
            #[inline]
            pub fn result(&self) -> ::planus::Result<self::VarBytesRef<'a>> {
                self.0.access_required(1, "TaskSuccessEvent", "result")
            }
        }

        impl<'a> ::core::fmt::Debug for TaskSuccessEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("TaskSuccessEventRef");
                f.field("task_id", &self.task_id());
                f.field("result", &self.result());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<TaskSuccessEventRef<'a>> for TaskSuccessEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: TaskSuccessEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    task_id: ::core::convert::TryInto::try_into(value.task_id()?)?,
                    result: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.result()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for TaskSuccessEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for TaskSuccessEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[TaskSuccessEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<TaskSuccessEvent>> for TaskSuccessEvent {
            type Value = ::planus::Offset<TaskSuccessEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<TaskSuccessEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for TaskSuccessEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[TaskSuccessEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PlayerSwitchedEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PlayerSwitchedEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1114`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PlayerSwitchedEvent {
            /// The field `new_player` in the table `PlayerSwitchedEvent`
            pub new_player: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `new_auth_token` in the table `PlayerSwitchedEvent`
            pub new_auth_token: ::planus::alloc::boxed::Box<self::AuthToken>,
        }

        impl PlayerSwitchedEvent {
            /// Creates a [PlayerSwitchedEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PlayerSwitchedEventBuilder<()> {
                PlayerSwitchedEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_new_player: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_new_auth_token: impl ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            ) -> ::planus::Offset<Self> {
                let prepared_new_player = field_new_player.prepare(builder);
                let prepared_new_auth_token = field_new_auth_token.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::AuthToken>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_new_player);
                        object_writer.write::<_, _, 4>(&prepared_new_auth_token);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PlayerSwitchedEvent>> for PlayerSwitchedEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PlayerSwitchedEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PlayerSwitchedEvent>> for PlayerSwitchedEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PlayerSwitchedEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PlayerSwitchedEvent> for PlayerSwitchedEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PlayerSwitchedEvent> {
                PlayerSwitchedEvent::create(builder, &self.new_player, &self.new_auth_token)
            }
        }

        /// Builder for serializing an instance of the [PlayerSwitchedEvent] type.
        ///
        /// Can be created using the [PlayerSwitchedEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PlayerSwitchedEventBuilder<State>(State);

        impl PlayerSwitchedEventBuilder<()> {
            /// Setter for the [`new_player` field](PlayerSwitchedEvent#structfield.new_player).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn new_player<T0>(self, value: T0) -> PlayerSwitchedEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                PlayerSwitchedEventBuilder((value,))
            }
        }

        impl<T0> PlayerSwitchedEventBuilder<(T0,)> {
            /// Setter for the [`new_auth_token` field](PlayerSwitchedEvent#structfield.new_auth_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn new_auth_token<T1>(self, value: T1) -> PlayerSwitchedEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
            {
                let (v0,) = self.0;
                PlayerSwitchedEventBuilder((v0, value))
            }
        }

        impl<T0, T1> PlayerSwitchedEventBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PlayerSwitchedEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PlayerSwitchedEvent>
            where
                Self: ::planus::WriteAsOffset<PlayerSwitchedEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
        > ::planus::WriteAs<::planus::Offset<PlayerSwitchedEvent>>
            for PlayerSwitchedEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PlayerSwitchedEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PlayerSwitchedEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
        > ::planus::WriteAsOptional<::planus::Offset<PlayerSwitchedEvent>>
            for PlayerSwitchedEventBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PlayerSwitchedEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PlayerSwitchedEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::AuthToken>>,
        > ::planus::WriteAsOffset<PlayerSwitchedEvent> for PlayerSwitchedEventBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<PlayerSwitchedEvent> {
                let (v0, v1) = &self.0;
                PlayerSwitchedEvent::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [PlayerSwitchedEvent].
        #[derive(Copy, Clone)]
        pub struct PlayerSwitchedEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PlayerSwitchedEventRef<'a> {
            /// Getter for the [`new_player` field](PlayerSwitchedEvent#structfield.new_player).
            #[inline]
            pub fn new_player(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(0, "PlayerSwitchedEvent", "new_player")
            }

            /// Getter for the [`new_auth_token` field](PlayerSwitchedEvent#structfield.new_auth_token).
            #[inline]
            pub fn new_auth_token(&self) -> ::planus::Result<self::AuthTokenRef<'a>> {
                self.0
                    .access_required(1, "PlayerSwitchedEvent", "new_auth_token")
            }
        }

        impl<'a> ::core::fmt::Debug for PlayerSwitchedEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PlayerSwitchedEventRef");
                f.field("new_player", &self.new_player());
                f.field("new_auth_token", &self.new_auth_token());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PlayerSwitchedEventRef<'a>> for PlayerSwitchedEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PlayerSwitchedEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    new_player: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.new_player()?)?,
                    ),
                    new_auth_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.new_auth_token()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PlayerSwitchedEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PlayerSwitchedEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PlayerSwitchedEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PlayerSwitchedEvent>> for PlayerSwitchedEvent {
            type Value = ::planus::Offset<PlayerSwitchedEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PlayerSwitchedEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PlayerSwitchedEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PlayerSwitchedEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `SetConnectionOptionEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `SetConnectionOptionEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1119`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct SetConnectionOptionEvent {
            /// The field `connection_obj` in the table `SetConnectionOptionEvent`
            pub connection_obj: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `option_name` in the table `SetConnectionOptionEvent`
            pub option_name: ::planus::alloc::boxed::Box<self::Symbol>,
            /// The field `value` in the table `SetConnectionOptionEvent`
            pub value: ::planus::alloc::boxed::Box<self::VarBytes>,
        }

        impl SetConnectionOptionEvent {
            /// Creates a [SetConnectionOptionEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> SetConnectionOptionEventBuilder<()> {
                SetConnectionOptionEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_connection_obj: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_option_name: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
                field_value: impl ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            ) -> ::planus::Offset<Self> {
                let prepared_connection_obj = field_connection_obj.prepare(builder);
                let prepared_option_name = field_option_name.prepare(builder);
                let prepared_value = field_value.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::Obj>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);
                table_writer.write_entry::<::planus::Offset<self::VarBytes>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_connection_obj);
                        object_writer.write::<_, _, 4>(&prepared_option_name);
                        object_writer.write::<_, _, 4>(&prepared_value);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<SetConnectionOptionEvent>> for SetConnectionOptionEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SetConnectionOptionEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<SetConnectionOptionEvent>>
            for SetConnectionOptionEvent
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SetConnectionOptionEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<SetConnectionOptionEvent> for SetConnectionOptionEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SetConnectionOptionEvent> {
                SetConnectionOptionEvent::create(
                    builder,
                    &self.connection_obj,
                    &self.option_name,
                    &self.value,
                )
            }
        }

        /// Builder for serializing an instance of the [SetConnectionOptionEvent] type.
        ///
        /// Can be created using the [SetConnectionOptionEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct SetConnectionOptionEventBuilder<State>(State);

        impl SetConnectionOptionEventBuilder<()> {
            /// Setter for the [`connection_obj` field](SetConnectionOptionEvent#structfield.connection_obj).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn connection_obj<T0>(self, value: T0) -> SetConnectionOptionEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                SetConnectionOptionEventBuilder((value,))
            }
        }

        impl<T0> SetConnectionOptionEventBuilder<(T0,)> {
            /// Setter for the [`option_name` field](SetConnectionOptionEvent#structfield.option_name).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn option_name<T1>(self, value: T1) -> SetConnectionOptionEventBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                SetConnectionOptionEventBuilder((v0, value))
            }
        }

        impl<T0, T1> SetConnectionOptionEventBuilder<(T0, T1)> {
            /// Setter for the [`value` field](SetConnectionOptionEvent#structfield.value).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn value<T2>(self, value: T2) -> SetConnectionOptionEventBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            {
                let (v0, v1) = self.0;
                SetConnectionOptionEventBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> SetConnectionOptionEventBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetConnectionOptionEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SetConnectionOptionEvent>
            where
                Self: ::planus::WriteAsOffset<SetConnectionOptionEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAs<::planus::Offset<SetConnectionOptionEvent>>
            for SetConnectionOptionEventBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<SetConnectionOptionEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SetConnectionOptionEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOptional<::planus::Offset<SetConnectionOptionEvent>>
            for SetConnectionOptionEventBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<SetConnectionOptionEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<SetConnectionOptionEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOffset<SetConnectionOptionEvent>
            for SetConnectionOptionEventBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<SetConnectionOptionEvent> {
                let (v0, v1, v2) = &self.0;
                SetConnectionOptionEvent::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [SetConnectionOptionEvent].
        #[derive(Copy, Clone)]
        pub struct SetConnectionOptionEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> SetConnectionOptionEventRef<'a> {
            /// Getter for the [`connection_obj` field](SetConnectionOptionEvent#structfield.connection_obj).
            #[inline]
            pub fn connection_obj(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0
                    .access_required(0, "SetConnectionOptionEvent", "connection_obj")
            }

            /// Getter for the [`option_name` field](SetConnectionOptionEvent#structfield.option_name).
            #[inline]
            pub fn option_name(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0
                    .access_required(1, "SetConnectionOptionEvent", "option_name")
            }

            /// Getter for the [`value` field](SetConnectionOptionEvent#structfield.value).
            #[inline]
            pub fn value(&self) -> ::planus::Result<self::VarBytesRef<'a>> {
                self.0
                    .access_required(2, "SetConnectionOptionEvent", "value")
            }
        }

        impl<'a> ::core::fmt::Debug for SetConnectionOptionEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("SetConnectionOptionEventRef");
                f.field("connection_obj", &self.connection_obj());
                f.field("option_name", &self.option_name());
                f.field("value", &self.value());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<SetConnectionOptionEventRef<'a>> for SetConnectionOptionEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: SetConnectionOptionEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    connection_obj: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.connection_obj()?)?,
                    ),
                    option_name: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.option_name()?)?,
                    ),
                    value: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.value()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for SetConnectionOptionEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for SetConnectionOptionEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[SetConnectionOptionEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<SetConnectionOptionEvent>>
            for SetConnectionOptionEvent
        {
            type Value = ::planus::Offset<SetConnectionOptionEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<SetConnectionOptionEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for SetConnectionOptionEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[SetConnectionOptionEventRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `ClientEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ClientEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1125`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ClientEvent {
            /// The field `event` in the table `ClientEvent`
            pub event: self::ClientEventUnion,
        }

        impl ClientEvent {
            /// Creates a [ClientEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ClientEventBuilder<()> {
                ClientEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_event: impl ::planus::WriteAsUnion<self::ClientEventUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_event = field_event.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientEventUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_event.offset());
                        object_writer.write::<_, _, 1>(&prepared_event.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ClientEvent>> for ClientEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ClientEvent>> for ClientEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ClientEvent> for ClientEvent {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientEvent> {
                ClientEvent::create(builder, &self.event)
            }
        }

        /// Builder for serializing an instance of the [ClientEvent] type.
        ///
        /// Can be created using the [ClientEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ClientEventBuilder<State>(State);

        impl ClientEventBuilder<()> {
            /// Setter for the [`event` field](ClientEvent#structfield.event).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event<T0>(self, value: T0) -> ClientEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::ClientEventUnion>,
            {
                ClientEventBuilder((value,))
            }
        }

        impl<T0> ClientEventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ClientEvent].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientEvent>
            where
                Self: ::planus::WriteAsOffset<ClientEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ClientEventUnion>>
            ::planus::WriteAs<::planus::Offset<ClientEvent>> for ClientEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ClientEvent>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ClientEventUnion>>
            ::planus::WriteAsOptional<::planus::Offset<ClientEvent>> for ClientEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ClientEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ClientEventUnion>>
            ::planus::WriteAsOffset<ClientEvent> for ClientEventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientEvent> {
                let (v0,) = &self.0;
                ClientEvent::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ClientEvent].
        #[derive(Copy, Clone)]
        pub struct ClientEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ClientEventRef<'a> {
            /// Getter for the [`event` field](ClientEvent#structfield.event).
            #[inline]
            pub fn event(&self) -> ::planus::Result<self::ClientEventUnionRef<'a>> {
                self.0.access_union_required(0, "ClientEvent", "event")
            }
        }

        impl<'a> ::core::fmt::Debug for ClientEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ClientEventRef");
                f.field("event", &self.event());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ClientEventRef<'a>> for ClientEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ClientEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    event: ::core::convert::TryInto::try_into(value.event()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ClientEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ClientEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ClientEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ClientEvent>> for ClientEvent {
            type Value = ::planus::Offset<ClientEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ClientEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ClientEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ClientEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `ClientsBroadcastEventUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `ClientsBroadcastEventUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1133`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum ClientsBroadcastEventUnion {
            /// The variant of type `ClientsBroadcastPingPong` in the union `ClientsBroadcastEventUnion`
            ClientsBroadcastPingPong(::planus::alloc::boxed::Box<self::ClientsBroadcastPingPong>),
        }

        impl ClientsBroadcastEventUnion {
            /// Creates a [ClientsBroadcastEventUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ClientsBroadcastEventUnionBuilder<::planus::Uninitialized> {
                ClientsBroadcastEventUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_clients_broadcast_ping_pong(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ClientsBroadcastPingPong>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<ClientsBroadcastEventUnion> for ClientsBroadcastEventUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::ClientsBroadcastPingPong(value) => {
                        Self::create_clients_broadcast_ping_pong(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<ClientsBroadcastEventUnion> for ClientsBroadcastEventUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [ClientsBroadcastEventUnion] type.
        ///
        /// Can be created using the [ClientsBroadcastEventUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ClientsBroadcastEventUnionBuilder<T>(T);

        impl ClientsBroadcastEventUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`ClientsBroadcastPingPong` variant](ClientsBroadcastEventUnion#variant.ClientsBroadcastPingPong).
            #[inline]
            pub fn clients_broadcast_ping_pong<T>(
                self,
                value: T,
            ) -> ClientsBroadcastEventUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::ClientsBroadcastPingPong>,
            {
                ClientsBroadcastEventUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> ClientsBroadcastEventUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [ClientsBroadcastEventUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientsBroadcastEventUnion>
            where
                Self: ::planus::WriteAsUnion<ClientsBroadcastEventUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<ClientsBroadcastEventUnion>
            for ClientsBroadcastEventUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ClientsBroadcastPingPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ClientsBroadcastEventUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ClientsBroadcastEventUnion>
            for ClientsBroadcastEventUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::ClientsBroadcastPingPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ClientsBroadcastEventUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [ClientsBroadcastEventUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum ClientsBroadcastEventUnionRef<'a> {
            ClientsBroadcastPingPong(self::ClientsBroadcastPingPongRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<ClientsBroadcastEventUnionRef<'a>>
            for ClientsBroadcastEventUnion
        {
            type Error = ::planus::Error;

            fn try_from(value: ClientsBroadcastEventUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    ClientsBroadcastEventUnionRef::ClientsBroadcastPingPong(value) => {
                        Self::ClientsBroadcastPingPong(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for ClientsBroadcastEventUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::ClientsBroadcastPingPong(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for ClientsBroadcastEventUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[ClientsBroadcastEventUnionRef]";
        }

        /// The table `ClientsBroadcastPingPong` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ClientsBroadcastPingPong` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1137`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ClientsBroadcastPingPong {
            /// The field `timestamp` in the table `ClientsBroadcastPingPong`
            pub timestamp: u64,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for ClientsBroadcastPingPong {
            fn default() -> Self {
                Self { timestamp: 0 }
            }
        }

        impl ClientsBroadcastPingPong {
            /// Creates a [ClientsBroadcastPingPongBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ClientsBroadcastPingPongBuilder<()> {
                ClientsBroadcastPingPongBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_timestamp = field_timestamp.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                if prepared_timestamp.is_some() {
                    table_writer.write_entry::<u64>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            object_writer.write::<_, _, 8>(&prepared_timestamp);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ClientsBroadcastPingPong>> for ClientsBroadcastPingPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientsBroadcastPingPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ClientsBroadcastPingPong>>
            for ClientsBroadcastPingPong
        {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientsBroadcastPingPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ClientsBroadcastPingPong> for ClientsBroadcastPingPong {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientsBroadcastPingPong> {
                ClientsBroadcastPingPong::create(builder, self.timestamp)
            }
        }

        /// Builder for serializing an instance of the [ClientsBroadcastPingPong] type.
        ///
        /// Can be created using the [ClientsBroadcastPingPong::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ClientsBroadcastPingPongBuilder<State>(State);

        impl ClientsBroadcastPingPongBuilder<()> {
            /// Setter for the [`timestamp` field](ClientsBroadcastPingPong#structfield.timestamp).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp<T0>(self, value: T0) -> ClientsBroadcastPingPongBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<u64, u64>,
            {
                ClientsBroadcastPingPongBuilder((value,))
            }

            /// Sets the [`timestamp` field](ClientsBroadcastPingPong#structfield.timestamp) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timestamp_as_default(
                self,
            ) -> ClientsBroadcastPingPongBuilder<(::planus::DefaultValue,)> {
                self.timestamp(::planus::DefaultValue)
            }
        }

        impl<T0> ClientsBroadcastPingPongBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ClientsBroadcastPingPong].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientsBroadcastPingPong>
            where
                Self: ::planus::WriteAsOffset<ClientsBroadcastPingPong>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAs<::planus::Offset<ClientsBroadcastPingPong>>
            for ClientsBroadcastPingPongBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ClientsBroadcastPingPong>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientsBroadcastPingPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOptional<::planus::Offset<ClientsBroadcastPingPong>>
            for ClientsBroadcastPingPongBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ClientsBroadcastPingPong>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientsBroadcastPingPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsDefault<u64, u64>>
            ::planus::WriteAsOffset<ClientsBroadcastPingPong>
            for ClientsBroadcastPingPongBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientsBroadcastPingPong> {
                let (v0,) = &self.0;
                ClientsBroadcastPingPong::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ClientsBroadcastPingPong].
        #[derive(Copy, Clone)]
        pub struct ClientsBroadcastPingPongRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ClientsBroadcastPingPongRef<'a> {
            /// Getter for the [`timestamp` field](ClientsBroadcastPingPong#structfield.timestamp).
            #[inline]
            pub fn timestamp(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "ClientsBroadcastPingPong", "timestamp")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for ClientsBroadcastPingPongRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ClientsBroadcastPingPongRef");
                f.field("timestamp", &self.timestamp());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ClientsBroadcastPingPongRef<'a>> for ClientsBroadcastPingPong {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ClientsBroadcastPingPongRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ClientsBroadcastPingPongRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ClientsBroadcastPingPongRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ClientsBroadcastPingPongRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ClientsBroadcastPingPong>>
            for ClientsBroadcastPingPong
        {
            type Value = ::planus::Offset<ClientsBroadcastPingPong>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ClientsBroadcastPingPong>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ClientsBroadcastPingPongRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ClientsBroadcastPingPongRef]",
                        "read_as_root",
                        0,
                    )
                })
            }
        }

        /// The table `ClientsBroadcastEvent` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ClientsBroadcastEvent` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1141`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ClientsBroadcastEvent {
            /// The field `event` in the table `ClientsBroadcastEvent`
            pub event: self::ClientsBroadcastEventUnion,
        }

        impl ClientsBroadcastEvent {
            /// Creates a [ClientsBroadcastEventBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ClientsBroadcastEventBuilder<()> {
                ClientsBroadcastEventBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_event: impl ::planus::WriteAsUnion<self::ClientsBroadcastEventUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_event = field_event.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ClientsBroadcastEventUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_event.offset());
                        object_writer.write::<_, _, 1>(&prepared_event.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ClientsBroadcastEvent>> for ClientsBroadcastEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientsBroadcastEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ClientsBroadcastEvent>> for ClientsBroadcastEvent {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientsBroadcastEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ClientsBroadcastEvent> for ClientsBroadcastEvent {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientsBroadcastEvent> {
                ClientsBroadcastEvent::create(builder, &self.event)
            }
        }

        /// Builder for serializing an instance of the [ClientsBroadcastEvent] type.
        ///
        /// Can be created using the [ClientsBroadcastEvent::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ClientsBroadcastEventBuilder<State>(State);

        impl ClientsBroadcastEventBuilder<()> {
            /// Setter for the [`event` field](ClientsBroadcastEvent#structfield.event).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn event<T0>(self, value: T0) -> ClientsBroadcastEventBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::ClientsBroadcastEventUnion>,
            {
                ClientsBroadcastEventBuilder((value,))
            }
        }

        impl<T0> ClientsBroadcastEventBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ClientsBroadcastEvent].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientsBroadcastEvent>
            where
                Self: ::planus::WriteAsOffset<ClientsBroadcastEvent>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ClientsBroadcastEventUnion>>
            ::planus::WriteAs<::planus::Offset<ClientsBroadcastEvent>>
            for ClientsBroadcastEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ClientsBroadcastEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientsBroadcastEvent> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ClientsBroadcastEventUnion>>
            ::planus::WriteAsOptional<::planus::Offset<ClientsBroadcastEvent>>
            for ClientsBroadcastEventBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ClientsBroadcastEvent>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientsBroadcastEvent>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ClientsBroadcastEventUnion>>
            ::planus::WriteAsOffset<ClientsBroadcastEvent> for ClientsBroadcastEventBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<ClientsBroadcastEvent> {
                let (v0,) = &self.0;
                ClientsBroadcastEvent::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ClientsBroadcastEvent].
        #[derive(Copy, Clone)]
        pub struct ClientsBroadcastEventRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ClientsBroadcastEventRef<'a> {
            /// Getter for the [`event` field](ClientsBroadcastEvent#structfield.event).
            #[inline]
            pub fn event(&self) -> ::planus::Result<self::ClientsBroadcastEventUnionRef<'a>> {
                self.0
                    .access_union_required(0, "ClientsBroadcastEvent", "event")
            }
        }

        impl<'a> ::core::fmt::Debug for ClientsBroadcastEventRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ClientsBroadcastEventRef");
                f.field("event", &self.event());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ClientsBroadcastEventRef<'a>> for ClientsBroadcastEvent {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ClientsBroadcastEventRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    event: ::core::convert::TryInto::try_into(value.event()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ClientsBroadcastEventRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ClientsBroadcastEventRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ClientsBroadcastEventRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ClientsBroadcastEvent>>
            for ClientsBroadcastEvent
        {
            type Value = ::planus::Offset<ClientsBroadcastEvent>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ClientsBroadcastEvent>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ClientsBroadcastEventRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ClientsBroadcastEventRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `DaemonToWorkerMessageUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `DaemonToWorkerMessageUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1149`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum DaemonToWorkerMessageUnion {
            /// The variant of type `PingWorkers` in the union `DaemonToWorkerMessageUnion`
            PingWorkers(::planus::alloc::boxed::Box<self::PingWorkers>),

            /// The variant of type `WorkerRequest` in the union `DaemonToWorkerMessageUnion`
            WorkerRequest(::planus::alloc::boxed::Box<self::WorkerRequest>),

            /// The variant of type `PleaseDie` in the union `DaemonToWorkerMessageUnion`
            PleaseDie(::planus::alloc::boxed::Box<self::PleaseDie>),
        }

        impl DaemonToWorkerMessageUnion {
            /// Creates a [DaemonToWorkerMessageUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToWorkerMessageUnionBuilder<::planus::Uninitialized> {
                DaemonToWorkerMessageUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_ping_workers(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PingWorkers>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_worker_request(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerRequest>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_please_die(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::PleaseDie>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<DaemonToWorkerMessageUnion> for DaemonToWorkerMessageUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::PingWorkers(value) => Self::create_ping_workers(builder, value),
                    Self::WorkerRequest(value) => Self::create_worker_request(builder, value),
                    Self::PleaseDie(value) => Self::create_please_die(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<DaemonToWorkerMessageUnion> for DaemonToWorkerMessageUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [DaemonToWorkerMessageUnion] type.
        ///
        /// Can be created using the [DaemonToWorkerMessageUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToWorkerMessageUnionBuilder<T>(T);

        impl DaemonToWorkerMessageUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`PingWorkers` variant](DaemonToWorkerMessageUnion#variant.PingWorkers).
            #[inline]
            pub fn ping_workers<T>(
                self,
                value: T,
            ) -> DaemonToWorkerMessageUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::PingWorkers>,
            {
                DaemonToWorkerMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorkerRequest` variant](DaemonToWorkerMessageUnion#variant.WorkerRequest).
            #[inline]
            pub fn worker_request<T>(
                self,
                value: T,
            ) -> DaemonToWorkerMessageUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerRequest>,
            {
                DaemonToWorkerMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`PleaseDie` variant](DaemonToWorkerMessageUnion#variant.PleaseDie).
            #[inline]
            pub fn please_die<T>(
                self,
                value: T,
            ) -> DaemonToWorkerMessageUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::PleaseDie>,
            {
                DaemonToWorkerMessageUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> DaemonToWorkerMessageUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [DaemonToWorkerMessageUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToWorkerMessageUnion>
            where
                Self: ::planus::WriteAsUnion<DaemonToWorkerMessageUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<DaemonToWorkerMessageUnion>
            for DaemonToWorkerMessageUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::PingWorkers>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToWorkerMessageUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToWorkerMessageUnion>
            for DaemonToWorkerMessageUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::PingWorkers>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToWorkerMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToWorkerMessageUnion>
            for DaemonToWorkerMessageUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerRequest>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToWorkerMessageUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToWorkerMessageUnion>
            for DaemonToWorkerMessageUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerRequest>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToWorkerMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToWorkerMessageUnion>
            for DaemonToWorkerMessageUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::PleaseDie>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToWorkerMessageUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToWorkerMessageUnion>
            for DaemonToWorkerMessageUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::PleaseDie>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToWorkerMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [DaemonToWorkerMessageUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum DaemonToWorkerMessageUnionRef<'a> {
            PingWorkers(self::PingWorkersRef<'a>),
            WorkerRequest(self::WorkerRequestRef<'a>),
            PleaseDie(self::PleaseDieRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<DaemonToWorkerMessageUnionRef<'a>>
            for DaemonToWorkerMessageUnion
        {
            type Error = ::planus::Error;

            fn try_from(value: DaemonToWorkerMessageUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    DaemonToWorkerMessageUnionRef::PingWorkers(value) => {
                        Self::PingWorkers(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToWorkerMessageUnionRef::WorkerRequest(value) => {
                        Self::WorkerRequest(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToWorkerMessageUnionRef::PleaseDie(value) => {
                        Self::PleaseDie(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for DaemonToWorkerMessageUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::PingWorkers(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::WorkerRequest(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::PleaseDie(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for DaemonToWorkerMessageUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[DaemonToWorkerMessageUnionRef]";
        }

        /// The table `PingWorkers` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PingWorkers` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1155`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PingWorkers {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PingWorkers {
            fn default() -> Self {
                Self {}
            }
        }

        impl PingWorkers {
            /// Creates a [PingWorkersBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PingWorkersBuilder<()> {
                PingWorkersBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PingWorkers>> for PingWorkers {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PingWorkers> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PingWorkers>> for PingWorkers {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PingWorkers>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PingWorkers> for PingWorkers {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PingWorkers> {
                PingWorkers::create(builder)
            }
        }

        /// Builder for serializing an instance of the [PingWorkers] type.
        ///
        /// Can be created using the [PingWorkers::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PingWorkersBuilder<State>(State);

        impl PingWorkersBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PingWorkers].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PingWorkers>
            where
                Self: ::planus::WriteAsOffset<PingWorkers>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PingWorkers>> for PingWorkersBuilder<()> {
            type Prepared = ::planus::Offset<PingWorkers>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PingWorkers> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PingWorkers>> for PingWorkersBuilder<()> {
            type Prepared = ::planus::Offset<PingWorkers>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PingWorkers>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PingWorkers> for PingWorkersBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PingWorkers> {
                PingWorkers::create(builder)
            }
        }

        /// Reference to a deserialized [PingWorkers].
        #[derive(Copy, Clone)]
        pub struct PingWorkersRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PingWorkersRef<'a> {}

        impl<'a> ::core::fmt::Debug for PingWorkersRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PingWorkersRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PingWorkersRef<'a>> for PingWorkers {
            type Error = ::planus::Error;

            fn try_from(_value: PingWorkersRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for PingWorkersRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PingWorkersRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PingWorkersRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PingWorkers>> for PingWorkers {
            type Value = ::planus::Offset<PingWorkers>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PingWorkers>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PingWorkersRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PingWorkersRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerRequest` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerRequest` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1158`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerRequest {
            /// The field `worker_id` in the table `WorkerRequest`
            pub worker_id: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `token` in the table `WorkerRequest`
            pub token: ::planus::alloc::boxed::Box<self::WorkerToken>,
            /// The field `id` in the table `WorkerRequest`
            pub id: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `perms` in the table `WorkerRequest`
            pub perms: ::planus::alloc::boxed::Box<self::Obj>,
            /// The field `request` in the table `WorkerRequest`
            pub request: ::planus::alloc::vec::Vec<self::VarBytes>,
            /// The field `timeout_ms` in the table `WorkerRequest`
            pub timeout_ms: u64,
        }

        impl WorkerRequest {
            /// Creates a [WorkerRequestBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerRequestBuilder<()> {
                WorkerRequestBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_worker_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_token: impl ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
                field_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_perms: impl ::planus::WriteAs<::planus::Offset<self::Obj>>,
                field_request: impl ::planus::WriteAs<
                    ::planus::Offset<[::planus::Offset<self::VarBytes>]>,
                >,
                field_timeout_ms: impl ::planus::WriteAsDefault<u64, u64>,
            ) -> ::planus::Offset<Self> {
                let prepared_worker_id = field_worker_id.prepare(builder);
                let prepared_token = field_token.prepare(builder);
                let prepared_id = field_id.prepare(builder);
                let prepared_perms = field_perms.prepare(builder);
                let prepared_request = field_request.prepare(builder);
                let prepared_timeout_ms = field_timeout_ms.prepare(builder, &0);

                let mut table_writer: ::planus::table_writer::TableWriter<16> =
                    ::core::default::Default::default();
                if prepared_timeout_ms.is_some() {
                    table_writer.write_entry::<u64>(5);
                }
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(0);
                table_writer.write_entry::<::planus::Offset<self::WorkerToken>>(1);
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(2);
                table_writer.write_entry::<::planus::Offset<self::Obj>>(3);
                table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::VarBytes>]>>(4);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_timeout_ms) =
                            prepared_timeout_ms
                        {
                            object_writer.write::<_, _, 8>(&prepared_timeout_ms);
                        }
                        object_writer.write::<_, _, 4>(&prepared_worker_id);
                        object_writer.write::<_, _, 4>(&prepared_token);
                        object_writer.write::<_, _, 4>(&prepared_id);
                        object_writer.write::<_, _, 4>(&prepared_perms);
                        object_writer.write::<_, _, 4>(&prepared_request);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerRequest>> for WorkerRequest {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerRequest> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerRequest>> for WorkerRequest {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerRequest>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerRequest> for WorkerRequest {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerRequest> {
                WorkerRequest::create(
                    builder,
                    &self.worker_id,
                    &self.token,
                    &self.id,
                    &self.perms,
                    &self.request,
                    self.timeout_ms,
                )
            }
        }

        /// Builder for serializing an instance of the [WorkerRequest] type.
        ///
        /// Can be created using the [WorkerRequest::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerRequestBuilder<State>(State);

        impl WorkerRequestBuilder<()> {
            /// Setter for the [`worker_id` field](WorkerRequest#structfield.worker_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn worker_id<T0>(self, value: T0) -> WorkerRequestBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                WorkerRequestBuilder((value,))
            }
        }

        impl<T0> WorkerRequestBuilder<(T0,)> {
            /// Setter for the [`token` field](WorkerRequest#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T1>(self, value: T1) -> WorkerRequestBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            {
                let (v0,) = self.0;
                WorkerRequestBuilder((v0, value))
            }
        }

        impl<T0, T1> WorkerRequestBuilder<(T0, T1)> {
            /// Setter for the [`id` field](WorkerRequest#structfield.id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id<T2>(self, value: T2) -> WorkerRequestBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                let (v0, v1) = self.0;
                WorkerRequestBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> WorkerRequestBuilder<(T0, T1, T2)> {
            /// Setter for the [`perms` field](WorkerRequest#structfield.perms).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn perms<T3>(self, value: T3) -> WorkerRequestBuilder<(T0, T1, T2, T3)>
            where
                T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            {
                let (v0, v1, v2) = self.0;
                WorkerRequestBuilder((v0, v1, v2, value))
            }
        }

        impl<T0, T1, T2, T3> WorkerRequestBuilder<(T0, T1, T2, T3)> {
            /// Setter for the [`request` field](WorkerRequest#structfield.request).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn request<T4>(self, value: T4) -> WorkerRequestBuilder<(T0, T1, T2, T3, T4)>
            where
                T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            {
                let (v0, v1, v2, v3) = self.0;
                WorkerRequestBuilder((v0, v1, v2, v3, value))
            }
        }

        impl<T0, T1, T2, T3, T4> WorkerRequestBuilder<(T0, T1, T2, T3, T4)> {
            /// Setter for the [`timeout_ms` field](WorkerRequest#structfield.timeout_ms).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timeout_ms<T5>(self, value: T5) -> WorkerRequestBuilder<(T0, T1, T2, T3, T4, T5)>
            where
                T5: ::planus::WriteAsDefault<u64, u64>,
            {
                let (v0, v1, v2, v3, v4) = self.0;
                WorkerRequestBuilder((v0, v1, v2, v3, v4, value))
            }

            /// Sets the [`timeout_ms` field](WorkerRequest#structfield.timeout_ms) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn timeout_ms_as_default(
                self,
            ) -> WorkerRequestBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                self.timeout_ms(::planus::DefaultValue)
            }
        }

        impl<T0, T1, T2, T3, T4, T5> WorkerRequestBuilder<(T0, T1, T2, T3, T4, T5)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerRequest].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerRequest>
            where
                Self: ::planus::WriteAsOffset<WorkerRequest>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            T5: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAs<::planus::Offset<WorkerRequest>>
            for WorkerRequestBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            type Prepared = ::planus::Offset<WorkerRequest>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerRequest> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            T5: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAsOptional<::planus::Offset<WorkerRequest>>
            for WorkerRequestBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            type Prepared = ::planus::Offset<WorkerRequest>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerRequest>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T1: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T2: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T3: ::planus::WriteAs<::planus::Offset<self::Obj>>,
            T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::VarBytes>]>>,
            T5: ::planus::WriteAsDefault<u64, u64>,
        > ::planus::WriteAsOffset<WorkerRequest>
            for WorkerRequestBuilder<(T0, T1, T2, T3, T4, T5)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerRequest> {
                let (v0, v1, v2, v3, v4, v5) = &self.0;
                WorkerRequest::create(builder, v0, v1, v2, v3, v4, v5)
            }
        }

        /// Reference to a deserialized [WorkerRequest].
        #[derive(Copy, Clone)]
        pub struct WorkerRequestRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerRequestRef<'a> {
            /// Getter for the [`worker_id` field](WorkerRequest#structfield.worker_id).
            #[inline]
            pub fn worker_id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(0, "WorkerRequest", "worker_id")
            }

            /// Getter for the [`token` field](WorkerRequest#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<self::WorkerTokenRef<'a>> {
                self.0.access_required(1, "WorkerRequest", "token")
            }

            /// Getter for the [`id` field](WorkerRequest#structfield.id).
            #[inline]
            pub fn id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(2, "WorkerRequest", "id")
            }

            /// Getter for the [`perms` field](WorkerRequest#structfield.perms).
            #[inline]
            pub fn perms(&self) -> ::planus::Result<self::ObjRef<'a>> {
                self.0.access_required(3, "WorkerRequest", "perms")
            }

            /// Getter for the [`request` field](WorkerRequest#structfield.request).
            #[inline]
            pub fn request(
                &self,
            ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VarBytesRef<'a>>>>
            {
                self.0.access_required(4, "WorkerRequest", "request")
            }

            /// Getter for the [`timeout_ms` field](WorkerRequest#structfield.timeout_ms).
            #[inline]
            pub fn timeout_ms(&self) -> ::planus::Result<u64> {
                ::core::result::Result::Ok(
                    self.0
                        .access(5, "WorkerRequest", "timeout_ms")?
                        .unwrap_or(0),
                )
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerRequestRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerRequestRef");
                f.field("worker_id", &self.worker_id());
                f.field("token", &self.token());
                f.field("id", &self.id());
                f.field("perms", &self.perms());
                f.field("request", &self.request());
                f.field("timeout_ms", &self.timeout_ms());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerRequestRef<'a>> for WorkerRequest {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerRequestRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    worker_id: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.worker_id()?)?,
                    ),
                    token: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.token()?,
                    )?),
                    id: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.id()?,
                    )?),
                    perms: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.perms()?,
                    )?),
                    request: value.request()?.to_vec_result()?,
                    timeout_ms: ::core::convert::TryInto::try_into(value.timeout_ms()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerRequestRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerRequestRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerRequestRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerRequest>> for WorkerRequest {
            type Value = ::planus::Offset<WorkerRequest>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerRequest>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerRequestRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerRequestRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `PleaseDie` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `PleaseDie` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1167`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct PleaseDie {
            /// The field `token` in the table `PleaseDie`
            pub token: ::planus::alloc::boxed::Box<self::WorkerToken>,
            /// The field `worker_id` in the table `PleaseDie`
            pub worker_id: ::planus::alloc::boxed::Box<self::Uuid>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for PleaseDie {
            fn default() -> Self {
                Self {
                    token: ::core::default::Default::default(),
                    worker_id: ::core::default::Default::default(),
                }
            }
        }

        impl PleaseDie {
            /// Creates a [PleaseDieBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> PleaseDieBuilder<()> {
                PleaseDieBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
                field_worker_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);
                let prepared_worker_id = field_worker_id.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorkerToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                        object_writer.write::<_, _, 4>(&prepared_worker_id);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<PleaseDie>> for PleaseDie {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PleaseDie> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<PleaseDie>> for PleaseDie {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PleaseDie>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<PleaseDie> for PleaseDie {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PleaseDie> {
                PleaseDie::create(builder, &self.token, &self.worker_id)
            }
        }

        /// Builder for serializing an instance of the [PleaseDie] type.
        ///
        /// Can be created using the [PleaseDie::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct PleaseDieBuilder<State>(State);

        impl PleaseDieBuilder<()> {
            /// Setter for the [`token` field](PleaseDie#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> PleaseDieBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            {
                PleaseDieBuilder((value,))
            }
        }

        impl<T0> PleaseDieBuilder<(T0,)> {
            /// Setter for the [`worker_id` field](PleaseDie#structfield.worker_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn worker_id<T1>(self, value: T1) -> PleaseDieBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                let (v0,) = self.0;
                PleaseDieBuilder((v0, value))
            }
        }

        impl<T0, T1> PleaseDieBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PleaseDie].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PleaseDie>
            where
                Self: ::planus::WriteAsOffset<PleaseDie>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
        > ::planus::WriteAs<::planus::Offset<PleaseDie>> for PleaseDieBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PleaseDie>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PleaseDie> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
        > ::planus::WriteAsOptional<::planus::Offset<PleaseDie>> for PleaseDieBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<PleaseDie>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<PleaseDie>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
        > ::planus::WriteAsOffset<PleaseDie> for PleaseDieBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PleaseDie> {
                let (v0, v1) = &self.0;
                PleaseDie::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [PleaseDie].
        #[derive(Copy, Clone)]
        pub struct PleaseDieRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> PleaseDieRef<'a> {
            /// Getter for the [`token` field](PleaseDie#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<self::WorkerTokenRef<'a>> {
                self.0.access_required(0, "PleaseDie", "token")
            }

            /// Getter for the [`worker_id` field](PleaseDie#structfield.worker_id).
            #[inline]
            pub fn worker_id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(1, "PleaseDie", "worker_id")
            }
        }

        impl<'a> ::core::fmt::Debug for PleaseDieRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("PleaseDieRef");
                f.field("token", &self.token());
                f.field("worker_id", &self.worker_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<PleaseDieRef<'a>> for PleaseDie {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: PleaseDieRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.token()?,
                    )?),
                    worker_id: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.worker_id()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for PleaseDieRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for PleaseDieRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[PleaseDieRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<PleaseDie>> for PleaseDie {
            type Value = ::planus::Offset<PleaseDie>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<PleaseDie>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for PleaseDieRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[PleaseDieRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DaemonToWorkerMessage` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DaemonToWorkerMessage` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1172`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DaemonToWorkerMessage {
            /// The field `message` in the table `DaemonToWorkerMessage`
            pub message: self::DaemonToWorkerMessageUnion,
        }

        impl DaemonToWorkerMessage {
            /// Creates a [DaemonToWorkerMessageBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToWorkerMessageBuilder<()> {
                DaemonToWorkerMessageBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAsUnion<self::DaemonToWorkerMessageUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::DaemonToWorkerMessageUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message.offset());
                        object_writer.write::<_, _, 1>(&prepared_message.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DaemonToWorkerMessage>> for DaemonToWorkerMessage {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToWorkerMessage> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DaemonToWorkerMessage>> for DaemonToWorkerMessage {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToWorkerMessage>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DaemonToWorkerMessage> for DaemonToWorkerMessage {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToWorkerMessage> {
                DaemonToWorkerMessage::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [DaemonToWorkerMessage] type.
        ///
        /// Can be created using the [DaemonToWorkerMessage::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToWorkerMessageBuilder<State>(State);

        impl DaemonToWorkerMessageBuilder<()> {
            /// Setter for the [`message` field](DaemonToWorkerMessage#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> DaemonToWorkerMessageBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::DaemonToWorkerMessageUnion>,
            {
                DaemonToWorkerMessageBuilder((value,))
            }
        }

        impl<T0> DaemonToWorkerMessageBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DaemonToWorkerMessage].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToWorkerMessage>
            where
                Self: ::planus::WriteAsOffset<DaemonToWorkerMessage>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToWorkerMessageUnion>>
            ::planus::WriteAs<::planus::Offset<DaemonToWorkerMessage>>
            for DaemonToWorkerMessageBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DaemonToWorkerMessage>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToWorkerMessage> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToWorkerMessageUnion>>
            ::planus::WriteAsOptional<::planus::Offset<DaemonToWorkerMessage>>
            for DaemonToWorkerMessageBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DaemonToWorkerMessage>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToWorkerMessage>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToWorkerMessageUnion>>
            ::planus::WriteAsOffset<DaemonToWorkerMessage> for DaemonToWorkerMessageBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToWorkerMessage> {
                let (v0,) = &self.0;
                DaemonToWorkerMessage::create(builder, v0)
            }
        }

        /// Reference to a deserialized [DaemonToWorkerMessage].
        #[derive(Copy, Clone)]
        pub struct DaemonToWorkerMessageRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DaemonToWorkerMessageRef<'a> {
            /// Getter for the [`message` field](DaemonToWorkerMessage#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<self::DaemonToWorkerMessageUnionRef<'a>> {
                self.0
                    .access_union_required(0, "DaemonToWorkerMessage", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for DaemonToWorkerMessageRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DaemonToWorkerMessageRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DaemonToWorkerMessageRef<'a>> for DaemonToWorkerMessage {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DaemonToWorkerMessageRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::TryInto::try_into(value.message()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DaemonToWorkerMessageRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DaemonToWorkerMessageRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DaemonToWorkerMessageRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DaemonToWorkerMessage>>
            for DaemonToWorkerMessage
        {
            type Value = ::planus::Offset<DaemonToWorkerMessage>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DaemonToWorkerMessage>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DaemonToWorkerMessageRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DaemonToWorkerMessageRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `WorkerToDaemonMessageUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `WorkerToDaemonMessageUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1176`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum WorkerToDaemonMessageUnion {
            /// The variant of type `AttachWorker` in the union `WorkerToDaemonMessageUnion`
            AttachWorker(::planus::alloc::boxed::Box<self::AttachWorker>),

            /// The variant of type `WorkerPong` in the union `WorkerToDaemonMessageUnion`
            WorkerPong(::planus::alloc::boxed::Box<self::WorkerPong>),

            /// The variant of type `DetachWorker` in the union `WorkerToDaemonMessageUnion`
            DetachWorker(::planus::alloc::boxed::Box<self::DetachWorker>),

            /// The variant of type `RequestResult` in the union `WorkerToDaemonMessageUnion`
            RequestResult(::planus::alloc::boxed::Box<self::RequestResult>),

            /// The variant of type `RequestError` in the union `WorkerToDaemonMessageUnion`
            RequestError(::planus::alloc::boxed::Box<self::RequestError>),
        }

        impl WorkerToDaemonMessageUnion {
            /// Creates a [WorkerToDaemonMessageUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerToDaemonMessageUnionBuilder<::planus::Uninitialized> {
                WorkerToDaemonMessageUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_attach_worker(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::AttachWorker>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_worker_pong(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerPong>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_detach_worker(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::DetachWorker>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_request_result(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RequestResult>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_request_error(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::RequestError>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<WorkerToDaemonMessageUnion> for WorkerToDaemonMessageUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::AttachWorker(value) => Self::create_attach_worker(builder, value),
                    Self::WorkerPong(value) => Self::create_worker_pong(builder, value),
                    Self::DetachWorker(value) => Self::create_detach_worker(builder, value),
                    Self::RequestResult(value) => Self::create_request_result(builder, value),
                    Self::RequestError(value) => Self::create_request_error(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<WorkerToDaemonMessageUnion> for WorkerToDaemonMessageUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [WorkerToDaemonMessageUnion] type.
        ///
        /// Can be created using the [WorkerToDaemonMessageUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerToDaemonMessageUnionBuilder<T>(T);

        impl WorkerToDaemonMessageUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`AttachWorker` variant](WorkerToDaemonMessageUnion#variant.AttachWorker).
            #[inline]
            pub fn attach_worker<T>(
                self,
                value: T,
            ) -> WorkerToDaemonMessageUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::AttachWorker>,
            {
                WorkerToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorkerPong` variant](WorkerToDaemonMessageUnion#variant.WorkerPong).
            #[inline]
            pub fn worker_pong<T>(
                self,
                value: T,
            ) -> WorkerToDaemonMessageUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerPong>,
            {
                WorkerToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`DetachWorker` variant](WorkerToDaemonMessageUnion#variant.DetachWorker).
            #[inline]
            pub fn detach_worker<T>(
                self,
                value: T,
            ) -> WorkerToDaemonMessageUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::DetachWorker>,
            {
                WorkerToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RequestResult` variant](WorkerToDaemonMessageUnion#variant.RequestResult).
            #[inline]
            pub fn request_result<T>(
                self,
                value: T,
            ) -> WorkerToDaemonMessageUnionBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::RequestResult>,
            {
                WorkerToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`RequestError` variant](WorkerToDaemonMessageUnion#variant.RequestError).
            #[inline]
            pub fn request_error<T>(
                self,
                value: T,
            ) -> WorkerToDaemonMessageUnionBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::RequestError>,
            {
                WorkerToDaemonMessageUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> WorkerToDaemonMessageUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [WorkerToDaemonMessageUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerToDaemonMessageUnion>
            where
                Self: ::planus::WriteAsUnion<WorkerToDaemonMessageUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<WorkerToDaemonMessageUnion>
            for WorkerToDaemonMessageUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::AttachWorker>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerToDaemonMessageUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerToDaemonMessageUnion>
            for WorkerToDaemonMessageUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::AttachWorker>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorkerToDaemonMessageUnion>
            for WorkerToDaemonMessageUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerToDaemonMessageUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerToDaemonMessageUnion>
            for WorkerToDaemonMessageUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerPong>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorkerToDaemonMessageUnion>
            for WorkerToDaemonMessageUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::DetachWorker>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerToDaemonMessageUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerToDaemonMessageUnion>
            for WorkerToDaemonMessageUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::DetachWorker>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorkerToDaemonMessageUnion>
            for WorkerToDaemonMessageUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestResult>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerToDaemonMessageUnion> {
                ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerToDaemonMessageUnion>
            for WorkerToDaemonMessageUnionBuilder<::planus::Initialized<4, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestResult>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<WorkerToDaemonMessageUnion>
            for WorkerToDaemonMessageUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<WorkerToDaemonMessageUnion> {
                ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<WorkerToDaemonMessageUnion>
            for WorkerToDaemonMessageUnionBuilder<::planus::Initialized<5, T>>
        where
            T: ::planus::WriteAsOffset<self::RequestError>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<WorkerToDaemonMessageUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [WorkerToDaemonMessageUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum WorkerToDaemonMessageUnionRef<'a> {
            AttachWorker(self::AttachWorkerRef<'a>),
            WorkerPong(self::WorkerPongRef<'a>),
            DetachWorker(self::DetachWorkerRef<'a>),
            RequestResult(self::RequestResultRef<'a>),
            RequestError(self::RequestErrorRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<WorkerToDaemonMessageUnionRef<'a>>
            for WorkerToDaemonMessageUnion
        {
            type Error = ::planus::Error;

            fn try_from(value: WorkerToDaemonMessageUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    WorkerToDaemonMessageUnionRef::AttachWorker(value) => {
                        Self::AttachWorker(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorkerToDaemonMessageUnionRef::WorkerPong(value) => {
                        Self::WorkerPong(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorkerToDaemonMessageUnionRef::DetachWorker(value) => {
                        Self::DetachWorker(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorkerToDaemonMessageUnionRef::RequestResult(value) => {
                        Self::RequestResult(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    WorkerToDaemonMessageUnionRef::RequestError(value) => {
                        Self::RequestError(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for WorkerToDaemonMessageUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::AttachWorker(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::WorkerPong(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::DetachWorker(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    4 => ::core::result::Result::Ok(Self::RequestResult(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    5 => ::core::result::Result::Ok(Self::RequestError(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for WorkerToDaemonMessageUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[WorkerToDaemonMessageUnionRef]";
        }

        /// The table `AttachWorker` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `AttachWorker` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1184`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct AttachWorker {
            /// The field `token` in the table `AttachWorker`
            pub token: ::planus::alloc::boxed::Box<self::WorkerToken>,
            /// The field `worker_type` in the table `AttachWorker`
            pub worker_type: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for AttachWorker {
            fn default() -> Self {
                Self {
                    token: ::core::default::Default::default(),
                    worker_type: ::core::default::Default::default(),
                }
            }
        }

        impl AttachWorker {
            /// Creates a [AttachWorkerBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> AttachWorkerBuilder<()> {
                AttachWorkerBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
                field_worker_type: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);
                let prepared_worker_type = field_worker_type.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorkerToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                        object_writer.write::<_, _, 4>(&prepared_worker_type);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<AttachWorker>> for AttachWorker {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AttachWorker> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<AttachWorker>> for AttachWorker {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AttachWorker>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<AttachWorker> for AttachWorker {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AttachWorker> {
                AttachWorker::create(builder, &self.token, &self.worker_type)
            }
        }

        /// Builder for serializing an instance of the [AttachWorker] type.
        ///
        /// Can be created using the [AttachWorker::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct AttachWorkerBuilder<State>(State);

        impl AttachWorkerBuilder<()> {
            /// Setter for the [`token` field](AttachWorker#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> AttachWorkerBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            {
                AttachWorkerBuilder((value,))
            }
        }

        impl<T0> AttachWorkerBuilder<(T0,)> {
            /// Setter for the [`worker_type` field](AttachWorker#structfield.worker_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn worker_type<T1>(self, value: T1) -> AttachWorkerBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                AttachWorkerBuilder((v0, value))
            }
        }

        impl<T0, T1> AttachWorkerBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AttachWorker].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<AttachWorker>
            where
                Self: ::planus::WriteAsOffset<AttachWorker>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<AttachWorker>> for AttachWorkerBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<AttachWorker>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AttachWorker> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<AttachWorker>>
            for AttachWorkerBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<AttachWorker>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<AttachWorker>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<AttachWorker> for AttachWorkerBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<AttachWorker> {
                let (v0, v1) = &self.0;
                AttachWorker::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [AttachWorker].
        #[derive(Copy, Clone)]
        pub struct AttachWorkerRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> AttachWorkerRef<'a> {
            /// Getter for the [`token` field](AttachWorker#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<self::WorkerTokenRef<'a>> {
                self.0.access_required(0, "AttachWorker", "token")
            }

            /// Getter for the [`worker_type` field](AttachWorker#structfield.worker_type).
            #[inline]
            pub fn worker_type(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(1, "AttachWorker", "worker_type")
            }
        }

        impl<'a> ::core::fmt::Debug for AttachWorkerRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("AttachWorkerRef");
                f.field("token", &self.token());
                f.field("worker_type", &self.worker_type());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<AttachWorkerRef<'a>> for AttachWorker {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: AttachWorkerRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.token()?,
                    )?),
                    worker_type: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.worker_type()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for AttachWorkerRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for AttachWorkerRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[AttachWorkerRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<AttachWorker>> for AttachWorker {
            type Value = ::planus::Offset<AttachWorker>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<AttachWorker>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for AttachWorkerRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[AttachWorkerRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerPong` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerPong` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1189`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerPong {
            /// The field `token` in the table `WorkerPong`
            pub token: ::planus::alloc::boxed::Box<self::WorkerToken>,
            /// The field `worker_type` in the table `WorkerPong`
            pub worker_type: ::planus::alloc::boxed::Box<self::Symbol>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerPong {
            fn default() -> Self {
                Self {
                    token: ::core::default::Default::default(),
                    worker_type: ::core::default::Default::default(),
                }
            }
        }

        impl WorkerPong {
            /// Creates a [WorkerPongBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerPongBuilder<()> {
                WorkerPongBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
                field_worker_type: impl ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);
                let prepared_worker_type = field_worker_type.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorkerToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::Symbol>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                        object_writer.write::<_, _, 4>(&prepared_worker_type);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerPong>> for WorkerPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerPong>> for WorkerPong {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerPong> for WorkerPong {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerPong> {
                WorkerPong::create(builder, &self.token, &self.worker_type)
            }
        }

        /// Builder for serializing an instance of the [WorkerPong] type.
        ///
        /// Can be created using the [WorkerPong::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerPongBuilder<State>(State);

        impl WorkerPongBuilder<()> {
            /// Setter for the [`token` field](WorkerPong#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> WorkerPongBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            {
                WorkerPongBuilder((value,))
            }
        }

        impl<T0> WorkerPongBuilder<(T0,)> {
            /// Setter for the [`worker_type` field](WorkerPong#structfield.worker_type).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn worker_type<T1>(self, value: T1) -> WorkerPongBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
            {
                let (v0,) = self.0;
                WorkerPongBuilder((v0, value))
            }
        }

        impl<T0, T1> WorkerPongBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerPong].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerPong>
            where
                Self: ::planus::WriteAsOffset<WorkerPong>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAs<::planus::Offset<WorkerPong>> for WorkerPongBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<WorkerPong>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerPong> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOptional<::planus::Offset<WorkerPong>> for WorkerPongBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<WorkerPong>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerPong>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Symbol>>,
        > ::planus::WriteAsOffset<WorkerPong> for WorkerPongBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerPong> {
                let (v0, v1) = &self.0;
                WorkerPong::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [WorkerPong].
        #[derive(Copy, Clone)]
        pub struct WorkerPongRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerPongRef<'a> {
            /// Getter for the [`token` field](WorkerPong#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<self::WorkerTokenRef<'a>> {
                self.0.access_required(0, "WorkerPong", "token")
            }

            /// Getter for the [`worker_type` field](WorkerPong#structfield.worker_type).
            #[inline]
            pub fn worker_type(&self) -> ::planus::Result<self::SymbolRef<'a>> {
                self.0.access_required(1, "WorkerPong", "worker_type")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerPongRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerPongRef");
                f.field("token", &self.token());
                f.field("worker_type", &self.worker_type());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerPongRef<'a>> for WorkerPong {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerPongRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.token()?,
                    )?),
                    worker_type: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.worker_type()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerPongRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerPongRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerPongRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerPong>> for WorkerPong {
            type Value = ::planus::Offset<WorkerPong>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerPong>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerPongRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerPongRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DetachWorker` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DetachWorker` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1194`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DetachWorker {
            /// The field `token` in the table `DetachWorker`
            pub token: ::planus::alloc::boxed::Box<self::WorkerToken>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for DetachWorker {
            fn default() -> Self {
                Self {
                    token: ::core::default::Default::default(),
                }
            }
        }

        impl DetachWorker {
            /// Creates a [DetachWorkerBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DetachWorkerBuilder<()> {
                DetachWorkerBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorkerToken>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DetachWorker>> for DetachWorker {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DetachWorker> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DetachWorker>> for DetachWorker {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DetachWorker>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DetachWorker> for DetachWorker {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DetachWorker> {
                DetachWorker::create(builder, &self.token)
            }
        }

        /// Builder for serializing an instance of the [DetachWorker] type.
        ///
        /// Can be created using the [DetachWorker::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DetachWorkerBuilder<State>(State);

        impl DetachWorkerBuilder<()> {
            /// Setter for the [`token` field](DetachWorker#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> DetachWorkerBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            {
                DetachWorkerBuilder((value,))
            }
        }

        impl<T0> DetachWorkerBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DetachWorker].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<DetachWorker>
            where
                Self: ::planus::WriteAsOffset<DetachWorker>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>>
            ::planus::WriteAs<::planus::Offset<DetachWorker>> for DetachWorkerBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DetachWorker>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DetachWorker> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>>
            ::planus::WriteAsOptional<::planus::Offset<DetachWorker>>
            for DetachWorkerBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DetachWorker>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DetachWorker>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>>
            ::planus::WriteAsOffset<DetachWorker> for DetachWorkerBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<DetachWorker> {
                let (v0,) = &self.0;
                DetachWorker::create(builder, v0)
            }
        }

        /// Reference to a deserialized [DetachWorker].
        #[derive(Copy, Clone)]
        pub struct DetachWorkerRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DetachWorkerRef<'a> {
            /// Getter for the [`token` field](DetachWorker#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<self::WorkerTokenRef<'a>> {
                self.0.access_required(0, "DetachWorker", "token")
            }
        }

        impl<'a> ::core::fmt::Debug for DetachWorkerRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DetachWorkerRef");
                f.field("token", &self.token());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DetachWorkerRef<'a>> for DetachWorker {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DetachWorkerRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.token()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DetachWorkerRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DetachWorkerRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DetachWorkerRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DetachWorker>> for DetachWorker {
            type Value = ::planus::Offset<DetachWorker>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DetachWorker>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DetachWorkerRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DetachWorkerRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `RequestResult` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RequestResult` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1198`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RequestResult {
            /// The field `token` in the table `RequestResult`
            pub token: ::planus::alloc::boxed::Box<self::WorkerToken>,
            /// The field `id` in the table `RequestResult`
            pub id: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `result` in the table `RequestResult`
            pub result: ::planus::alloc::boxed::Box<self::VarBytes>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for RequestResult {
            fn default() -> Self {
                Self {
                    token: ::core::default::Default::default(),
                    id: ::core::default::Default::default(),
                    result: ::core::default::Default::default(),
                }
            }
        }

        impl RequestResult {
            /// Creates a [RequestResultBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RequestResultBuilder<()> {
                RequestResultBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
                field_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_result: impl ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);
                let prepared_id = field_id.prepare(builder);
                let prepared_result = field_result.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorkerToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(1);
                table_writer.write_entry::<::planus::Offset<self::VarBytes>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                        object_writer.write::<_, _, 4>(&prepared_id);
                        object_writer.write::<_, _, 4>(&prepared_result);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RequestResult>> for RequestResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RequestResult>> for RequestResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RequestResult> for RequestResult {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestResult> {
                RequestResult::create(builder, &self.token, &self.id, &self.result)
            }
        }

        /// Builder for serializing an instance of the [RequestResult] type.
        ///
        /// Can be created using the [RequestResult::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RequestResultBuilder<State>(State);

        impl RequestResultBuilder<()> {
            /// Setter for the [`token` field](RequestResult#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> RequestResultBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            {
                RequestResultBuilder((value,))
            }
        }

        impl<T0> RequestResultBuilder<(T0,)> {
            /// Setter for the [`id` field](RequestResult#structfield.id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id<T1>(self, value: T1) -> RequestResultBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                let (v0,) = self.0;
                RequestResultBuilder((v0, value))
            }
        }

        impl<T0, T1> RequestResultBuilder<(T0, T1)> {
            /// Setter for the [`result` field](RequestResult#structfield.result).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn result<T2>(self, value: T2) -> RequestResultBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
            {
                let (v0, v1) = self.0;
                RequestResultBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> RequestResultBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RequestResult].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestResult>
            where
                Self: ::planus::WriteAsOffset<RequestResult>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAs<::planus::Offset<RequestResult>>
            for RequestResultBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RequestResult>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOptional<::planus::Offset<RequestResult>>
            for RequestResultBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RequestResult>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T2: ::planus::WriteAs<::planus::Offset<self::VarBytes>>,
        > ::planus::WriteAsOffset<RequestResult> for RequestResultBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestResult> {
                let (v0, v1, v2) = &self.0;
                RequestResult::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [RequestResult].
        #[derive(Copy, Clone)]
        pub struct RequestResultRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RequestResultRef<'a> {
            /// Getter for the [`token` field](RequestResult#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<self::WorkerTokenRef<'a>> {
                self.0.access_required(0, "RequestResult", "token")
            }

            /// Getter for the [`id` field](RequestResult#structfield.id).
            #[inline]
            pub fn id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(1, "RequestResult", "id")
            }

            /// Getter for the [`result` field](RequestResult#structfield.result).
            #[inline]
            pub fn result(&self) -> ::planus::Result<self::VarBytesRef<'a>> {
                self.0.access_required(2, "RequestResult", "result")
            }
        }

        impl<'a> ::core::fmt::Debug for RequestResultRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RequestResultRef");
                f.field("token", &self.token());
                f.field("id", &self.id());
                f.field("result", &self.result());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RequestResultRef<'a>> for RequestResult {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RequestResultRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.token()?,
                    )?),
                    id: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.id()?,
                    )?),
                    result: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.result()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RequestResultRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RequestResultRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RequestResultRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RequestResult>> for RequestResult {
            type Value = ::planus::Offset<RequestResult>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RequestResult>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RequestResultRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RequestResultRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `RequestError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RequestError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1204`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RequestError {
            /// The field `token` in the table `RequestError`
            pub token: ::planus::alloc::boxed::Box<self::WorkerToken>,
            /// The field `id` in the table `RequestError`
            pub id: ::planus::alloc::boxed::Box<self::Uuid>,
            /// The field `error` in the table `RequestError`
            pub error: ::planus::alloc::boxed::Box<self::WorkerError>,
        }

        impl RequestError {
            /// Creates a [RequestErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RequestErrorBuilder<()> {
                RequestErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
                field_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::WorkerError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);
                let prepared_id = field_id.prepare(builder);
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorkerToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(1);
                table_writer.write_entry::<::planus::Offset<self::WorkerError>>(2);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                        object_writer.write::<_, _, 4>(&prepared_id);
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RequestError>> for RequestError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RequestError>> for RequestError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RequestError> for RequestError {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestError> {
                RequestError::create(builder, &self.token, &self.id, &self.error)
            }
        }

        /// Builder for serializing an instance of the [RequestError] type.
        ///
        /// Can be created using the [RequestError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RequestErrorBuilder<State>(State);

        impl RequestErrorBuilder<()> {
            /// Setter for the [`token` field](RequestError#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> RequestErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            {
                RequestErrorBuilder((value,))
            }
        }

        impl<T0> RequestErrorBuilder<(T0,)> {
            /// Setter for the [`id` field](RequestError#structfield.id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn id<T1>(self, value: T1) -> RequestErrorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                let (v0,) = self.0;
                RequestErrorBuilder((v0, value))
            }
        }

        impl<T0, T1> RequestErrorBuilder<(T0, T1)> {
            /// Setter for the [`error` field](RequestError#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T2>(self, value: T2) -> RequestErrorBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAs<::planus::Offset<self::WorkerError>>,
            {
                let (v0, v1) = self.0;
                RequestErrorBuilder((v0, v1, value))
            }
        }

        impl<T0, T1, T2> RequestErrorBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RequestError].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestError>
            where
                Self: ::planus::WriteAsOffset<RequestError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T2: ::planus::WriteAs<::planus::Offset<self::WorkerError>>,
        > ::planus::WriteAs<::planus::Offset<RequestError>> for RequestErrorBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RequestError>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T2: ::planus::WriteAs<::planus::Offset<self::WorkerError>>,
        > ::planus::WriteAsOptional<::planus::Offset<RequestError>>
            for RequestErrorBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RequestError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RequestError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            T2: ::planus::WriteAs<::planus::Offset<self::WorkerError>>,
        > ::planus::WriteAsOffset<RequestError> for RequestErrorBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RequestError> {
                let (v0, v1, v2) = &self.0;
                RequestError::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [RequestError].
        #[derive(Copy, Clone)]
        pub struct RequestErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RequestErrorRef<'a> {
            /// Getter for the [`token` field](RequestError#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<self::WorkerTokenRef<'a>> {
                self.0.access_required(0, "RequestError", "token")
            }

            /// Getter for the [`id` field](RequestError#structfield.id).
            #[inline]
            pub fn id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(1, "RequestError", "id")
            }

            /// Getter for the [`error` field](RequestError#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::WorkerErrorRef<'a>> {
                self.0.access_required(2, "RequestError", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for RequestErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RequestErrorRef");
                f.field("token", &self.token());
                f.field("id", &self.id());
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RequestErrorRef<'a>> for RequestError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RequestErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.token()?,
                    )?),
                    id: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.id()?,
                    )?),
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RequestErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RequestErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RequestErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RequestError>> for RequestError {
            type Value = ::planus::Offset<RequestError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RequestError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RequestErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RequestErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerToDaemonMessage` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerToDaemonMessage` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1210`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerToDaemonMessage {
            /// The field `message` in the table `WorkerToDaemonMessage`
            pub message: self::WorkerToDaemonMessageUnion,
        }

        impl WorkerToDaemonMessage {
            /// Creates a [WorkerToDaemonMessageBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerToDaemonMessageBuilder<()> {
                WorkerToDaemonMessageBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAsUnion<self::WorkerToDaemonMessageUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorkerToDaemonMessageUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message.offset());
                        object_writer.write::<_, _, 1>(&prepared_message.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerToDaemonMessage>> for WorkerToDaemonMessage {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerToDaemonMessage> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerToDaemonMessage>> for WorkerToDaemonMessage {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerToDaemonMessage>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerToDaemonMessage> for WorkerToDaemonMessage {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerToDaemonMessage> {
                WorkerToDaemonMessage::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [WorkerToDaemonMessage] type.
        ///
        /// Can be created using the [WorkerToDaemonMessage::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerToDaemonMessageBuilder<State>(State);

        impl WorkerToDaemonMessageBuilder<()> {
            /// Setter for the [`message` field](WorkerToDaemonMessage#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> WorkerToDaemonMessageBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::WorkerToDaemonMessageUnion>,
            {
                WorkerToDaemonMessageBuilder((value,))
            }
        }

        impl<T0> WorkerToDaemonMessageBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerToDaemonMessage].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerToDaemonMessage>
            where
                Self: ::planus::WriteAsOffset<WorkerToDaemonMessage>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorkerToDaemonMessageUnion>>
            ::planus::WriteAs<::planus::Offset<WorkerToDaemonMessage>>
            for WorkerToDaemonMessageBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerToDaemonMessage>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerToDaemonMessage> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorkerToDaemonMessageUnion>>
            ::planus::WriteAsOptional<::planus::Offset<WorkerToDaemonMessage>>
            for WorkerToDaemonMessageBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<WorkerToDaemonMessage>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerToDaemonMessage>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::WorkerToDaemonMessageUnion>>
            ::planus::WriteAsOffset<WorkerToDaemonMessage> for WorkerToDaemonMessageBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<WorkerToDaemonMessage> {
                let (v0,) = &self.0;
                WorkerToDaemonMessage::create(builder, v0)
            }
        }

        /// Reference to a deserialized [WorkerToDaemonMessage].
        #[derive(Copy, Clone)]
        pub struct WorkerToDaemonMessageRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerToDaemonMessageRef<'a> {
            /// Getter for the [`message` field](WorkerToDaemonMessage#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<self::WorkerToDaemonMessageUnionRef<'a>> {
                self.0
                    .access_union_required(0, "WorkerToDaemonMessage", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerToDaemonMessageRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerToDaemonMessageRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerToDaemonMessageRef<'a>> for WorkerToDaemonMessage {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerToDaemonMessageRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::TryInto::try_into(value.message()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerToDaemonMessageRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerToDaemonMessageRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerToDaemonMessageRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerToDaemonMessage>>
            for WorkerToDaemonMessage
        {
            type Value = ::planus::Offset<WorkerToDaemonMessage>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerToDaemonMessage>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerToDaemonMessageRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerToDaemonMessageRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `DaemonToWorkerReplyUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `DaemonToWorkerReplyUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1214`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum DaemonToWorkerReplyUnion {
            /// The variant of type `WorkerAck` in the union `DaemonToWorkerReplyUnion`
            WorkerAck(::planus::alloc::boxed::Box<self::WorkerAck>),

            /// The variant of type `WorkerRejected` in the union `DaemonToWorkerReplyUnion`
            WorkerRejected(::planus::alloc::boxed::Box<self::WorkerRejected>),

            /// The variant of type `WorkerAttached` in the union `DaemonToWorkerReplyUnion`
            WorkerAttached(::planus::alloc::boxed::Box<self::WorkerAttached>),
        }

        impl DaemonToWorkerReplyUnion {
            /// Creates a [DaemonToWorkerReplyUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToWorkerReplyUnionBuilder<::planus::Uninitialized> {
                DaemonToWorkerReplyUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_worker_ack(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerAck>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_worker_rejected(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerRejected>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_worker_attached(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::WorkerAttached>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<DaemonToWorkerReplyUnion> for DaemonToWorkerReplyUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::WorkerAck(value) => Self::create_worker_ack(builder, value),
                    Self::WorkerRejected(value) => Self::create_worker_rejected(builder, value),
                    Self::WorkerAttached(value) => Self::create_worker_attached(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<DaemonToWorkerReplyUnion> for DaemonToWorkerReplyUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [DaemonToWorkerReplyUnion] type.
        ///
        /// Can be created using the [DaemonToWorkerReplyUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToWorkerReplyUnionBuilder<T>(T);

        impl DaemonToWorkerReplyUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`WorkerAck` variant](DaemonToWorkerReplyUnion#variant.WorkerAck).
            #[inline]
            pub fn worker_ack<T>(
                self,
                value: T,
            ) -> DaemonToWorkerReplyUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerAck>,
            {
                DaemonToWorkerReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorkerRejected` variant](DaemonToWorkerReplyUnion#variant.WorkerRejected).
            #[inline]
            pub fn worker_rejected<T>(
                self,
                value: T,
            ) -> DaemonToWorkerReplyUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerRejected>,
            {
                DaemonToWorkerReplyUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`WorkerAttached` variant](DaemonToWorkerReplyUnion#variant.WorkerAttached).
            #[inline]
            pub fn worker_attached<T>(
                self,
                value: T,
            ) -> DaemonToWorkerReplyUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::WorkerAttached>,
            {
                DaemonToWorkerReplyUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> DaemonToWorkerReplyUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [DaemonToWorkerReplyUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToWorkerReplyUnion>
            where
                Self: ::planus::WriteAsUnion<DaemonToWorkerReplyUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<DaemonToWorkerReplyUnion>
            for DaemonToWorkerReplyUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerAck>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToWorkerReplyUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToWorkerReplyUnion>
            for DaemonToWorkerReplyUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerAck>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToWorkerReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToWorkerReplyUnion>
            for DaemonToWorkerReplyUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerRejected>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToWorkerReplyUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToWorkerReplyUnion>
            for DaemonToWorkerReplyUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerRejected>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToWorkerReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<DaemonToWorkerReplyUnion>
            for DaemonToWorkerReplyUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerAttached>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<DaemonToWorkerReplyUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<DaemonToWorkerReplyUnion>
            for DaemonToWorkerReplyUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::WorkerAttached>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<DaemonToWorkerReplyUnion>>
            {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [DaemonToWorkerReplyUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum DaemonToWorkerReplyUnionRef<'a> {
            WorkerAck(self::WorkerAckRef<'a>),
            WorkerRejected(self::WorkerRejectedRef<'a>),
            WorkerAttached(self::WorkerAttachedRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<DaemonToWorkerReplyUnionRef<'a>> for DaemonToWorkerReplyUnion {
            type Error = ::planus::Error;

            fn try_from(value: DaemonToWorkerReplyUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    DaemonToWorkerReplyUnionRef::WorkerAck(value) => {
                        Self::WorkerAck(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToWorkerReplyUnionRef::WorkerRejected(value) => {
                        Self::WorkerRejected(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    DaemonToWorkerReplyUnionRef::WorkerAttached(value) => {
                        Self::WorkerAttached(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for DaemonToWorkerReplyUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::WorkerAck(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::WorkerRejected(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::WorkerAttached(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for DaemonToWorkerReplyUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[DaemonToWorkerReplyUnionRef]";
        }

        /// The table `WorkerAck` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerAck` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1220`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerAck {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerAck {
            fn default() -> Self {
                Self {}
            }
        }

        impl WorkerAck {
            /// Creates a [WorkerAckBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerAckBuilder<()> {
                WorkerAckBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerAck>> for WorkerAck {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerAck> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerAck>> for WorkerAck {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerAck>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerAck> for WorkerAck {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerAck> {
                WorkerAck::create(builder)
            }
        }

        /// Builder for serializing an instance of the [WorkerAck] type.
        ///
        /// Can be created using the [WorkerAck::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerAckBuilder<State>(State);

        impl WorkerAckBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerAck].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerAck>
            where
                Self: ::planus::WriteAsOffset<WorkerAck>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerAck>> for WorkerAckBuilder<()> {
            type Prepared = ::planus::Offset<WorkerAck>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerAck> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerAck>> for WorkerAckBuilder<()> {
            type Prepared = ::planus::Offset<WorkerAck>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerAck>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerAck> for WorkerAckBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerAck> {
                WorkerAck::create(builder)
            }
        }

        /// Reference to a deserialized [WorkerAck].
        #[derive(Copy, Clone)]
        pub struct WorkerAckRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerAckRef<'a> {}

        impl<'a> ::core::fmt::Debug for WorkerAckRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerAckRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerAckRef<'a>> for WorkerAck {
            type Error = ::planus::Error;

            fn try_from(_value: WorkerAckRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerAckRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerAckRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerAckRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerAck>> for WorkerAck {
            type Value = ::planus::Offset<WorkerAck>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerAck>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerAckRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerAckRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerRejected` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerRejected` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1223`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerRejected {}

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerRejected {
            fn default() -> Self {
                Self {}
            }
        }

        impl WorkerRejected {
            /// Creates a [WorkerRejectedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerRejectedBuilder<()> {
                WorkerRejectedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                let table_writer: ::planus::table_writer::TableWriter<4> =
                    ::core::default::Default::default();
                unsafe {
                    table_writer.finish(builder, |_table_writer| {});
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerRejected>> for WorkerRejected {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerRejected> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerRejected>> for WorkerRejected {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerRejected>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerRejected> for WorkerRejected {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerRejected> {
                WorkerRejected::create(builder)
            }
        }

        /// Builder for serializing an instance of the [WorkerRejected] type.
        ///
        /// Can be created using the [WorkerRejected::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerRejectedBuilder<State>(State);

        impl WorkerRejectedBuilder<()> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerRejected].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerRejected>
            where
                Self: ::planus::WriteAsOffset<WorkerRejected>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerRejected>> for WorkerRejectedBuilder<()> {
            type Prepared = ::planus::Offset<WorkerRejected>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerRejected> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerRejected>> for WorkerRejectedBuilder<()> {
            type Prepared = ::planus::Offset<WorkerRejected>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerRejected>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerRejected> for WorkerRejectedBuilder<()> {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerRejected> {
                WorkerRejected::create(builder)
            }
        }

        /// Reference to a deserialized [WorkerRejected].
        #[derive(Copy, Clone)]
        pub struct WorkerRejectedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerRejectedRef<'a> {}

        impl<'a> ::core::fmt::Debug for WorkerRejectedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerRejectedRef");

                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerRejectedRef<'a>> for WorkerRejected {
            type Error = ::planus::Error;

            fn try_from(_value: WorkerRejectedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {})
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerRejectedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerRejectedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerRejectedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerRejected>> for WorkerRejected {
            type Value = ::planus::Offset<WorkerRejected>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerRejected>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerRejectedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerRejectedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `WorkerAttached` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `WorkerAttached` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1226`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct WorkerAttached {
            /// The field `token` in the table `WorkerAttached`
            pub token: ::planus::alloc::boxed::Box<self::WorkerToken>,
            /// The field `worker_id` in the table `WorkerAttached`
            pub worker_id: ::planus::alloc::boxed::Box<self::Uuid>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for WorkerAttached {
            fn default() -> Self {
                Self {
                    token: ::core::default::Default::default(),
                    worker_id: ::core::default::Default::default(),
                }
            }
        }

        impl WorkerAttached {
            /// Creates a [WorkerAttachedBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> WorkerAttachedBuilder<()> {
                WorkerAttachedBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_token: impl ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
                field_worker_id: impl ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            ) -> ::planus::Offset<Self> {
                let prepared_token = field_token.prepare(builder);
                let prepared_worker_id = field_worker_id.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::WorkerToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::Uuid>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_token);
                        object_writer.write::<_, _, 4>(&prepared_worker_id);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<WorkerAttached>> for WorkerAttached {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerAttached> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<WorkerAttached>> for WorkerAttached {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerAttached>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<WorkerAttached> for WorkerAttached {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerAttached> {
                WorkerAttached::create(builder, &self.token, &self.worker_id)
            }
        }

        /// Builder for serializing an instance of the [WorkerAttached] type.
        ///
        /// Can be created using the [WorkerAttached::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct WorkerAttachedBuilder<State>(State);

        impl WorkerAttachedBuilder<()> {
            /// Setter for the [`token` field](WorkerAttached#structfield.token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn token<T0>(self, value: T0) -> WorkerAttachedBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            {
                WorkerAttachedBuilder((value,))
            }
        }

        impl<T0> WorkerAttachedBuilder<(T0,)> {
            /// Setter for the [`worker_id` field](WorkerAttached#structfield.worker_id).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn worker_id<T1>(self, value: T1) -> WorkerAttachedBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
            {
                let (v0,) = self.0;
                WorkerAttachedBuilder((v0, value))
            }
        }

        impl<T0, T1> WorkerAttachedBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WorkerAttached].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerAttached>
            where
                Self: ::planus::WriteAsOffset<WorkerAttached>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
        > ::planus::WriteAs<::planus::Offset<WorkerAttached>> for WorkerAttachedBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<WorkerAttached>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerAttached> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
        > ::planus::WriteAsOptional<::planus::Offset<WorkerAttached>>
            for WorkerAttachedBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<WorkerAttached>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<WorkerAttached>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::WorkerToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::Uuid>>,
        > ::planus::WriteAsOffset<WorkerAttached> for WorkerAttachedBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<WorkerAttached> {
                let (v0, v1) = &self.0;
                WorkerAttached::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [WorkerAttached].
        #[derive(Copy, Clone)]
        pub struct WorkerAttachedRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> WorkerAttachedRef<'a> {
            /// Getter for the [`token` field](WorkerAttached#structfield.token).
            #[inline]
            pub fn token(&self) -> ::planus::Result<self::WorkerTokenRef<'a>> {
                self.0.access_required(0, "WorkerAttached", "token")
            }

            /// Getter for the [`worker_id` field](WorkerAttached#structfield.worker_id).
            #[inline]
            pub fn worker_id(&self) -> ::planus::Result<self::UuidRef<'a>> {
                self.0.access_required(1, "WorkerAttached", "worker_id")
            }
        }

        impl<'a> ::core::fmt::Debug for WorkerAttachedRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("WorkerAttachedRef");
                f.field("token", &self.token());
                f.field("worker_id", &self.worker_id());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<WorkerAttachedRef<'a>> for WorkerAttached {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: WorkerAttachedRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    token: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.token()?,
                    )?),
                    worker_id: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.worker_id()?)?,
                    ),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for WorkerAttachedRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for WorkerAttachedRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[WorkerAttachedRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<WorkerAttached>> for WorkerAttached {
            type Value = ::planus::Offset<WorkerAttached>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<WorkerAttached>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for WorkerAttachedRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[WorkerAttachedRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `DaemonToWorkerReply` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `DaemonToWorkerReply` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1231`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct DaemonToWorkerReply {
            /// The field `reply` in the table `DaemonToWorkerReply`
            pub reply: self::DaemonToWorkerReplyUnion,
        }

        impl DaemonToWorkerReply {
            /// Creates a [DaemonToWorkerReplyBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> DaemonToWorkerReplyBuilder<()> {
                DaemonToWorkerReplyBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_reply: impl ::planus::WriteAsUnion<self::DaemonToWorkerReplyUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_reply = field_reply.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::DaemonToWorkerReplyUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_reply.offset());
                        object_writer.write::<_, _, 1>(&prepared_reply.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<DaemonToWorkerReply>> for DaemonToWorkerReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToWorkerReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<DaemonToWorkerReply>> for DaemonToWorkerReply {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToWorkerReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<DaemonToWorkerReply> for DaemonToWorkerReply {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToWorkerReply> {
                DaemonToWorkerReply::create(builder, &self.reply)
            }
        }

        /// Builder for serializing an instance of the [DaemonToWorkerReply] type.
        ///
        /// Can be created using the [DaemonToWorkerReply::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct DaemonToWorkerReplyBuilder<State>(State);

        impl DaemonToWorkerReplyBuilder<()> {
            /// Setter for the [`reply` field](DaemonToWorkerReply#structfield.reply).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn reply<T0>(self, value: T0) -> DaemonToWorkerReplyBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::DaemonToWorkerReplyUnion>,
            {
                DaemonToWorkerReplyBuilder((value,))
            }
        }

        impl<T0> DaemonToWorkerReplyBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DaemonToWorkerReply].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToWorkerReply>
            where
                Self: ::planus::WriteAsOffset<DaemonToWorkerReply>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToWorkerReplyUnion>>
            ::planus::WriteAs<::planus::Offset<DaemonToWorkerReply>>
            for DaemonToWorkerReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DaemonToWorkerReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToWorkerReply> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToWorkerReplyUnion>>
            ::planus::WriteAsOptional<::planus::Offset<DaemonToWorkerReply>>
            for DaemonToWorkerReplyBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<DaemonToWorkerReply>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<DaemonToWorkerReply>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::DaemonToWorkerReplyUnion>>
            ::planus::WriteAsOffset<DaemonToWorkerReply> for DaemonToWorkerReplyBuilder<(T0,)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<DaemonToWorkerReply> {
                let (v0,) = &self.0;
                DaemonToWorkerReply::create(builder, v0)
            }
        }

        /// Reference to a deserialized [DaemonToWorkerReply].
        #[derive(Copy, Clone)]
        pub struct DaemonToWorkerReplyRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> DaemonToWorkerReplyRef<'a> {
            /// Getter for the [`reply` field](DaemonToWorkerReply#structfield.reply).
            #[inline]
            pub fn reply(&self) -> ::planus::Result<self::DaemonToWorkerReplyUnionRef<'a>> {
                self.0
                    .access_union_required(0, "DaemonToWorkerReply", "reply")
            }
        }

        impl<'a> ::core::fmt::Debug for DaemonToWorkerReplyRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("DaemonToWorkerReplyRef");
                f.field("reply", &self.reply());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<DaemonToWorkerReplyRef<'a>> for DaemonToWorkerReply {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: DaemonToWorkerReplyRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    reply: ::core::convert::TryInto::try_into(value.reply()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for DaemonToWorkerReplyRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for DaemonToWorkerReplyRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[DaemonToWorkerReplyRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<DaemonToWorkerReply>> for DaemonToWorkerReply {
            type Value = ::planus::Offset<DaemonToWorkerReply>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<DaemonToWorkerReply>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for DaemonToWorkerReplyRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[DaemonToWorkerReplyRef]", "read_as_root", 0)
                })
            }
        }

        /// The enum `RpcMessageErrorCode` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Enum `RpcMessageErrorCode` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1239`
        #[derive(
            Copy,
            Clone,
            Debug,
            PartialEq,
            Eq,
            PartialOrd,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        #[repr(u8)]
        pub enum RpcMessageErrorCode {
            /// The variant `AlreadyConnected` in the enum `RpcMessageErrorCode`
            AlreadyConnected = 0,

            /// The variant `InvalidRequest` in the enum `RpcMessageErrorCode`
            InvalidRequest = 1,

            /// The variant `NoConnection` in the enum `RpcMessageErrorCode`
            NoConnection = 2,

            /// The variant `ErrorCouldNotRetrieveSysProp` in the enum `RpcMessageErrorCode`
            ErrorCouldNotRetrieveSysProp = 3,

            /// The variant `LoginTaskFailed` in the enum `RpcMessageErrorCode`
            LoginTaskFailed = 4,

            /// The variant `CreateSessionFailed` in the enum `RpcMessageErrorCode`
            CreateSessionFailed = 5,

            /// The variant `PermissionDenied` in the enum `RpcMessageErrorCode`
            PermissionDenied = 6,

            /// The variant `TaskError` in the enum `RpcMessageErrorCode`
            TaskError = 7,

            /// The variant `EntityRetrievalError` in the enum `RpcMessageErrorCode`
            EntityRetrievalError = 8,

            /// The variant `InternalError` in the enum `RpcMessageErrorCode`
            InternalError = 9,
        }

        impl RpcMessageErrorCode {
            /// Array containing all valid variants of RpcMessageErrorCode
            pub const ENUM_VALUES: [Self; 10] = [
                Self::AlreadyConnected,
                Self::InvalidRequest,
                Self::NoConnection,
                Self::ErrorCouldNotRetrieveSysProp,
                Self::LoginTaskFailed,
                Self::CreateSessionFailed,
                Self::PermissionDenied,
                Self::TaskError,
                Self::EntityRetrievalError,
                Self::InternalError,
            ];
        }

        impl ::core::convert::TryFrom<u8> for RpcMessageErrorCode {
            type Error = ::planus::errors::UnknownEnumTagKind;
            #[inline]
            fn try_from(
                value: u8,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind> {
                #[allow(clippy::match_single_binding)]
                match value {
                    0 => ::core::result::Result::Ok(RpcMessageErrorCode::AlreadyConnected),
                    1 => ::core::result::Result::Ok(RpcMessageErrorCode::InvalidRequest),
                    2 => ::core::result::Result::Ok(RpcMessageErrorCode::NoConnection),
                    3 => ::core::result::Result::Ok(
                        RpcMessageErrorCode::ErrorCouldNotRetrieveSysProp,
                    ),
                    4 => ::core::result::Result::Ok(RpcMessageErrorCode::LoginTaskFailed),
                    5 => ::core::result::Result::Ok(RpcMessageErrorCode::CreateSessionFailed),
                    6 => ::core::result::Result::Ok(RpcMessageErrorCode::PermissionDenied),
                    7 => ::core::result::Result::Ok(RpcMessageErrorCode::TaskError),
                    8 => ::core::result::Result::Ok(RpcMessageErrorCode::EntityRetrievalError),
                    9 => ::core::result::Result::Ok(RpcMessageErrorCode::InternalError),

                    _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                        tag: value as i128,
                    }),
                }
            }
        }

        impl ::core::convert::From<RpcMessageErrorCode> for u8 {
            #[inline]
            fn from(value: RpcMessageErrorCode) -> Self {
                value as u8
            }
        }

        /// # Safety
        /// The Planus compiler correctly calculates `ALIGNMENT` and `SIZE`.
        unsafe impl ::planus::Primitive for RpcMessageErrorCode {
            const ALIGNMENT: usize = 1;
            const SIZE: usize = 1;
        }

        impl ::planus::WriteAsPrimitive<RpcMessageErrorCode> for RpcMessageErrorCode {
            #[inline]
            fn write<const N: usize>(&self, cursor: ::planus::Cursor<'_, N>, buffer_position: u32) {
                (*self as u8).write(cursor, buffer_position);
            }
        }

        impl ::planus::WriteAs<RpcMessageErrorCode> for RpcMessageErrorCode {
            type Prepared = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> RpcMessageErrorCode {
                *self
            }
        }

        impl ::planus::WriteAsDefault<RpcMessageErrorCode, RpcMessageErrorCode> for RpcMessageErrorCode {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
                default: &RpcMessageErrorCode,
            ) -> ::core::option::Option<RpcMessageErrorCode> {
                if self == default {
                    ::core::option::Option::None
                } else {
                    ::core::option::Option::Some(*self)
                }
            }
        }

        impl ::planus::WriteAsOptional<RpcMessageErrorCode> for RpcMessageErrorCode {
            type Prepared = Self;

            #[inline]
            fn prepare(
                &self,
                _builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<RpcMessageErrorCode> {
                ::core::option::Option::Some(*self)
            }
        }

        impl<'buf> ::planus::TableRead<'buf> for RpcMessageErrorCode {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
            }
        }

        impl<'buf> ::planus::VectorReadInner<'buf> for RpcMessageErrorCode {
            type Error = ::planus::errors::UnknownEnumTag;
            const STRIDE: usize = 1;
            #[inline]
            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'buf>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag> {
                let value = unsafe { *buffer.buffer.get_unchecked(offset) };
                let value: ::core::result::Result<Self, _> =
                    ::core::convert::TryInto::try_into(value);
                value.map_err(|error_kind| {
                    error_kind.with_error_location(
                        "RpcMessageErrorCode",
                        "VectorRead::from_buffer",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<RpcMessageErrorCode> for RpcMessageErrorCode {
            const STRIDE: usize = 1;

            type Value = Self;

            #[inline]
            fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                *self
            }

            #[inline]
            unsafe fn write_values(
                values: &[Self],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - i as u32,
                    );
                }
            }
        }

        /// The table `RpcMessageError` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `RpcMessageError` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1252`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct RpcMessageError {
            /// The field `error_code` in the table `RpcMessageError`
            pub error_code: self::RpcMessageErrorCode,
            /// The field `message` in the table `RpcMessageError`
            pub message: ::core::option::Option<::planus::alloc::string::String>,
            /// The field `scheduler_error` in the table `RpcMessageError`
            pub scheduler_error:
                ::core::option::Option<::planus::alloc::boxed::Box<self::SchedulerError>>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for RpcMessageError {
            fn default() -> Self {
                Self {
                    error_code: self::RpcMessageErrorCode::AlreadyConnected,
                    message: ::core::default::Default::default(),
                    scheduler_error: ::core::default::Default::default(),
                }
            }
        }

        impl RpcMessageError {
            /// Creates a [RpcMessageErrorBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> RpcMessageErrorBuilder<()> {
                RpcMessageErrorBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error_code: impl ::planus::WriteAsDefault<
                    self::RpcMessageErrorCode,
                    self::RpcMessageErrorCode,
                >,
                field_message: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                field_scheduler_error: impl ::planus::WriteAsOptional<
                    ::planus::Offset<self::SchedulerError>,
                >,
            ) -> ::planus::Offset<Self> {
                let prepared_error_code =
                    field_error_code.prepare(builder, &self::RpcMessageErrorCode::AlreadyConnected);
                let prepared_message = field_message.prepare(builder);
                let prepared_scheduler_error = field_scheduler_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<10> =
                    ::core::default::Default::default();
                if prepared_message.is_some() {
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                }
                if prepared_scheduler_error.is_some() {
                    table_writer.write_entry::<::planus::Offset<self::SchedulerError>>(2);
                }
                if prepared_error_code.is_some() {
                    table_writer.write_entry::<self::RpcMessageErrorCode>(0);
                }

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        if let ::core::option::Option::Some(prepared_message) = prepared_message {
                            object_writer.write::<_, _, 4>(&prepared_message);
                        }
                        if let ::core::option::Option::Some(prepared_scheduler_error) =
                            prepared_scheduler_error
                        {
                            object_writer.write::<_, _, 4>(&prepared_scheduler_error);
                        }
                        if let ::core::option::Option::Some(prepared_error_code) =
                            prepared_error_code
                        {
                            object_writer.write::<_, _, 1>(&prepared_error_code);
                        }
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<RpcMessageError>> for RpcMessageError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RpcMessageError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<RpcMessageError>> for RpcMessageError {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RpcMessageError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<RpcMessageError> for RpcMessageError {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RpcMessageError> {
                RpcMessageError::create(
                    builder,
                    self.error_code,
                    &self.message,
                    &self.scheduler_error,
                )
            }
        }

        /// Builder for serializing an instance of the [RpcMessageError] type.
        ///
        /// Can be created using the [RpcMessageError::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct RpcMessageErrorBuilder<State>(State);

        impl RpcMessageErrorBuilder<()> {
            /// Setter for the [`error_code` field](RpcMessageError#structfield.error_code).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error_code<T0>(self, value: T0) -> RpcMessageErrorBuilder<(T0,)>
            where
                T0: ::planus::WriteAsDefault<self::RpcMessageErrorCode, self::RpcMessageErrorCode>,
            {
                RpcMessageErrorBuilder((value,))
            }

            /// Sets the [`error_code` field](RpcMessageError#structfield.error_code) to the default value.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error_code_as_default(
                self,
            ) -> RpcMessageErrorBuilder<(::planus::DefaultValue,)> {
                self.error_code(::planus::DefaultValue)
            }
        }

        impl<T0> RpcMessageErrorBuilder<(T0,)> {
            /// Setter for the [`message` field](RpcMessageError#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T1>(self, value: T1) -> RpcMessageErrorBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            {
                let (v0,) = self.0;
                RpcMessageErrorBuilder((v0, value))
            }

            /// Sets the [`message` field](RpcMessageError#structfield.message) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message_as_null(self) -> RpcMessageErrorBuilder<(T0, ())> {
                self.message(())
            }
        }

        impl<T0, T1> RpcMessageErrorBuilder<(T0, T1)> {
            /// Setter for the [`scheduler_error` field](RpcMessageError#structfield.scheduler_error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scheduler_error<T2>(self, value: T2) -> RpcMessageErrorBuilder<(T0, T1, T2)>
            where
                T2: ::planus::WriteAsOptional<::planus::Offset<self::SchedulerError>>,
            {
                let (v0, v1) = self.0;
                RpcMessageErrorBuilder((v0, v1, value))
            }

            /// Sets the [`scheduler_error` field](RpcMessageError#structfield.scheduler_error) to null.
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn scheduler_error_as_null(self) -> RpcMessageErrorBuilder<(T0, T1, ())> {
                self.scheduler_error(())
            }
        }

        impl<T0, T1, T2> RpcMessageErrorBuilder<(T0, T1, T2)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RpcMessageError].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RpcMessageError>
            where
                Self: ::planus::WriteAsOffset<RpcMessageError>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::RpcMessageErrorCode, self::RpcMessageErrorCode>,
            T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::SchedulerError>>,
        > ::planus::WriteAs<::planus::Offset<RpcMessageError>>
            for RpcMessageErrorBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RpcMessageError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RpcMessageError> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::RpcMessageErrorCode, self::RpcMessageErrorCode>,
            T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::SchedulerError>>,
        > ::planus::WriteAsOptional<::planus::Offset<RpcMessageError>>
            for RpcMessageErrorBuilder<(T0, T1, T2)>
        {
            type Prepared = ::planus::Offset<RpcMessageError>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<RpcMessageError>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAsDefault<self::RpcMessageErrorCode, self::RpcMessageErrorCode>,
            T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
            T2: ::planus::WriteAsOptional<::planus::Offset<self::SchedulerError>>,
        > ::planus::WriteAsOffset<RpcMessageError> for RpcMessageErrorBuilder<(T0, T1, T2)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<RpcMessageError> {
                let (v0, v1, v2) = &self.0;
                RpcMessageError::create(builder, v0, v1, v2)
            }
        }

        /// Reference to a deserialized [RpcMessageError].
        #[derive(Copy, Clone)]
        pub struct RpcMessageErrorRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> RpcMessageErrorRef<'a> {
            /// Getter for the [`error_code` field](RpcMessageError#structfield.error_code).
            #[inline]
            pub fn error_code(&self) -> ::planus::Result<self::RpcMessageErrorCode> {
                ::core::result::Result::Ok(
                    self.0
                        .access(0, "RpcMessageError", "error_code")?
                        .unwrap_or(self::RpcMessageErrorCode::AlreadyConnected),
                )
            }

            /// Getter for the [`message` field](RpcMessageError#structfield.message).
            #[inline]
            pub fn message(
                &self,
            ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>> {
                self.0.access(1, "RpcMessageError", "message")
            }

            /// Getter for the [`scheduler_error` field](RpcMessageError#structfield.scheduler_error).
            #[inline]
            pub fn scheduler_error(
                &self,
            ) -> ::planus::Result<::core::option::Option<self::SchedulerErrorRef<'a>>> {
                self.0.access(2, "RpcMessageError", "scheduler_error")
            }
        }

        impl<'a> ::core::fmt::Debug for RpcMessageErrorRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("RpcMessageErrorRef");
                f.field("error_code", &self.error_code());
                if let ::core::option::Option::Some(field_message) = self.message().transpose() {
                    f.field("message", &field_message);
                }
                if let ::core::option::Option::Some(field_scheduler_error) =
                    self.scheduler_error().transpose()
                {
                    f.field("scheduler_error", &field_scheduler_error);
                }
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<RpcMessageErrorRef<'a>> for RpcMessageError {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: RpcMessageErrorRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error_code: ::core::convert::TryInto::try_into(value.error_code()?)?,
                    message: value.message()?.map(::core::convert::Into::into),
                    scheduler_error: if let ::core::option::Option::Some(scheduler_error) =
                        value.scheduler_error()?
                    {
                        ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(scheduler_error)?,
                        ))
                    } else {
                        ::core::option::Option::None
                    },
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for RpcMessageErrorRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for RpcMessageErrorRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[RpcMessageErrorRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<RpcMessageError>> for RpcMessageError {
            type Value = ::planus::Offset<RpcMessageError>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<RpcMessageError>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for RpcMessageErrorRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[RpcMessageErrorRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `MessageTypeUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `MessageTypeUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1258`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum MessageTypeUnion {
            /// The variant of type `HostToDaemonMsg` in the union `MessageTypeUnion`
            HostToDaemonMsg(::planus::alloc::boxed::Box<self::HostToDaemonMsg>),

            /// The variant of type `HostClientToDaemonMsg` in the union `MessageTypeUnion`
            HostClientToDaemonMsg(::planus::alloc::boxed::Box<self::HostClientToDaemonMsg>),
        }

        impl MessageTypeUnion {
            /// Creates a [MessageTypeUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> MessageTypeUnionBuilder<::planus::Uninitialized> {
                MessageTypeUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_host_to_daemon_msg(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HostToDaemonMsg>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_host_client_to_daemon_msg(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HostClientToDaemonMsg>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<MessageTypeUnion> for MessageTypeUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::HostToDaemonMsg(value) => Self::create_host_to_daemon_msg(builder, value),
                    Self::HostClientToDaemonMsg(value) => {
                        Self::create_host_client_to_daemon_msg(builder, value)
                    }
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<MessageTypeUnion> for MessageTypeUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [MessageTypeUnion] type.
        ///
        /// Can be created using the [MessageTypeUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct MessageTypeUnionBuilder<T>(T);

        impl MessageTypeUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`HostToDaemonMsg` variant](MessageTypeUnion#variant.HostToDaemonMsg).
            #[inline]
            pub fn host_to_daemon_msg<T>(
                self,
                value: T,
            ) -> MessageTypeUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::HostToDaemonMsg>,
            {
                MessageTypeUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`HostClientToDaemonMsg` variant](MessageTypeUnion#variant.HostClientToDaemonMsg).
            #[inline]
            pub fn host_client_to_daemon_msg<T>(
                self,
                value: T,
            ) -> MessageTypeUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::HostClientToDaemonMsg>,
            {
                MessageTypeUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> MessageTypeUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [MessageTypeUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<MessageTypeUnion>
            where
                Self: ::planus::WriteAsUnion<MessageTypeUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<MessageTypeUnion>
            for MessageTypeUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::HostToDaemonMsg>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<MessageTypeUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<MessageTypeUnion>
            for MessageTypeUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::HostToDaemonMsg>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<MessageTypeUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<MessageTypeUnion>
            for MessageTypeUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::HostClientToDaemonMsg>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<MessageTypeUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<MessageTypeUnion>
            for MessageTypeUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::HostClientToDaemonMsg>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<MessageTypeUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [MessageTypeUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum MessageTypeUnionRef<'a> {
            HostToDaemonMsg(self::HostToDaemonMsgRef<'a>),
            HostClientToDaemonMsg(self::HostClientToDaemonMsgRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<MessageTypeUnionRef<'a>> for MessageTypeUnion {
            type Error = ::planus::Error;

            fn try_from(value: MessageTypeUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    MessageTypeUnionRef::HostToDaemonMsg(value) => {
                        Self::HostToDaemonMsg(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    MessageTypeUnionRef::HostClientToDaemonMsg(value) => {
                        Self::HostClientToDaemonMsg(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for MessageTypeUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::HostToDaemonMsg(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::HostClientToDaemonMsg(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for MessageTypeUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[MessageTypeUnionRef]";
        }

        /// The table `HostToDaemonMsg` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostToDaemonMsg` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1263`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostToDaemonMsg {
            /// The field `host_token` in the table `HostToDaemonMsg`
            pub host_token: ::planus::alloc::boxed::Box<self::HostToken>,
            /// The field `message` in the table `HostToDaemonMsg`
            pub message: ::planus::alloc::boxed::Box<self::HostToDaemonMessage>,
        }

        impl HostToDaemonMsg {
            /// Creates a [HostToDaemonMsgBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostToDaemonMsgBuilder<()> {
                HostToDaemonMsgBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_host_token: impl ::planus::WriteAs<::planus::Offset<self::HostToken>>,
                field_message: impl ::planus::WriteAs<::planus::Offset<self::HostToDaemonMessage>>,
            ) -> ::planus::Offset<Self> {
                let prepared_host_token = field_host_token.prepare(builder);
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::HostToken>>(0);
                table_writer.write_entry::<::planus::Offset<self::HostToDaemonMessage>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_host_token);
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostToDaemonMsg>> for HostToDaemonMsg {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostToDaemonMsg> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostToDaemonMsg>> for HostToDaemonMsg {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostToDaemonMsg>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostToDaemonMsg> for HostToDaemonMsg {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostToDaemonMsg> {
                HostToDaemonMsg::create(builder, &self.host_token, &self.message)
            }
        }

        /// Builder for serializing an instance of the [HostToDaemonMsg] type.
        ///
        /// Can be created using the [HostToDaemonMsg::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostToDaemonMsgBuilder<State>(State);

        impl HostToDaemonMsgBuilder<()> {
            /// Setter for the [`host_token` field](HostToDaemonMsg#structfield.host_token).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn host_token<T0>(self, value: T0) -> HostToDaemonMsgBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::HostToken>>,
            {
                HostToDaemonMsgBuilder((value,))
            }
        }

        impl<T0> HostToDaemonMsgBuilder<(T0,)> {
            /// Setter for the [`message` field](HostToDaemonMsg#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T1>(self, value: T1) -> HostToDaemonMsgBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::HostToDaemonMessage>>,
            {
                let (v0,) = self.0;
                HostToDaemonMsgBuilder((v0, value))
            }
        }

        impl<T0, T1> HostToDaemonMsgBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostToDaemonMsg].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostToDaemonMsg>
            where
                Self: ::planus::WriteAsOffset<HostToDaemonMsg>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::HostToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::HostToDaemonMessage>>,
        > ::planus::WriteAs<::planus::Offset<HostToDaemonMsg>>
            for HostToDaemonMsgBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HostToDaemonMsg>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostToDaemonMsg> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::HostToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::HostToDaemonMessage>>,
        > ::planus::WriteAsOptional<::planus::Offset<HostToDaemonMsg>>
            for HostToDaemonMsgBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HostToDaemonMsg>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostToDaemonMsg>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<self::HostToken>>,
            T1: ::planus::WriteAs<::planus::Offset<self::HostToDaemonMessage>>,
        > ::planus::WriteAsOffset<HostToDaemonMsg> for HostToDaemonMsgBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostToDaemonMsg> {
                let (v0, v1) = &self.0;
                HostToDaemonMsg::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [HostToDaemonMsg].
        #[derive(Copy, Clone)]
        pub struct HostToDaemonMsgRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostToDaemonMsgRef<'a> {
            /// Getter for the [`host_token` field](HostToDaemonMsg#structfield.host_token).
            #[inline]
            pub fn host_token(&self) -> ::planus::Result<self::HostTokenRef<'a>> {
                self.0.access_required(0, "HostToDaemonMsg", "host_token")
            }

            /// Getter for the [`message` field](HostToDaemonMsg#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<self::HostToDaemonMessageRef<'a>> {
                self.0.access_required(1, "HostToDaemonMsg", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for HostToDaemonMsgRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostToDaemonMsgRef");
                f.field("host_token", &self.host_token());
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostToDaemonMsgRef<'a>> for HostToDaemonMsg {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostToDaemonMsgRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    host_token: ::planus::alloc::boxed::Box::new(
                        ::core::convert::TryInto::try_into(value.host_token()?)?,
                    ),
                    message: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.message()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostToDaemonMsgRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostToDaemonMsgRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostToDaemonMsgRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostToDaemonMsg>> for HostToDaemonMsg {
            type Value = ::planus::Offset<HostToDaemonMsg>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostToDaemonMsg>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostToDaemonMsgRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HostToDaemonMsgRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `HostClientToDaemonMsg` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostClientToDaemonMsg` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1268`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostClientToDaemonMsg {
            /// The field `client_data` in the table `HostClientToDaemonMsg`
            pub client_data: ::planus::alloc::vec::Vec<u8>,
            /// The field `message` in the table `HostClientToDaemonMsg`
            pub message: ::planus::alloc::boxed::Box<self::HostClientToDaemonMessage>,
        }

        impl HostClientToDaemonMsg {
            /// Creates a [HostClientToDaemonMsgBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostClientToDaemonMsgBuilder<()> {
                HostClientToDaemonMsgBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_client_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                field_message: impl ::planus::WriteAs<::planus::Offset<self::HostClientToDaemonMessage>>,
            ) -> ::planus::Offset<Self> {
                let prepared_client_data = field_client_data.prepare(builder);
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<[u8]>>(0);
                table_writer.write_entry::<::planus::Offset<self::HostClientToDaemonMessage>>(1);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_client_data);
                        object_writer.write::<_, _, 4>(&prepared_message);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostClientToDaemonMsg>> for HostClientToDaemonMsg {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostClientToDaemonMsg> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostClientToDaemonMsg>> for HostClientToDaemonMsg {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostClientToDaemonMsg>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostClientToDaemonMsg> for HostClientToDaemonMsg {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostClientToDaemonMsg> {
                HostClientToDaemonMsg::create(builder, &self.client_data, &self.message)
            }
        }

        /// Builder for serializing an instance of the [HostClientToDaemonMsg] type.
        ///
        /// Can be created using the [HostClientToDaemonMsg::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostClientToDaemonMsgBuilder<State>(State);

        impl HostClientToDaemonMsgBuilder<()> {
            /// Setter for the [`client_data` field](HostClientToDaemonMsg#structfield.client_data).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn client_data<T0>(self, value: T0) -> HostClientToDaemonMsgBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
            {
                HostClientToDaemonMsgBuilder((value,))
            }
        }

        impl<T0> HostClientToDaemonMsgBuilder<(T0,)> {
            /// Setter for the [`message` field](HostClientToDaemonMsg#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T1>(self, value: T1) -> HostClientToDaemonMsgBuilder<(T0, T1)>
            where
                T1: ::planus::WriteAs<::planus::Offset<self::HostClientToDaemonMessage>>,
            {
                let (v0,) = self.0;
                HostClientToDaemonMsgBuilder((v0, value))
            }
        }

        impl<T0, T1> HostClientToDaemonMsgBuilder<(T0, T1)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostClientToDaemonMsg].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostClientToDaemonMsg>
            where
                Self: ::planus::WriteAsOffset<HostClientToDaemonMsg>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
            T1: ::planus::WriteAs<::planus::Offset<self::HostClientToDaemonMessage>>,
        > ::planus::WriteAs<::planus::Offset<HostClientToDaemonMsg>>
            for HostClientToDaemonMsgBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HostClientToDaemonMsg>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostClientToDaemonMsg> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
            T1: ::planus::WriteAs<::planus::Offset<self::HostClientToDaemonMessage>>,
        > ::planus::WriteAsOptional<::planus::Offset<HostClientToDaemonMsg>>
            for HostClientToDaemonMsgBuilder<(T0, T1)>
        {
            type Prepared = ::planus::Offset<HostClientToDaemonMsg>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostClientToDaemonMsg>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<
            T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
            T1: ::planus::WriteAs<::planus::Offset<self::HostClientToDaemonMessage>>,
        > ::planus::WriteAsOffset<HostClientToDaemonMsg>
            for HostClientToDaemonMsgBuilder<(T0, T1)>
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::Offset<HostClientToDaemonMsg> {
                let (v0, v1) = &self.0;
                HostClientToDaemonMsg::create(builder, v0, v1)
            }
        }

        /// Reference to a deserialized [HostClientToDaemonMsg].
        #[derive(Copy, Clone)]
        pub struct HostClientToDaemonMsgRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostClientToDaemonMsgRef<'a> {
            /// Getter for the [`client_data` field](HostClientToDaemonMsg#structfield.client_data).
            #[inline]
            pub fn client_data(&self) -> ::planus::Result<&'a [u8]> {
                self.0
                    .access_required(0, "HostClientToDaemonMsg", "client_data")
            }

            /// Getter for the [`message` field](HostClientToDaemonMsg#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<self::HostClientToDaemonMessageRef<'a>> {
                self.0
                    .access_required(1, "HostClientToDaemonMsg", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for HostClientToDaemonMsgRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostClientToDaemonMsgRef");
                f.field("client_data", &self.client_data());
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostClientToDaemonMsgRef<'a>> for HostClientToDaemonMsg {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostClientToDaemonMsgRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    client_data: value.client_data()?.to_vec(),
                    message: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.message()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostClientToDaemonMsgRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostClientToDaemonMsgRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostClientToDaemonMsgRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostClientToDaemonMsg>>
            for HostClientToDaemonMsg
        {
            type Value = ::planus::Offset<HostClientToDaemonMsg>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostClientToDaemonMsg>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostClientToDaemonMsgRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HostClientToDaemonMsgRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `MessageType` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `MessageType` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1273`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct MessageType {
            /// The field `message` in the table `MessageType`
            pub message: self::MessageTypeUnion,
        }

        impl MessageType {
            /// Creates a [MessageTypeBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> MessageTypeBuilder<()> {
                MessageTypeBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_message: impl ::planus::WriteAsUnion<self::MessageTypeUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_message = field_message.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::MessageTypeUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_message.offset());
                        object_writer.write::<_, _, 1>(&prepared_message.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<MessageType>> for MessageType {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<MessageType> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<MessageType>> for MessageType {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<MessageType>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<MessageType> for MessageType {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<MessageType> {
                MessageType::create(builder, &self.message)
            }
        }

        /// Builder for serializing an instance of the [MessageType] type.
        ///
        /// Can be created using the [MessageType::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct MessageTypeBuilder<State>(State);

        impl MessageTypeBuilder<()> {
            /// Setter for the [`message` field](MessageType#structfield.message).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn message<T0>(self, value: T0) -> MessageTypeBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::MessageTypeUnion>,
            {
                MessageTypeBuilder((value,))
            }
        }

        impl<T0> MessageTypeBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [MessageType].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<MessageType>
            where
                Self: ::planus::WriteAsOffset<MessageType>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::MessageTypeUnion>>
            ::planus::WriteAs<::planus::Offset<MessageType>> for MessageTypeBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<MessageType>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<MessageType> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::MessageTypeUnion>>
            ::planus::WriteAsOptional<::planus::Offset<MessageType>> for MessageTypeBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<MessageType>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<MessageType>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::MessageTypeUnion>>
            ::planus::WriteAsOffset<MessageType> for MessageTypeBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<MessageType> {
                let (v0,) = &self.0;
                MessageType::create(builder, v0)
            }
        }

        /// Reference to a deserialized [MessageType].
        #[derive(Copy, Clone)]
        pub struct MessageTypeRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> MessageTypeRef<'a> {
            /// Getter for the [`message` field](MessageType#structfield.message).
            #[inline]
            pub fn message(&self) -> ::planus::Result<self::MessageTypeUnionRef<'a>> {
                self.0.access_union_required(0, "MessageType", "message")
            }
        }

        impl<'a> ::core::fmt::Debug for MessageTypeRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("MessageTypeRef");
                f.field("message", &self.message());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<MessageTypeRef<'a>> for MessageType {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: MessageTypeRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    message: ::core::convert::TryInto::try_into(value.message()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for MessageTypeRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for MessageTypeRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[MessageTypeRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<MessageType>> for MessageType {
            type Value = ::planus::Offset<MessageType>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<MessageType>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for MessageTypeRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[MessageTypeRef]", "read_as_root", 0)
                })
            }
        }

        /// The union `ReplyResultUnion` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Union `ReplyResultUnion` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1277`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub enum ReplyResultUnion {
            /// The variant of type `HostSuccess` in the union `ReplyResultUnion`
            HostSuccess(::planus::alloc::boxed::Box<self::HostSuccess>),

            /// The variant of type `ClientSuccess` in the union `ReplyResultUnion`
            ClientSuccess(::planus::alloc::boxed::Box<self::ClientSuccess>),

            /// The variant of type `Failure` in the union `ReplyResultUnion`
            Failure(::planus::alloc::boxed::Box<self::Failure>),
        }

        impl ReplyResultUnion {
            /// Creates a [ReplyResultUnionBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ReplyResultUnionBuilder<::planus::Uninitialized> {
                ReplyResultUnionBuilder(::planus::Uninitialized)
            }

            #[inline]
            pub fn create_host_success(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::HostSuccess>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_client_success(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::ClientSuccess>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
            }

            #[inline]
            pub fn create_failure(
                builder: &mut ::planus::Builder,
                value: impl ::planus::WriteAsOffset<self::Failure>,
            ) -> ::planus::UnionOffset<Self> {
                ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
            }
        }

        impl ::planus::WriteAsUnion<ReplyResultUnion> for ReplyResultUnion {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                match self {
                    Self::HostSuccess(value) => Self::create_host_success(builder, value),
                    Self::ClientSuccess(value) => Self::create_client_success(builder, value),
                    Self::Failure(value) => Self::create_failure(builder, value),
                }
            }
        }

        impl ::planus::WriteAsOptionalUnion<ReplyResultUnion> for ReplyResultUnion {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Builder for serializing an instance of the [ReplyResultUnion] type.
        ///
        /// Can be created using the [ReplyResultUnion::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ReplyResultUnionBuilder<T>(T);

        impl ReplyResultUnionBuilder<::planus::Uninitialized> {
            /// Creates an instance of the [`HostSuccess` variant](ReplyResultUnion#variant.HostSuccess).
            #[inline]
            pub fn host_success<T>(
                self,
                value: T,
            ) -> ReplyResultUnionBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::HostSuccess>,
            {
                ReplyResultUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`ClientSuccess` variant](ReplyResultUnion#variant.ClientSuccess).
            #[inline]
            pub fn client_success<T>(
                self,
                value: T,
            ) -> ReplyResultUnionBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::ClientSuccess>,
            {
                ReplyResultUnionBuilder(::planus::Initialized(value))
            }

            /// Creates an instance of the [`Failure` variant](ReplyResultUnion#variant.Failure).
            #[inline]
            pub fn failure<T>(
                self,
                value: T,
            ) -> ReplyResultUnionBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::Failure>,
            {
                ReplyResultUnionBuilder(::planus::Initialized(value))
            }
        }

        impl<const N: u8, T> ReplyResultUnionBuilder<::planus::Initialized<N, T>> {
            /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [ReplyResultUnion].
            #[inline]
            pub fn finish(
                self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ReplyResultUnion>
            where
                Self: ::planus::WriteAsUnion<ReplyResultUnion>,
            {
                ::planus::WriteAsUnion::prepare(&self, builder)
            }
        }

        impl<T> ::planus::WriteAsUnion<ReplyResultUnion>
            for ReplyResultUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::HostSuccess>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ReplyResultUnion> {
                ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ReplyResultUnion>
            for ReplyResultUnionBuilder<::planus::Initialized<1, T>>
        where
            T: ::planus::WriteAsOffset<self::HostSuccess>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ReplyResultUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ReplyResultUnion>
            for ReplyResultUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ClientSuccess>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ReplyResultUnion> {
                ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ReplyResultUnion>
            for ReplyResultUnionBuilder<::planus::Initialized<2, T>>
        where
            T: ::planus::WriteAsOffset<self::ClientSuccess>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ReplyResultUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }
        impl<T> ::planus::WriteAsUnion<ReplyResultUnion>
            for ReplyResultUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::Failure>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::planus::UnionOffset<ReplyResultUnion> {
                ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
            }
        }

        impl<T> ::planus::WriteAsOptionalUnion<ReplyResultUnion>
            for ReplyResultUnionBuilder<::planus::Initialized<3, T>>
        where
            T: ::planus::WriteAsOffset<self::Failure>,
        {
            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::UnionOffset<ReplyResultUnion>> {
                ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
            }
        }

        /// Reference to a deserialized [ReplyResultUnion].
        #[derive(Copy, Clone, Debug)]
        pub enum ReplyResultUnionRef<'a> {
            HostSuccess(self::HostSuccessRef<'a>),
            ClientSuccess(self::ClientSuccessRef<'a>),
            Failure(self::FailureRef<'a>),
        }

        impl<'a> ::core::convert::TryFrom<ReplyResultUnionRef<'a>> for ReplyResultUnion {
            type Error = ::planus::Error;

            fn try_from(value: ReplyResultUnionRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(match value {
                    ReplyResultUnionRef::HostSuccess(value) => {
                        Self::HostSuccess(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ReplyResultUnionRef::ClientSuccess(value) => {
                        Self::ClientSuccess(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }

                    ReplyResultUnionRef::Failure(value) => {
                        Self::Failure(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        ))
                    }
                })
            }
        }

        impl<'a> ::planus::TableReadUnion<'a> for ReplyResultUnionRef<'a> {
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                tag: u8,
                field_offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                match tag {
                    1 => ::core::result::Result::Ok(Self::HostSuccess(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    2 => ::core::result::Result::Ok(Self::ClientSuccess(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    3 => ::core::result::Result::Ok(Self::Failure(
                        ::planus::TableRead::from_buffer(buffer, field_offset)?,
                    )),
                    _ => {
                        ::core::result::Result::Err(::planus::errors::ErrorKind::UnknownUnionTag {
                            tag,
                        })
                    }
                }
            }
        }

        impl<'a> ::planus::VectorReadUnion<'a> for ReplyResultUnionRef<'a> {
            const VECTOR_NAME: &'static str = "[ReplyResultUnionRef]";
        }

        /// The table `HostSuccess` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `HostSuccess` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1283`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct HostSuccess {
            /// The field `reply` in the table `HostSuccess`
            pub reply: ::planus::alloc::boxed::Box<self::DaemonToHostReply>,
        }

        impl HostSuccess {
            /// Creates a [HostSuccessBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> HostSuccessBuilder<()> {
                HostSuccessBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_reply: impl ::planus::WriteAs<::planus::Offset<self::DaemonToHostReply>>,
            ) -> ::planus::Offset<Self> {
                let prepared_reply = field_reply.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::DaemonToHostReply>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_reply);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<HostSuccess>> for HostSuccess {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostSuccess> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<HostSuccess>> for HostSuccess {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostSuccess>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<HostSuccess> for HostSuccess {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostSuccess> {
                HostSuccess::create(builder, &self.reply)
            }
        }

        /// Builder for serializing an instance of the [HostSuccess] type.
        ///
        /// Can be created using the [HostSuccess::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct HostSuccessBuilder<State>(State);

        impl HostSuccessBuilder<()> {
            /// Setter for the [`reply` field](HostSuccess#structfield.reply).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn reply<T0>(self, value: T0) -> HostSuccessBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::DaemonToHostReply>>,
            {
                HostSuccessBuilder((value,))
            }
        }

        impl<T0> HostSuccessBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [HostSuccess].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostSuccess>
            where
                Self: ::planus::WriteAsOffset<HostSuccess>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::DaemonToHostReply>>>
            ::planus::WriteAs<::planus::Offset<HostSuccess>> for HostSuccessBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostSuccess>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostSuccess> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::DaemonToHostReply>>>
            ::planus::WriteAsOptional<::planus::Offset<HostSuccess>> for HostSuccessBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<HostSuccess>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<HostSuccess>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::DaemonToHostReply>>>
            ::planus::WriteAsOffset<HostSuccess> for HostSuccessBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<HostSuccess> {
                let (v0,) = &self.0;
                HostSuccess::create(builder, v0)
            }
        }

        /// Reference to a deserialized [HostSuccess].
        #[derive(Copy, Clone)]
        pub struct HostSuccessRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> HostSuccessRef<'a> {
            /// Getter for the [`reply` field](HostSuccess#structfield.reply).
            #[inline]
            pub fn reply(&self) -> ::planus::Result<self::DaemonToHostReplyRef<'a>> {
                self.0.access_required(0, "HostSuccess", "reply")
            }
        }

        impl<'a> ::core::fmt::Debug for HostSuccessRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("HostSuccessRef");
                f.field("reply", &self.reply());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<HostSuccessRef<'a>> for HostSuccess {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: HostSuccessRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    reply: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.reply()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for HostSuccessRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for HostSuccessRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[HostSuccessRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<HostSuccess>> for HostSuccess {
            type Value = ::planus::Offset<HostSuccess>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<HostSuccess>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for HostSuccessRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[HostSuccessRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ClientSuccess` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ClientSuccess` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1287`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ClientSuccess {
            /// The field `reply` in the table `ClientSuccess`
            pub reply: ::planus::alloc::boxed::Box<self::DaemonToClientReply>,
        }

        impl ClientSuccess {
            /// Creates a [ClientSuccessBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ClientSuccessBuilder<()> {
                ClientSuccessBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_reply: impl ::planus::WriteAs<::planus::Offset<self::DaemonToClientReply>>,
            ) -> ::planus::Offset<Self> {
                let prepared_reply = field_reply.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::DaemonToClientReply>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_reply);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ClientSuccess>> for ClientSuccess {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientSuccess> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ClientSuccess>> for ClientSuccess {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientSuccess>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ClientSuccess> for ClientSuccess {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientSuccess> {
                ClientSuccess::create(builder, &self.reply)
            }
        }

        /// Builder for serializing an instance of the [ClientSuccess] type.
        ///
        /// Can be created using the [ClientSuccess::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ClientSuccessBuilder<State>(State);

        impl ClientSuccessBuilder<()> {
            /// Setter for the [`reply` field](ClientSuccess#structfield.reply).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn reply<T0>(self, value: T0) -> ClientSuccessBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::DaemonToClientReply>>,
            {
                ClientSuccessBuilder((value,))
            }
        }

        impl<T0> ClientSuccessBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ClientSuccess].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientSuccess>
            where
                Self: ::planus::WriteAsOffset<ClientSuccess>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::DaemonToClientReply>>>
            ::planus::WriteAs<::planus::Offset<ClientSuccess>> for ClientSuccessBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ClientSuccess>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientSuccess> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::DaemonToClientReply>>>
            ::planus::WriteAsOptional<::planus::Offset<ClientSuccess>>
            for ClientSuccessBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ClientSuccess>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ClientSuccess>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::DaemonToClientReply>>>
            ::planus::WriteAsOffset<ClientSuccess> for ClientSuccessBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ClientSuccess> {
                let (v0,) = &self.0;
                ClientSuccess::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ClientSuccess].
        #[derive(Copy, Clone)]
        pub struct ClientSuccessRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ClientSuccessRef<'a> {
            /// Getter for the [`reply` field](ClientSuccess#structfield.reply).
            #[inline]
            pub fn reply(&self) -> ::planus::Result<self::DaemonToClientReplyRef<'a>> {
                self.0.access_required(0, "ClientSuccess", "reply")
            }
        }

        impl<'a> ::core::fmt::Debug for ClientSuccessRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ClientSuccessRef");
                f.field("reply", &self.reply());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ClientSuccessRef<'a>> for ClientSuccess {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ClientSuccessRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    reply: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.reply()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ClientSuccessRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ClientSuccessRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ClientSuccessRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ClientSuccess>> for ClientSuccess {
            type Value = ::planus::Offset<ClientSuccess>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ClientSuccess>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ClientSuccessRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ClientSuccessRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `Failure` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `Failure` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1291`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct Failure {
            /// The field `error` in the table `Failure`
            pub error: ::planus::alloc::boxed::Box<self::RpcMessageError>,
        }

        #[allow(clippy::derivable_impls)]
        impl ::core::default::Default for Failure {
            fn default() -> Self {
                Self {
                    error: ::core::default::Default::default(),
                }
            }
        }

        impl Failure {
            /// Creates a [FailureBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> FailureBuilder<()> {
                FailureBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_error: impl ::planus::WriteAs<::planus::Offset<self::RpcMessageError>>,
            ) -> ::planus::Offset<Self> {
                let prepared_error = field_error.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<6> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::RpcMessageError>>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_error);
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<Failure>> for Failure {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Failure> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<Failure>> for Failure {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Failure>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<Failure> for Failure {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Failure> {
                Failure::create(builder, &self.error)
            }
        }

        /// Builder for serializing an instance of the [Failure] type.
        ///
        /// Can be created using the [Failure::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct FailureBuilder<State>(State);

        impl FailureBuilder<()> {
            /// Setter for the [`error` field](Failure#structfield.error).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn error<T0>(self, value: T0) -> FailureBuilder<(T0,)>
            where
                T0: ::planus::WriteAs<::planus::Offset<self::RpcMessageError>>,
            {
                FailureBuilder((value,))
            }
        }

        impl<T0> FailureBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Failure].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Failure>
            where
                Self: ::planus::WriteAsOffset<Failure>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::RpcMessageError>>>
            ::planus::WriteAs<::planus::Offset<Failure>> for FailureBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Failure>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Failure> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::RpcMessageError>>>
            ::planus::WriteAsOptional<::planus::Offset<Failure>> for FailureBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<Failure>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<Failure>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAs<::planus::Offset<self::RpcMessageError>>>
            ::planus::WriteAsOffset<Failure> for FailureBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Failure> {
                let (v0,) = &self.0;
                Failure::create(builder, v0)
            }
        }

        /// Reference to a deserialized [Failure].
        #[derive(Copy, Clone)]
        pub struct FailureRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> FailureRef<'a> {
            /// Getter for the [`error` field](Failure#structfield.error).
            #[inline]
            pub fn error(&self) -> ::planus::Result<self::RpcMessageErrorRef<'a>> {
                self.0.access_required(0, "Failure", "error")
            }
        }

        impl<'a> ::core::fmt::Debug for FailureRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("FailureRef");
                f.field("error", &self.error());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<FailureRef<'a>> for Failure {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: FailureRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    error: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                        value.error()?,
                    )?),
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for FailureRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for FailureRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location("[FailureRef]", "get", buffer.offset_from_start)
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<Failure>> for Failure {
            type Value = ::planus::Offset<Failure>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<Failure>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for FailureRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[FailureRef]", "read_as_root", 0)
                })
            }
        }

        /// The table `ReplyResult` in the namespace `MoorRpc`
        ///
        /// Generated from these locations:
        /// * Table `ReplyResult` in the file `/home/ryan/moor/crates/rpc/rpc-common/moor_rpc.fbs:1295`
        #[derive(
            Clone,
            Debug,
            PartialEq,
            PartialOrd,
            Eq,
            Ord,
            Hash,
            ::serde::Serialize,
            ::serde::Deserialize,
        )]
        pub struct ReplyResult {
            /// The field `result` in the table `ReplyResult`
            pub result: self::ReplyResultUnion,
        }

        impl ReplyResult {
            /// Creates a [ReplyResultBuilder] for serializing an instance of this table.
            #[inline]
            pub fn builder() -> ReplyResultBuilder<()> {
                ReplyResultBuilder(())
            }

            #[allow(clippy::too_many_arguments)]
            pub fn create(
                builder: &mut ::planus::Builder,
                field_result: impl ::planus::WriteAsUnion<self::ReplyResultUnion>,
            ) -> ::planus::Offset<Self> {
                let prepared_result = field_result.prepare(builder);

                let mut table_writer: ::planus::table_writer::TableWriter<8> =
                    ::core::default::Default::default();
                table_writer.write_entry::<::planus::Offset<self::ReplyResultUnion>>(1);
                table_writer.write_entry::<u8>(0);

                unsafe {
                    table_writer.finish(builder, |object_writer| {
                        object_writer.write::<_, _, 4>(&prepared_result.offset());
                        object_writer.write::<_, _, 1>(&prepared_result.tag());
                    });
                }
                builder.current_offset()
            }
        }

        impl ::planus::WriteAs<::planus::Offset<ReplyResult>> for ReplyResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ReplyResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl ::planus::WriteAsOptional<::planus::Offset<ReplyResult>> for ReplyResult {
            type Prepared = ::planus::Offset<Self>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ReplyResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl ::planus::WriteAsOffset<ReplyResult> for ReplyResult {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ReplyResult> {
                ReplyResult::create(builder, &self.result)
            }
        }

        /// Builder for serializing an instance of the [ReplyResult] type.
        ///
        /// Can be created using the [ReplyResult::builder] method.
        #[derive(Debug)]
        #[must_use]
        pub struct ReplyResultBuilder<State>(State);

        impl ReplyResultBuilder<()> {
            /// Setter for the [`result` field](ReplyResult#structfield.result).
            #[inline]
            #[allow(clippy::type_complexity)]
            pub fn result<T0>(self, value: T0) -> ReplyResultBuilder<(T0,)>
            where
                T0: ::planus::WriteAsUnion<self::ReplyResultUnion>,
            {
                ReplyResultBuilder((value,))
            }
        }

        impl<T0> ReplyResultBuilder<(T0,)> {
            /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ReplyResult].
            #[inline]
            pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ReplyResult>
            where
                Self: ::planus::WriteAsOffset<ReplyResult>,
            {
                ::planus::WriteAsOffset::prepare(&self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ReplyResultUnion>>
            ::planus::WriteAs<::planus::Offset<ReplyResult>> for ReplyResultBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ReplyResult>;

            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ReplyResult> {
                ::planus::WriteAsOffset::prepare(self, builder)
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ReplyResultUnion>>
            ::planus::WriteAsOptional<::planus::Offset<ReplyResult>> for ReplyResultBuilder<(T0,)>
        {
            type Prepared = ::planus::Offset<ReplyResult>;

            #[inline]
            fn prepare(
                &self,
                builder: &mut ::planus::Builder,
            ) -> ::core::option::Option<::planus::Offset<ReplyResult>> {
                ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
            }
        }

        impl<T0: ::planus::WriteAsUnion<self::ReplyResultUnion>>
            ::planus::WriteAsOffset<ReplyResult> for ReplyResultBuilder<(T0,)>
        {
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ReplyResult> {
                let (v0,) = &self.0;
                ReplyResult::create(builder, v0)
            }
        }

        /// Reference to a deserialized [ReplyResult].
        #[derive(Copy, Clone)]
        pub struct ReplyResultRef<'a>(::planus::table_reader::Table<'a>);

        impl<'a> ReplyResultRef<'a> {
            /// Getter for the [`result` field](ReplyResult#structfield.result).
            #[inline]
            pub fn result(&self) -> ::planus::Result<self::ReplyResultUnionRef<'a>> {
                self.0.access_union_required(0, "ReplyResult", "result")
            }
        }

        impl<'a> ::core::fmt::Debug for ReplyResultRef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut f = f.debug_struct("ReplyResultRef");
                f.field("result", &self.result());
                f.finish()
            }
        }

        impl<'a> ::core::convert::TryFrom<ReplyResultRef<'a>> for ReplyResult {
            type Error = ::planus::Error;

            #[allow(unreachable_code)]
            fn try_from(value: ReplyResultRef<'a>) -> ::planus::Result<Self> {
                ::core::result::Result::Ok(Self {
                    result: ::core::convert::TryInto::try_into(value.result()?)?,
                })
            }
        }

        impl<'a> ::planus::TableRead<'a> for ReplyResultRef<'a> {
            #[inline]
            fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                    buffer, offset,
                )?))
            }
        }

        impl<'a> ::planus::VectorReadInner<'a> for ReplyResultRef<'a> {
            type Error = ::planus::Error;
            const STRIDE: usize = 4;

            unsafe fn from_buffer(
                buffer: ::planus::SliceWithStartOffset<'a>,
                offset: usize,
            ) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                    error_kind.with_error_location(
                        "[ReplyResultRef]",
                        "get",
                        buffer.offset_from_start,
                    )
                })
            }
        }

        /// # Safety
        /// The planus compiler generates implementations that initialize
        /// the bytes in `write_values`.
        unsafe impl ::planus::VectorWrite<::planus::Offset<ReplyResult>> for ReplyResult {
            type Value = ::planus::Offset<ReplyResult>;
            const STRIDE: usize = 4;
            #[inline]
            fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                ::planus::WriteAs::prepare(self, builder)
            }

            #[inline]
            unsafe fn write_values(
                values: &[::planus::Offset<ReplyResult>],
                bytes: *mut ::core::mem::MaybeUninit<u8>,
                buffer_position: u32,
            ) {
                let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                    ::planus::WriteAsPrimitive::write(
                        v,
                        ::planus::Cursor::new(unsafe { &mut *bytes.add(i) }),
                        buffer_position - (Self::STRIDE * i) as u32,
                    );
                }
            }
        }

        impl<'a> ::planus::ReadAsRoot<'a> for ReplyResultRef<'a> {
            fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                ::planus::TableRead::from_buffer(
                    ::planus::SliceWithStartOffset {
                        buffer: slice,
                        offset_from_start: 0,
                    },
                    0,
                )
                .map_err(|error_kind| {
                    error_kind.with_error_location("[ReplyResultRef]", "read_as_root", 0)
                })
            }
        }
    }
}
